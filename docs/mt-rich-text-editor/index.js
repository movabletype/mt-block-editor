var ob = Object.defineProperty;
var jd = (n) => {
  throw TypeError(n);
};
var ab = (n, e, t) => e in n ? ob(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var _n = (n, e, t) => ab(n, typeof e != "symbol" ? e + "" : e, t), Ol = (n, e, t) => e.has(n) || jd("Cannot " + t);
var G = (n, e, t) => (Ol(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Le = (n, e, t) => e.has(n) ? jd("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Oe = (n, e, t, i) => (Ol(n, e, "write to private field"), i ? i.call(n, t) : e.set(n, t), t), bo = (n, e, t) => (Ol(n, e, "access private method"), t);
import { b as Ya, E as Su, r as Rs, a as Rr, p as Qo, U as lb, h as De, c as Wi, H as cb, d as Vp, e as Lc, s as zi, f as Yn, g as yn, i as jp, j as E, k as ea, I as Nl, l as Wp, q as Up, m as Is, n as Cu, o as Wd, t as Tu, u as gr, v as Ud, w as Kp, x as ub, y as db, z as fb, A as hb, B as Eu, C as qp, D as pb, F as Au, G as Mu, J as mb, K as gb, L as Rc, M as _b, N as bb, O as vb, P as yb, Q as Kd, R as Za, S as jr, T as Ou, V as Qa, W as xb, X as wb, Y as kb, Z as Sb, _ as Cb, $ as Tb, a0 as Eb, a1 as Ab, a2 as Mb, a3 as Ot, a4 as Ob, a5 as Nb, a6 as Lb, a7 as Rb, a8 as Ib, a9 as Pb, aa as Db, ab as $b, ac as Bb, ad as zb, ae as Hb, af as es, ag as qd, ah as Gd, ai as Fb, aj as Vb, ak as Nu, al as jb, am as ys, an as Wb, ao as $e, ap as Jd, aq as Ub, ar as Kb, as as Gp, at as qb, au as Gb, av as ve, aw as ye, ax as Q, ay as Z, az as et, aA as dt, aB as F, aC as xe, aD as ce, aE as q, aF as ee, aG as L, aH as H, aI as O, aJ as wi, aK as Re, aL as Jb, aM as Xb, aN as Ht, aO as Jp, aP as Xp, aQ as ne, aR as Yp, aS as B, aT as Cn, aU as Zp, aV as Wr, aW as Nt, aX as Ic, aY as at, aZ as _r, a_ as Yb, a$ as vo, b0 as Fe, b1 as Tn, b2 as ta, b3 as Zb, b4 as Qb, b5 as Ir, b6 as e1, b7 as t1 } from "./component-DKumGqt1.js";
const n1 = "0.0.1", _e = (n) => typeof n == "string", ts = () => {
  let n, e;
  const t = new Promise((i, r) => {
    n = i, e = r;
  });
  return t.resolve = n, t.reject = e, t;
}, Xd = (n) => n == null ? "" : "" + n, i1 = (n, e, t) => {
  n.forEach((i) => {
    e[i] && (t[i] = e[i]);
  });
}, r1 = /###/g, Yd = (n) => n && n.indexOf("###") > -1 ? n.replace(r1, ".") : n, Zd = (n) => !n || _e(n), xs = (n, e, t) => {
  const i = _e(e) ? e.split(".") : e;
  let r = 0;
  for (; r < i.length - 1; ) {
    if (Zd(n)) return {};
    const s = Yd(i[r]);
    !n[s] && t && (n[s] = new t()), Object.prototype.hasOwnProperty.call(n, s) ? n = n[s] : n = {}, ++r;
  }
  return Zd(n) ? {} : {
    obj: n,
    k: Yd(i[r])
  };
}, Qd = (n, e, t) => {
  const {
    obj: i,
    k: r
  } = xs(n, e, Object);
  if (i !== void 0 || e.length === 1) {
    i[r] = t;
    return;
  }
  let s = e[e.length - 1], o = e.slice(0, e.length - 1), a = xs(n, o, Object);
  for (; a.obj === void 0 && o.length; )
    s = `${o[o.length - 1]}.${s}`, o = o.slice(0, o.length - 1), a = xs(n, o, Object), a != null && a.obj && typeof a.obj[`${a.k}.${s}`] < "u" && (a.obj = void 0);
  a.obj[`${a.k}.${s}`] = t;
}, s1 = (n, e, t, i) => {
  const {
    obj: r,
    k: s
  } = xs(n, e, Object);
  r[s] = r[s] || [], r[s].push(t);
}, na = (n, e) => {
  const {
    obj: t,
    k: i
  } = xs(n, e);
  if (t && Object.prototype.hasOwnProperty.call(t, i))
    return t[i];
}, o1 = (n, e, t) => {
  const i = na(n, t);
  return i !== void 0 ? i : na(e, t);
}, Qp = (n, e, t) => {
  for (const i in e)
    i !== "__proto__" && i !== "constructor" && (i in n ? _e(n[i]) || n[i] instanceof String || _e(e[i]) || e[i] instanceof String ? t && (n[i] = e[i]) : Qp(n[i], e[i], t) : n[i] = e[i]);
  return n;
}, rr = (n) => n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var a1 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const l1 = (n) => _e(n) ? n.replace(/[&<>"'\/]/g, (e) => a1[e]) : n;
class c1 {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const i = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, i), this.regExpQueue.push(e), i;
  }
}
const u1 = [" ", ",", "?", "!", ";"], d1 = new c1(20), f1 = (n, e, t) => {
  e = e || "", t = t || "";
  const i = u1.filter((o) => e.indexOf(o) < 0 && t.indexOf(o) < 0);
  if (i.length === 0) return !0;
  const r = d1.getRegExp(`(${i.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let s = !r.test(n);
  if (!s) {
    const o = n.indexOf(t);
    o > 0 && !r.test(n.substring(0, o)) && (s = !0);
  }
  return s;
}, Pc = function(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!n) return;
  if (n[e])
    return Object.prototype.hasOwnProperty.call(n, e) ? n[e] : void 0;
  const i = e.split(t);
  let r = n;
  for (let s = 0; s < i.length; ) {
    if (!r || typeof r != "object")
      return;
    let o, a = "";
    for (let l = s; l < i.length; ++l)
      if (l !== s && (a += t), a += i[l], o = r[a], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && l < i.length - 1)
          continue;
        s += l - s + 1;
        break;
      }
    r = o;
  }
  return r;
}, ia = (n) => n == null ? void 0 : n.replace("_", "-"), h1 = {
  type: "logger",
  log(n) {
    this.output("log", n);
  },
  warn(n) {
    this.output("warn", n);
  },
  error(n) {
    this.output("error", n);
  },
  output(n, e) {
    var t, i;
    (i = (t = console == null ? void 0 : console[n]) == null ? void 0 : t.apply) == null || i.call(t, console, e);
  }
};
class ra {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || h1, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, i, r) {
    return r && !this.debug ? null : (_e(e[0]) && (e[0] = `${i}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new ra(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new ra(this.logger, e);
  }
}
var Dn = new ra();
let el = class {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((i) => {
      this.observers[i] || (this.observers[i] = /* @__PURE__ */ new Map());
      const r = this.observers[i].get(t) || 0;
      this.observers[i].set(t, r + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      i[r - 1] = arguments[r];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((o) => {
      let [a, l] = o;
      for (let c = 0; c < l; c++)
        a(...i);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [a, l] = o;
      for (let c = 0; c < l; c++)
        a.apply(a, [e, ...i]);
    });
  }
};
class ef extends el {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, i) {
    var c, u;
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const s = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, o = r.ignoreJSONStructure !== void 0 ? r.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let a;
    e.indexOf(".") > -1 ? a = e.split(".") : (a = [e, t], i && (Array.isArray(i) ? a.push(...i) : _e(i) && s ? a.push(...i.split(s)) : a.push(i)));
    const l = na(this.data, a);
    return !l && !t && !i && e.indexOf(".") > -1 && (e = a[0], t = a[1], i = a.slice(2).join(".")), l || !o || !_e(i) ? l : Pc((u = (c = this.data) == null ? void 0 : c[e]) == null ? void 0 : u[t], i, s);
  }
  addResource(e, t, i, r) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator;
    let a = [e, t];
    i && (a = a.concat(o ? i.split(o) : i)), e.indexOf(".") > -1 && (a = e.split("."), r = t, t = a[1]), this.addNamespaces(t), Qd(this.data, a, r), s.silent || this.emit("added", e, t, i, r);
  }
  addResources(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const s in i)
      (_e(i[s]) || Array.isArray(i[s])) && this.addResource(e, t, s, i[s], {
        silent: !0
      });
    r.silent || this.emit("added", e, t, i);
  }
  addResourceBundle(e, t, i, r, s) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, a = [e, t];
    e.indexOf(".") > -1 && (a = e.split("."), r = i, i = t, t = a[1]), this.addNamespaces(t);
    let l = na(this.data, a) || {};
    o.skipCopy || (i = JSON.parse(JSON.stringify(i))), r ? Qp(l, i, s) : l = {
      ...l,
      ...i
    }, Qd(this.data, a, l), o.silent || this.emit("added", e, t, i);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((r) => t[r] && Object.keys(t[r]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var em = {
  processors: {},
  addPostProcessor(n) {
    this.processors[n.name] = n;
  },
  handle(n, e, t, i, r) {
    return n.forEach((s) => {
      var o;
      e = ((o = this.processors[s]) == null ? void 0 : o.process(e, t, i, r)) ?? e;
    }), e;
  }
};
const tf = {}, nf = (n) => !_e(n) && typeof n != "boolean" && typeof n != "number";
class sa extends el {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), i1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Dn.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const i = this.resolve(e, t);
    return (i == null ? void 0 : i.res) !== void 0;
  }
  extractFromKey(e, t) {
    let i = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    i === void 0 && (i = ":");
    const r = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let s = t.ns || this.options.defaultNS || [];
    const o = i && e.indexOf(i) > -1, a = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !f1(e, i, r);
    if (o && !a) {
      const l = e.match(this.interpolator.nestingRegexp);
      if (l && l.length > 0)
        return {
          key: e,
          namespaces: _e(s) ? [s] : s
        };
      const c = e.split(i);
      (i !== r || i === r && this.options.ns.indexOf(c[0]) > -1) && (s = c.shift()), e = c.join(r);
    }
    return {
      key: e,
      namespaces: _e(s) ? [s] : s
    };
  }
  translate(e, t, i) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const r = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, s = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: a
    } = this.extractFromKey(e[e.length - 1], t), l = a[a.length - 1], c = t.lng || this.language, u = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if ((c == null ? void 0 : c.toLowerCase()) === "cimode") {
      if (u) {
        const T = t.nsSeparator || this.options.nsSeparator;
        return r ? {
          res: `${l}${T}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: c,
          usedNS: l,
          usedParams: this.getUsedParamsDetails(t)
        } : `${l}${T}${o}`;
      }
      return r ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: c,
        usedNS: l,
        usedParams: this.getUsedParamsDetails(t)
      } : o;
    }
    const d = this.resolve(e, t);
    let f = d == null ? void 0 : d.res;
    const h = (d == null ? void 0 : d.usedKey) || o, p = (d == null ? void 0 : d.exactUsedKey) || o, b = ["[object Number]", "[object Function]", "[object RegExp]"], m = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, g = !this.i18nFormat || this.i18nFormat.handleAsObject, v = t.count !== void 0 && !_e(t.count), x = sa.hasDefaultValue(t), w = v ? this.pluralResolver.getSuffix(c, t.count, t) : "", S = t.ordinal && v ? this.pluralResolver.getSuffix(c, t.count, {
      ordinal: !1
    }) : "", k = v && !t.ordinal && t.count === 0, C = k && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${w}`] || t[`defaultValue${S}`] || t.defaultValue;
    let y = f;
    g && !f && x && (y = C);
    const A = nf(y), _ = Object.prototype.toString.apply(y);
    if (g && y && A && b.indexOf(_) < 0 && !(_e(m) && Array.isArray(y))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const T = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, y, {
          ...t,
          ns: a
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return r ? (d.res = T, d.usedParams = this.getUsedParamsDetails(t), d) : T;
      }
      if (s) {
        const T = Array.isArray(y), M = T ? [] : {}, z = T ? p : h;
        for (const P in y)
          if (Object.prototype.hasOwnProperty.call(y, P)) {
            const V = `${z}${s}${P}`;
            x && !f ? M[P] = this.translate(V, {
              ...t,
              defaultValue: nf(C) ? C[P] : void 0,
              joinArrays: !1,
              ns: a
            }) : M[P] = this.translate(V, {
              ...t,
              joinArrays: !1,
              ns: a
            }), M[P] === V && (M[P] = y[P]);
          }
        f = M;
      }
    } else if (g && _e(m) && Array.isArray(f))
      f = f.join(m), f && (f = this.extendTranslation(f, e, t, i));
    else {
      let T = !1, M = !1;
      !this.isValidLookup(f) && x && (T = !0, f = C), this.isValidLookup(f) || (M = !0, f = o);
      const P = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && M ? void 0 : f, V = x && C !== f && this.options.updateMissing;
      if (M || T || V) {
        if (this.logger.log(V ? "updateKey" : "missingKey", c, l, o, V ? C : f), s) {
          const te = this.resolve(o, {
            ...t,
            keySeparator: !1
          });
          te && te.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let U = [];
        const J = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && J && J[0])
          for (let te = 0; te < J.length; te++)
            U.push(J[te]);
        else this.options.saveMissingTo === "all" ? U = this.languageUtils.toResolveHierarchy(t.lng || this.language) : U.push(t.lng || this.language);
        const re = (te, ge, se) => {
          var fe;
          const Be = x && se !== f ? se : P;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(te, l, ge, Be, V, t) : (fe = this.backendConnector) != null && fe.saveMissing && this.backendConnector.saveMissing(te, l, ge, Be, V, t), this.emit("missingKey", te, l, ge, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && v ? U.forEach((te) => {
          const ge = this.pluralResolver.getSuffixes(te, t);
          k && t[`defaultValue${this.options.pluralSeparator}zero`] && ge.indexOf(`${this.options.pluralSeparator}zero`) < 0 && ge.push(`${this.options.pluralSeparator}zero`), ge.forEach((se) => {
            re([te], o + se, t[`defaultValue${se}`] || C);
          });
        }) : re(U, o, C));
      }
      f = this.extendTranslation(f, e, t, d, i), M && f === o && this.options.appendNamespaceToMissingKey && (f = `${l}:${o}`), (M || T) && this.options.parseMissingKeyHandler && (f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}:${o}` : o, T ? f : void 0));
    }
    return r ? (d.res = f, d.usedParams = this.getUsedParamsDetails(t), d) : f;
  }
  extendTranslation(e, t, i, r, s) {
    var c, u;
    var o = this;
    if ((c = this.i18nFormat) != null && c.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...i
      }, i.lng || this.language || r.usedLng, r.usedNS, r.usedKey, {
        resolved: r
      });
    else if (!i.skipInterpolation) {
      i.interpolation && this.interpolator.init({
        ...i,
        interpolation: {
          ...this.options.interpolation,
          ...i.interpolation
        }
      });
      const d = _e(e) && (((u = i == null ? void 0 : i.interpolation) == null ? void 0 : u.skipOnVariables) !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let f;
      if (d) {
        const p = e.match(this.interpolator.nestingRegexp);
        f = p && p.length;
      }
      let h = i.replace && !_e(i.replace) ? i.replace : i;
      if (this.options.interpolation.defaultVariables && (h = {
        ...this.options.interpolation.defaultVariables,
        ...h
      }), e = this.interpolator.interpolate(e, h, i.lng || this.language || r.usedLng, i), d) {
        const p = e.match(this.interpolator.nestingRegexp), b = p && p.length;
        f < b && (i.nest = !1);
      }
      !i.lng && r && r.res && (i.lng = this.language || r.usedLng), i.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var p = arguments.length, b = new Array(p), m = 0; m < p; m++)
          b[m] = arguments[m];
        return (s == null ? void 0 : s[0]) === b[0] && !i.context ? (o.logger.warn(`It seems you are nesting recursively key: ${b[0]} in key: ${t[0]}`), null) : o.translate(...b, t);
      }, i)), i.interpolation && this.interpolator.reset();
    }
    const a = i.postProcess || this.options.postProcess, l = _e(a) ? [a] : a;
    return e != null && (l != null && l.length) && i.applyPostProcessor !== !1 && (e = em.handle(l, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...r,
        usedParams: this.getUsedParamsDetails(i)
      },
      ...i
    } : i, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i, r, s, o, a;
    return _e(e) && (e = [e]), e.forEach((l) => {
      if (this.isValidLookup(i)) return;
      const c = this.extractFromKey(l, t), u = c.key;
      r = u;
      let d = c.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = t.count !== void 0 && !_e(t.count), h = f && !t.ordinal && t.count === 0, p = t.context !== void 0 && (_e(t.context) || typeof t.context == "number") && t.context !== "", b = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      d.forEach((m) => {
        var g, v;
        this.isValidLookup(i) || (a = m, !tf[`${b[0]}-${m}`] && ((g = this.utils) != null && g.hasLoadedNamespace) && !((v = this.utils) != null && v.hasLoadedNamespace(a)) && (tf[`${b[0]}-${m}`] = !0, this.logger.warn(`key "${r}" for languages "${b.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), b.forEach((x) => {
          var k;
          if (this.isValidLookup(i)) return;
          o = x;
          const w = [u];
          if ((k = this.i18nFormat) != null && k.addLookupKeys)
            this.i18nFormat.addLookupKeys(w, u, x, m, t);
          else {
            let C;
            f && (C = this.pluralResolver.getSuffix(x, t.count, t));
            const y = `${this.options.pluralSeparator}zero`, A = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (w.push(u + C), t.ordinal && C.indexOf(A) === 0 && w.push(u + C.replace(A, this.options.pluralSeparator)), h && w.push(u + y)), p) {
              const _ = `${u}${this.options.contextSeparator}${t.context}`;
              w.push(_), f && (w.push(_ + C), t.ordinal && C.indexOf(A) === 0 && w.push(_ + C.replace(A, this.options.pluralSeparator)), h && w.push(_ + y));
            }
          }
          let S;
          for (; S = w.pop(); )
            this.isValidLookup(i) || (s = S, i = this.getResource(x, m, S, t));
        }));
      });
    }), {
      res: i,
      usedKey: r,
      exactUsedKey: s,
      usedLng: o,
      usedNS: a
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, i) {
    var s;
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return (s = this.i18nFormat) != null && s.getResource ? this.i18nFormat.getResource(e, t, i, r) : this.resourceStore.getResource(e, t, i, r);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], i = e.replace && !_e(e.replace);
    let r = i ? e.replace : e;
    if (i && typeof e.count < "u" && (r.count = e.count), this.options.interpolation.defaultVariables && (r = {
      ...this.options.interpolation.defaultVariables,
      ...r
    }), !i) {
      r = {
        ...r
      };
      for (const s of t)
        delete r[s];
    }
    return r;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const i in e)
      if (Object.prototype.hasOwnProperty.call(e, i) && t === i.substring(0, t.length) && e[i] !== void 0)
        return !0;
    return !1;
  }
}
class rf {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Dn.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = ia(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = ia(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (_e(e) && e.indexOf("-") > -1) {
      let t;
      try {
        t = Intl.getCanonicalLocales(e)[0];
      } catch {
      }
      return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((i) => {
      if (t) return;
      const r = this.formatLanguageCode(i);
      (!this.options.supportedLngs || this.isSupportedCode(r)) && (t = r);
    }), !t && this.options.supportedLngs && e.forEach((i) => {
      if (t) return;
      const r = this.getLanguagePartFromCode(i);
      if (this.isSupportedCode(r)) return t = r;
      t = this.options.supportedLngs.find((s) => {
        if (s === r) return s;
        if (!(s.indexOf("-") < 0 && r.indexOf("-") < 0) && (s.indexOf("-") > 0 && r.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === r || s.indexOf(r) === 0 && r.length > 1))
          return s;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), _e(e) && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let i = e[t];
    return i || (i = e[this.getScriptPartFromCode(t)]), i || (i = e[this.formatLanguageCode(t)]), i || (i = e[this.getLanguagePartFromCode(t)]), i || (i = e.default), i || [];
  }
  toResolveHierarchy(e, t) {
    const i = this.getFallbackCodes(t || this.options.fallbackLng || [], e), r = [], s = (o) => {
      o && (this.isSupportedCode(o) ? r.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return _e(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(e))) : _e(e) && s(this.formatLanguageCode(e)), i.forEach((o) => {
      r.indexOf(o) < 0 && s(this.formatLanguageCode(o));
    }), r;
  }
}
const sf = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, of = {
  select: (n) => n === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class p1 {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = Dn.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = ia(e === "dev" ? "en" : e), r = t.ordinal ? "ordinal" : "cardinal", s = JSON.stringify({
      cleanedCode: i,
      type: r
    });
    if (s in this.pluralRulesCache)
      return this.pluralRulesCache[s];
    let o;
    try {
      o = new Intl.PluralRules(i, {
        type: r
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), of;
      if (!e.match(/-|_/)) return of;
      const l = this.languageUtils.getLanguagePartFromCode(e);
      o = this.getRule(l, t);
    }
    return this.pluralRulesCache[s] = o, o;
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(e, t);
    return i || (i = this.getRule("dev", t)), (i == null ? void 0 : i.resolvedOptions().pluralCategories.length) > 1;
  }
  getPluralFormsOfKey(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, i).map((r) => `${t}${r}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(e, t);
    return i || (i = this.getRule("dev", t)), i ? i.resolvedOptions().pluralCategories.sort((r, s) => sf[r] - sf[s]).map((r) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${r}`) : [];
  }
  getSuffix(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = this.getRule(e, i);
    return r ? `${this.options.prepend}${i.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, i));
  }
}
const af = function(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, s = o1(n, e, t);
  return !s && r && _e(t) && (s = Pc(n, t, i), s === void 0 && (s = Pc(e, t, i))), s;
}, Ll = (n) => n.replace(/\$/g, "$$$$");
class m1 {
  constructor() {
    var t;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Dn.create("interpolator"), this.options = e, this.format = ((t = e == null ? void 0 : e.interpolation) == null ? void 0 : t.format) || ((i) => i), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: i,
      useRawValueToEscape: r,
      prefix: s,
      prefixEscaped: o,
      suffix: a,
      suffixEscaped: l,
      formatSeparator: c,
      unescapeSuffix: u,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: p,
      nestingSuffixEscaped: b,
      nestingOptionsSeparator: m,
      maxReplaces: g,
      alwaysFormat: v
    } = e.interpolation;
    this.escape = t !== void 0 ? t : l1, this.escapeValue = i !== void 0 ? i : !0, this.useRawValueToEscape = r !== void 0 ? r : !1, this.prefix = s ? rr(s) : o || "{{", this.suffix = a ? rr(a) : l || "}}", this.formatSeparator = c || ",", this.unescapePrefix = u ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : u || "", this.nestingPrefix = f ? rr(f) : h || rr("$t("), this.nestingSuffix = p ? rr(p) : b || rr(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = g || 1e3, this.alwaysFormat = v !== void 0 ? v : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, i) => (t == null ? void 0 : t.source) === i ? (t.lastIndex = 0, t) : new RegExp(i, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, i, r) {
    var h;
    let s, o, a;
    const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = (p) => {
      if (p.indexOf(this.formatSeparator) < 0) {
        const v = af(t, l, p, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, i, {
          ...r,
          ...t,
          interpolationkey: p
        }) : v;
      }
      const b = p.split(this.formatSeparator), m = b.shift().trim(), g = b.join(this.formatSeparator).trim();
      return this.format(af(t, l, m, this.options.keySeparator, this.options.ignoreJSONStructure), g, i, {
        ...r,
        ...t,
        interpolationkey: m
      });
    };
    this.resetRegExp();
    const u = (r == null ? void 0 : r.missingInterpolationHandler) || this.options.missingInterpolationHandler, d = ((h = r == null ? void 0 : r.interpolation) == null ? void 0 : h.skipOnVariables) !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (p) => Ll(p)
    }, {
      regex: this.regexp,
      safeValue: (p) => this.escapeValue ? Ll(this.escape(p)) : Ll(p)
    }].forEach((p) => {
      for (a = 0; s = p.regex.exec(e); ) {
        const b = s[1].trim();
        if (o = c(b), o === void 0)
          if (typeof u == "function") {
            const g = u(e, s, r);
            o = _e(g) ? g : "";
          } else if (r && Object.prototype.hasOwnProperty.call(r, b))
            o = "";
          else if (d) {
            o = s[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${b} for interpolating ${e}`), o = "";
        else !_e(o) && !this.useRawValueToEscape && (o = Xd(o));
        const m = p.safeValue(o);
        if (e = e.replace(s[0], m), d ? (p.regex.lastIndex += o.length, p.regex.lastIndex -= s[0].length) : p.regex.lastIndex = 0, a++, a >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r, s, o;
    const a = (l, c) => {
      const u = this.nestingOptionsSeparator;
      if (l.indexOf(u) < 0) return l;
      const d = l.split(new RegExp(`${u}[ ]*{`));
      let f = `{${d[1]}`;
      l = d[0], f = this.interpolate(f, o);
      const h = f.match(/'/g), p = f.match(/"/g);
      (((h == null ? void 0 : h.length) ?? 0) % 2 === 0 && !p || p.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        o = JSON.parse(f), c && (o = {
          ...c,
          ...o
        });
      } catch (b) {
        return this.logger.warn(`failed parsing options string in nesting for key ${l}`, b), `${l}${u}${f}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, l;
    };
    for (; r = this.nestingRegexp.exec(e); ) {
      let l = [];
      o = {
        ...i
      }, o = o.replace && !_e(o.replace) ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let c = !1;
      if (r[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(r[1])) {
        const u = r[1].split(this.formatSeparator).map((d) => d.trim());
        r[1] = u.shift(), l = u, c = !0;
      }
      if (s = t(a.call(this, r[1].trim(), o), o), s && r[0] === e && !_e(s)) return s;
      _e(s) || (s = Xd(s)), s || (this.logger.warn(`missed to resolve ${r[1]} for nesting ${e}`), s = ""), c && (s = l.reduce((u, d) => this.format(u, d, i.lng, {
        ...i,
        interpolationkey: r[1].trim()
      }), s.trim())), e = e.replace(r[0], s), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
const g1 = (n) => {
  let e = n.toLowerCase().trim();
  const t = {};
  if (n.indexOf("(") > -1) {
    const i = n.split("(");
    e = i[0].toLowerCase().trim();
    const r = i[1].substring(0, i[1].length - 1);
    e === "currency" && r.indexOf(":") < 0 ? t.currency || (t.currency = r.trim()) : e === "relativetime" && r.indexOf(":") < 0 ? t.range || (t.range = r.trim()) : r.split(";").forEach((o) => {
      if (o) {
        const [a, ...l] = o.split(":"), c = l.join(":").trim().replace(/^'+|'+$/g, ""), u = a.trim();
        t[u] || (t[u] = c), c === "false" && (t[u] = !1), c === "true" && (t[u] = !0), isNaN(c) || (t[u] = parseInt(c, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}, sr = (n) => {
  const e = {};
  return (t, i, r) => {
    let s = r;
    r && r.interpolationkey && r.formatParams && r.formatParams[r.interpolationkey] && r[r.interpolationkey] && (s = {
      ...s,
      [r.interpolationkey]: void 0
    });
    const o = i + JSON.stringify(s);
    let a = e[o];
    return a || (a = n(ia(i), r), e[o] = a), a(t);
  };
};
class _1 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Dn.create("formatter"), this.options = e, this.formats = {
      number: sr((t, i) => {
        const r = new Intl.NumberFormat(t, {
          ...i
        });
        return (s) => r.format(s);
      }),
      currency: sr((t, i) => {
        const r = new Intl.NumberFormat(t, {
          ...i,
          style: "currency"
        });
        return (s) => r.format(s);
      }),
      datetime: sr((t, i) => {
        const r = new Intl.DateTimeFormat(t, {
          ...i
        });
        return (s) => r.format(s);
      }),
      relativetime: sr((t, i) => {
        const r = new Intl.RelativeTimeFormat(t, {
          ...i
        });
        return (s) => r.format(s, i.range || "day");
      }),
      list: sr((t, i) => {
        const r = new Intl.ListFormat(t, {
          ...i
        });
        return (s) => r.format(s);
      })
    }, this.init(e);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = t.interpolation.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = sr(t);
  }
  format(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const s = t.split(this.formatSeparator);
    if (s.length > 1 && s[0].indexOf("(") > 1 && s[0].indexOf(")") < 0 && s.find((a) => a.indexOf(")") > -1)) {
      const a = s.findIndex((l) => l.indexOf(")") > -1);
      s[0] = [s[0], ...s.splice(1, a)].join(this.formatSeparator);
    }
    return s.reduce((a, l) => {
      var d;
      const {
        formatName: c,
        formatOptions: u
      } = g1(l);
      if (this.formats[c]) {
        let f = a;
        try {
          const h = ((d = r == null ? void 0 : r.formatParams) == null ? void 0 : d[r.interpolationkey]) || {}, p = h.locale || h.lng || r.locale || r.lng || i;
          f = this.formats[c](a, p, {
            ...u,
            ...r,
            ...h
          });
        } catch (h) {
          this.logger.warn(h);
        }
        return f;
      } else
        this.logger.warn(`there was no format function for ${c}`);
      return a;
    }, e);
  }
}
const b1 = (n, e) => {
  n.pending[e] !== void 0 && (delete n.pending[e], n.pendingCount--);
};
class v1 extends el {
  constructor(e, t, i) {
    var s, o;
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = i, this.languageUtils = i.languageUtils, this.options = r, this.logger = Dn.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = r.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5, this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350, this.state = {}, this.queue = [], (o = (s = this.backend) == null ? void 0 : s.init) == null || o.call(s, i, r.backend, r);
  }
  queueLoad(e, t, i, r) {
    const s = {}, o = {}, a = {}, l = {};
    return e.forEach((c) => {
      let u = !0;
      t.forEach((d) => {
        const f = `${c}|${d}`;
        !i.reload && this.store.hasResourceBundle(c, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? o[f] === void 0 && (o[f] = !0) : (this.state[f] = 1, u = !1, o[f] === void 0 && (o[f] = !0), s[f] === void 0 && (s[f] = !0), l[d] === void 0 && (l[d] = !0)));
      }), u || (a[c] = !0);
    }), (Object.keys(s).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: r
    }), {
      toLoad: Object.keys(s),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(a),
      toLoadNamespaces: Object.keys(l)
    };
  }
  loaded(e, t, i) {
    const r = e.split("|"), s = r[0], o = r[1];
    t && this.emit("failedLoading", s, o, t), !t && i && this.store.addResourceBundle(s, o, i, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2, t && i && (this.state[e] = 0);
    const a = {};
    this.queue.forEach((l) => {
      s1(l.loaded, [s], o), b1(l, e), t && l.errors.push(t), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach((c) => {
        a[c] || (a[c] = {});
        const u = l.loaded[c];
        u.length && u.forEach((d) => {
          a[c][d] === void 0 && (a[c][d] = !0);
        });
      }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback());
    }), this.emit("loaded", a), this.queue = this.queue.filter((l) => !l.done);
  }
  read(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: i,
        tried: r,
        wait: s,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const a = (c, u) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (c && u && r < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, i, r + 1, s * 2, o);
        }, s);
        return;
      }
      o(c, u);
    }, l = this.backend[i].bind(this.backend);
    if (l.length === 2) {
      try {
        const c = l(e, t);
        c && typeof c.then == "function" ? c.then((u) => a(null, u)).catch(a) : a(null, c);
      } catch (c) {
        a(c);
      }
      return;
    }
    return l(e, t, a);
  }
  prepareLoading(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), r && r();
    _e(e) && (e = this.languageUtils.toResolveHierarchy(e)), _e(t) && (t = [t]);
    const s = this.queueLoad(e, t, i, r);
    if (!s.toLoad.length)
      return s.pending.length || r(), null;
    s.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(e, t, i) {
    this.prepareLoading(e, t, {}, i);
  }
  reload(e, t, i) {
    this.prepareLoading(e, t, {
      reload: !0
    }, i);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const i = e.split("|"), r = i[0], s = i[1];
    this.read(r, s, "read", void 0, void 0, (o, a) => {
      o && this.logger.warn(`${t}loading namespace ${s} for language ${r} failed`, o), !o && a && this.logger.log(`${t}loaded namespace ${s} for language ${r}`, a), this.loaded(e, o, a);
    });
  }
  saveMissing(e, t, i, r, s) {
    var l, c, u, d, f;
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if ((c = (l = this.services) == null ? void 0 : l.utils) != null && c.hasLoadedNamespace && !((d = (u = this.services) == null ? void 0 : u.utils) != null && d.hasLoadedNamespace(t))) {
      this.logger.warn(`did not save key "${i}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(i == null || i === "")) {
      if ((f = this.backend) != null && f.create) {
        const h = {
          ...o,
          isUpdate: s
        }, p = this.backend.create.bind(this.backend);
        if (p.length < 6)
          try {
            let b;
            p.length === 5 ? b = p(e, t, i, r, h) : b = p(e, t, i, r), b && typeof b.then == "function" ? b.then((m) => a(null, m)).catch(a) : a(null, b);
          } catch (b) {
            a(b);
          }
        else
          p(e, t, i, r, a, h);
      }
      !e || !e[0] || this.store.addResource(e[0], t, i, r);
    }
  }
}
const lf = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (n) => {
    let e = {};
    if (typeof n[1] == "object" && (e = n[1]), _e(n[1]) && (e.defaultValue = n[1]), _e(n[2]) && (e.tDescription = n[2]), typeof n[2] == "object" || typeof n[3] == "object") {
      const t = n[3] || n[2];
      Object.keys(t).forEach((i) => {
        e[i] = t[i];
      });
    }
    return e;
  },
  interpolation: {
    escapeValue: !0,
    format: (n) => n,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), cf = (n) => {
  var e, t;
  return _e(n.ns) && (n.ns = [n.ns]), _e(n.fallbackLng) && (n.fallbackLng = [n.fallbackLng]), _e(n.fallbackNS) && (n.fallbackNS = [n.fallbackNS]), ((t = (e = n.supportedLngs) == null ? void 0 : e.indexOf) == null ? void 0 : t.call(e, "cimode")) < 0 && (n.supportedLngs = n.supportedLngs.concat(["cimode"])), typeof n.initImmediate == "boolean" && (n.initAsync = n.initImmediate), n;
}, yo = () => {
}, y1 = (n) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((t) => {
    typeof n[t] == "function" && (n[t] = n[t].bind(n));
  });
};
class Ps extends el {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = cf(e), this.services = {}, this.logger = Dn, this.modules = {
      external: []
    }, y1(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initAsync)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (i = t, t = {}), t.defaultNS == null && t.ns && (_e(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const r = lf();
    this.options = {
      ...r,
      ...this.options,
      ...cf(t)
    }, this.options.interpolation = {
      ...r.interpolation,
      ...this.options.interpolation
    }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const s = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? Dn.init(s(this.modules.logger), this.options) : Dn.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : u = _1;
      const d = new rf(this.options);
      this.store = new ef(this.options.resources, this.options);
      const f = this.services;
      f.logger = Dn, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new p1(d, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), u && (!this.options.interpolation.format || this.options.interpolation.format === r.interpolation.format) && (f.formatter = s(u), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new m1(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new v1(s(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var p = arguments.length, b = new Array(p > 1 ? p - 1 : 0), m = 1; m < p; m++)
          b[m - 1] = arguments[m];
        e.emit(h, ...b);
      }), this.modules.languageDetector && (f.languageDetector = s(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = s(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new sa(this.services, this.options), this.translator.on("*", function(h) {
        for (var p = arguments.length, b = new Array(p > 1 ? p - 1 : 0), m = 1; m < p; m++)
          b[m - 1] = arguments[m];
        e.emit(h, ...b);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, i || (i = yo), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = function() {
        return e.store[u](...arguments), e;
      };
    });
    const l = ts(), c = () => {
      const u = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), l.resolve(f), i(d, f);
      };
      if (this.languages && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initAsync ? c() : setTimeout(c, 0), l;
  }
  loadResources(e) {
    var s, o;
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yo;
    const r = _e(e) ? e : this.language;
    if (typeof e == "function" && (i = e), !this.options.resources || this.options.partialBundledLanguages) {
      if ((r == null ? void 0 : r.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return i();
      const a = [], l = (c) => {
        if (!c || c === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(c).forEach((d) => {
          d !== "cimode" && a.indexOf(d) < 0 && a.push(d);
        });
      };
      r ? l(r) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((u) => l(u)), (o = (s = this.options.preload) == null ? void 0 : s.forEach) == null || o.call(s, (c) => l(c)), this.services.backendConnector.load(a, this.options.ns, (c) => {
        !c && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), i(c);
      });
    } else
      i(null);
  }
  reloadResources(e, t, i) {
    const r = ts();
    return typeof e == "function" && (i = e, e = void 0), typeof t == "function" && (i = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), i || (i = yo), this.services.backendConnector.reload(e, t, (s) => {
      r.resolve(), i(s);
    }), r;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && em.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const i = this.languages[t];
        if (!(["cimode", "dev"].indexOf(i) > -1) && this.store.hasLanguageSomeTranslations(i)) {
          this.resolvedLanguage = i;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var i = this;
    this.isLanguageChangingTo = e;
    const r = ts();
    this.emit("languageChanging", e);
    const s = (l) => {
      this.language = l, this.languages = this.services.languageUtils.toResolveHierarchy(l), this.resolvedLanguage = void 0, this.setResolvedLanguage(l);
    }, o = (l, c) => {
      c ? (s(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, r.resolve(function() {
        return i.t(...arguments);
      }), t && t(l, function() {
        return i.t(...arguments);
      });
    }, a = (l) => {
      var u, d;
      !e && !l && this.services.languageDetector && (l = []);
      const c = _e(l) ? l : this.services.languageUtils.getBestMatchFromCodes(l);
      c && (this.language || s(c), this.translator.language || this.translator.changeLanguage(c), (d = (u = this.services.languageDetector) == null ? void 0 : u.cacheUserLanguage) == null || d.call(u, c)), this.loadResources(c, (f) => {
        o(f, c);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), r;
  }
  getFixedT(e, t, i) {
    var r = this;
    const s = function(o, a) {
      let l;
      if (typeof a != "object") {
        for (var c = arguments.length, u = new Array(c > 2 ? c - 2 : 0), d = 2; d < c; d++)
          u[d - 2] = arguments[d];
        l = r.options.overloadTranslationOptionHandler([o, a].concat(u));
      } else
        l = {
          ...a
        };
      l.lng = l.lng || s.lng, l.lngs = l.lngs || s.lngs, l.ns = l.ns || s.ns, l.keyPrefix !== "" && (l.keyPrefix = l.keyPrefix || i || s.keyPrefix);
      const f = r.options.keySeparator || ".";
      let h;
      return l.keyPrefix && Array.isArray(o) ? h = o.map((p) => `${l.keyPrefix}${f}${p}`) : h = l.keyPrefix ? `${l.keyPrefix}${f}${o}` : o, r.t(h, l);
    };
    return _e(e) ? s.lng = e : s.lngs = e, s.ns = t, s.keyPrefix = i, s;
  }
  t() {
    var r;
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return (r = this.translator) == null ? void 0 : r.translate(...t);
  }
  exists() {
    var r;
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return (r = this.translator) == null ? void 0 : r.exists(...t);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const i = t.lng || this.resolvedLanguage || this.languages[0], r = this.options ? this.options.fallbackLng : !1, s = this.languages[this.languages.length - 1];
    if (i.toLowerCase() === "cimode") return !0;
    const o = (a, l) => {
      const c = this.services.backendConnector.state[`${a}|${l}`];
      return c === -1 || c === 0 || c === 2;
    };
    if (t.precheck) {
      const a = t.precheck(this, o);
      if (a !== void 0) return a;
    }
    return !!(this.hasResourceBundle(i, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(i, e) && (!r || o(s, e)));
  }
  loadNamespaces(e, t) {
    const i = ts();
    return this.options.ns ? (_e(e) && (e = [e]), e.forEach((r) => {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }), this.loadResources((r) => {
      i.resolve(), t && t(r);
    }), i) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const i = ts();
    _e(e) && (e = [e]);
    const r = this.options.preload || [], s = e.filter((o) => r.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return s.length ? (this.options.preload = r.concat(s), this.loadResources((o) => {
      i.resolve(), t && t(o);
    }), i) : (t && t(), Promise.resolve());
  }
  dir(e) {
    var r, s;
    if (e || (e = this.resolvedLanguage || (((r = this.languages) == null ? void 0 : r.length) > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], i = ((s = this.services) == null ? void 0 : s.languageUtils) || new rf(lf());
    return t.indexOf(i.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new Ps(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yo;
    const i = e.forkResourceStore;
    i && delete e.forkResourceStore;
    const r = {
      ...this.options,
      ...e,
      isClone: !0
    }, s = new Ps(r);
    if ((e.debug !== void 0 || e.prefix !== void 0) && (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach((a) => {
      s[a] = this[a];
    }), s.services = {
      ...this.services
    }, s.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, i) {
      const a = Object.keys(this.store.data).reduce((l, c) => (l[c] = {
        ...this.store.data[c]
      }, Object.keys(l[c]).reduce((u, d) => (u[d] = {
        ...l[c][d]
      }, u), {})), {});
      s.store = new ef(a, r), s.services.resourceStore = s.store;
    }
    return s.translator = new sa(s.services, r), s.translator.on("*", function(a) {
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)
        c[u - 1] = arguments[u];
      s.emit(a, ...c);
    }), s.init(r, t), s.translator.options = r, s.translator.backendConnector.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, s;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Qe = Ps.createInstance();
Qe.createInstance = Ps.createInstance;
Qe.createInstance;
Qe.dir;
Qe.init;
Qe.loadResources;
Qe.reloadResources;
Qe.use;
Qe.changeLanguage;
Qe.getFixedT;
Qe.t;
Qe.exists;
Qe.setDefaultNamespace;
Qe.hasLoadedNamespace;
Qe.loadNamespaces;
Qe.loadLanguages;
const x1 = "", w1 = "", k1 = "", S1 = "", C1 = "", T1 = "", E1 = "", A1 = "", M1 = "", O1 = "", N1 = "", L1 = "", R1 = "", I1 = "", P1 = "", D1 = "", $1 = "", B1 = "", z1 = "", H1 = "", F1 = "", V1 = "", j1 = "", W1 = "", U1 = "", K1 = "", q1 = "", G1 = "", J1 = "", X1 = "", Y1 = "", Z1 = "", Q1 = "", ev = "URL", tv = "", nv = "", iv = "", rv = "", sv = "", ov = "", av = "", lv = "", cv = {
  HORIZONTAL_ALIGN_JUSTIFY: x1,
  "Align Right": "",
  "Insert Image": "",
  "Column group": "",
  "Full Screen": "",
  Undo: w1,
  "Delete column": "",
  Row: k1,
  Blockquote: S1,
  "Available Paragraph Styles": "",
  Title: C1,
  "Ordered List": "",
  "Select All": "",
  "Insert column after": "",
  "Link URL": "URL",
  "Cell type": "",
  "Insert HTML": "HTML",
  "Link Text": "",
  "Insert row before": "",
  "Cell properties": "",
  "Parameters for oEmbed API": "oEmbed API",
  Toolbar: T1,
  "Align Center": "",
  HORIZONTAL_ALIGN_CENTER: E1,
  Table: A1,
  Scope: M1,
  "Toggle to HTML structure editing mode": "HTML",
  Column: O1,
  "Select the properties you want to keep in the pasted HTML. Unselected properties will be removed.": "style",
  "Insert (s)": " (s)",
  "Select the data attributes you want to keep in the pasted HTML. Unselected attributes will be removed.": "",
  Width: N1,
  "Specify the default value of a parameter when using the oEmbed API to obtain the embed code for content from an external service. <br>Since the handling of the specified parameters depends on the specifications of each service, it may not always be embedded at the specified size.": "oEmbed API<br>",
  "Text Color": "",
  "Select items to use in the toolbar.": "",
  'Specify the color to be used for "Text color" and "highlight color".': "",
  Cell: L1,
  Boilerplate: R1,
  "Merge cells": "",
  "Row Properties": "",
  "Embed webpage as card": " ()",
  "Table properties": "",
  "Link Target": "...",
  "Paste as HTML": "HTML",
  "Cell Spacing": "",
  "Cell Padding": "",
  "Add color to the palette": "",
  MTRichTextEditor: I1,
  "Bullet List": "",
  Link: P1,
  "Paste as link": "",
  "Insert row after": "",
  Paragraph: D1,
  "Horizontal align": "",
  "Edit Link": "",
  Unlink: $1,
  "Align Left": "",
  Indent: B1,
  "Color Palette": "",
  "Delete row": "",
  "Insert table": "",
  None: z1,
  "Highlight Color": "",
  "Paste as text": "",
  Text: H1,
  Style: F1,
  "Insert column before": "",
  "Edit Image": "",
  File: V1,
  "Heading 4": " 4",
  "Delete table": "",
  Underline: j1,
  VERTICAL_ALIGN_MIDDLE: W1,
  "Heading 6": " 6",
  "MTRichTextEditor Settings": "",
  "Border Width": "",
  "Cancel (x)": " (x)",
  "Cell Properties": "",
  "Data attributes": "",
  "Source Code": "",
  "Heading 3": " 3",
  Italic: U1,
  Redo: K1,
  "Select the style to be used in the paragraph style.": "",
  VERTICAL_ALIGN_BOTTOM: q1,
  "Embed object": "",
  Preformatted: G1,
  "Toggle to HTML editing mode": "HTML",
  "Horizontal Rule": "",
  "Heading 2": " 2",
  LINK_TARGET_BLANK: J1,
  "Split cell": "",
  "Vertical align": "",
  "Insert Link": "",
  "Remove Format": "",
  HORIZONTAL_ALIGN_RIGHT: X1,
  VERTICAL_ALIGN_TOP: Y1,
  "Header cell": "",
  Height: Z1,
  "Properties for style attributes": "style",
  "Convert from Markdown": "Markdown",
  "Embed inline": "",
  HORIZONTAL_ALIGN_LEFT: Q1,
  URL: ev,
  "Embed webpage as inline link": " ()",
  "Failed to get embed object": "",
  "Edit attributes": "",
  Cancel: tv,
  "Heading 5": " 5",
  "Available Items": "",
  "Heading 1": " 1",
  "Paragraph Styles": "",
  "Insert File": "",
  Bold: nv,
  Strike: iv,
  Insert: rv,
  "Table Properties": "",
  "Row group": "",
  LINK_TARGET_SELF: sv,
  "Delete Image": "",
  "Save (s)": " (s)",
  "Row properties": "",
  "Class name": "",
  Outdent: ov,
  Image: av,
  Save: lv,
  "Insert Boilerplate": ""
}, uv = "Middle", dv = "New window", fv = "Justify", hv = "Bottom", pv = "Top", mv = "Current window", gv = "Left", _v = "Right", bv = "Center", vv = {
  VERTICAL_ALIGN_MIDDLE: uv,
  LINK_TARGET_BLANK: dv,
  "Vertical align": "Vertical align",
  HORIZONTAL_ALIGN_JUSTIFY: fv,
  VERTICAL_ALIGN_BOTTOM: hv,
  VERTICAL_ALIGN_TOP: pv,
  LINK_TARGET_SELF: mv,
  HORIZONTAL_ALIGN_LEFT: gv,
  HORIZONTAL_ALIGN_RIGHT: _v,
  HORIZONTAL_ALIGN_CENTER: bv
};
Qe.init({
  fallbackLng: "en",
  resources: {
    ja: {
      translation: cv
    },
    en: {
      translation: vv
    }
  }
});
const I = (...n) => {
  if (typeof n[0] == "string")
    return Qe.t(...n);
  {
    let e = "";
    const [t, ...i] = n;
    for (let r = 0; r < t.length; r++)
      e += t[r] + Qe.t(i[r]);
    return e;
  }
};
function yt(n) {
  this.content = n;
}
yt.prototype = {
  constructor: yt,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var i = t && t != n ? this.remove(t) : this, r = i.find(n), s = i.content.slice();
    return r == -1 ? s.push(t || n, e) : (s[r + 1] = e, t && (s[r] = t)), new yt(s);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new yt(t);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new yt([n, e].concat(this.remove(n).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new yt(t);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var i = this.remove(e), r = i.content.slice(), s = i.find(n);
    return r.splice(s == -1 ? r.length : s, 0, e, t), new yt(r);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = yt.from(n), n.size ? new yt(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = yt.from(n), n.size ? new yt(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = yt.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
yt.from = function(n) {
  if (n instanceof yt) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new yt(e);
};
function tm(n, e, t) {
  for (let i = 0; ; i++) {
    if (i == n.childCount || i == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let r = n.child(i), s = e.child(i);
    if (r == s) {
      t += r.nodeSize;
      continue;
    }
    if (!r.sameMarkup(s))
      return t;
    if (r.isText && r.text != s.text) {
      for (let o = 0; r.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (r.content.size || s.content.size) {
      let o = tm(r.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += r.nodeSize;
  }
}
function nm(n, e, t, i) {
  for (let r = n.childCount, s = e.childCount; ; ) {
    if (r == 0 || s == 0)
      return r == s ? null : { a: t, b: i };
    let o = n.child(--r), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      t -= l, i -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: t, b: i };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, t--, i--;
      return { a: t, b: i };
    }
    if (o.content.size || a.content.size) {
      let c = nm(o.content, a.content, t - 1, i - 1);
      if (c)
        return c;
    }
    t -= l, i -= l;
  }
}
class $ {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let i = 0; i < e.length; i++)
        this.size += e[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, i, r = 0, s) {
    for (let o = 0, a = 0; a < t; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && i(l, r + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, t - u), i, r + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, i, r) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, t - l) : a.isLeaf ? r ? typeof r == "function" ? r(a) : r : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && i && (o ? o = !1 : s += i), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, i = e.firstChild, r = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(i) && (r[r.length - 1] = t.withText(t.text + i.text), s = 1); s < e.content.length; s++)
      r.push(e.content[s]);
    return new $(r, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let i = [], r = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > t) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, t - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, t - o - 1))), i.push(a), r += a.nodeSize), o = l;
      }
    return new $(i, r);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? $.empty : e == 0 && t == this.content.length ? this : new $(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let i = this.content[e];
    if (i == t)
      return this;
    let r = this.content.slice(), s = this.size + t.nodeSize - i.nodeSize;
    return r[e] = t, new $(r, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new $([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new $(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, i = 0; t < this.content.length; t++) {
      let r = this.content[t];
      e(r, i, t), i += r.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return tm(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, i = e.size) {
    return nm(this, e, t, i);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, t = -1) {
    if (e == 0)
      return xo(0, e);
    if (e == this.size)
      return xo(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let i = 0, r = 0; ; i++) {
      let s = this.child(i), o = r + s.nodeSize;
      if (o >= e)
        return o == e || t > 0 ? xo(i + 1, o) : xo(i, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return $.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return $.empty;
    let t, i = 0;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      i += s.nodeSize, r && s.isText && e[r - 1].sameMarkup(s) ? (t || (t = e.slice(0, r)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new $(t || e, i);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return $.empty;
    if (e instanceof $)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new $([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
$.empty = new $([], 0);
const Rl = { index: 0, offset: 0 };
function xo(n, e) {
  return Rl.index = n, Rl.offset = e, Rl;
}
function oa(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (!oa(n[i], e[i]))
        return !1;
  } else {
    for (let i in n)
      if (!(i in e) || !oa(n[i], e[i]))
        return !1;
    for (let i in e)
      if (!(i in n))
        return !1;
  }
  return !0;
}
let Ve = class Dc {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, i = !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, r));
      else {
        if (s.type.excludes(this.type))
          return e;
        !i && s.type.rank > this.type.rank && (t || (t = e.slice(0, r)), t.push(this), i = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), i || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && oa(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let i = e.marks[t.type];
    if (!i)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let r = i.create(t.attrs);
    return i.checkAttrs(r.attrs), r;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (!e[i].eq(t[i]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Dc.none;
    if (e instanceof Dc)
      return [e];
    let t = e.slice();
    return t.sort((i, r) => i.type.rank - r.type.rank), t;
  }
};
Ve.none = [];
class aa extends Error {
}
class Y {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, i) {
    this.content = e, this.openStart = t, this.openEnd = i;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let i = rm(this.content, e + this.openStart, t);
    return i && new Y(i, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new Y(im(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return Y.empty;
    let i = t.openStart || 0, r = t.openEnd || 0;
    if (typeof i != "number" || typeof r != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Y($.fromJSON(e, t.content), i, r);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let i = 0, r = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      i++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      r++;
    return new Y(e, i, r);
  }
}
Y.empty = new Y($.empty, 0, 0);
function im(n, e, t) {
  let { index: i, offset: r } = n.findIndex(e), s = n.maybeChild(i), { index: o, offset: a } = n.findIndex(t);
  if (r == e || s.isText) {
    if (a != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (i != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(i, s.copy(im(s.content, e - r - 1, t - r - 1)));
}
function rm(n, e, t, i) {
  let { index: r, offset: s } = n.findIndex(e), o = n.maybeChild(r);
  if (s == e || o.isText)
    return n.cut(0, e).append(t).append(n.cut(e));
  let a = rm(o.content, e - s - 1, t);
  return a && n.replaceChild(r, o.copy(a));
}
function yv(n, e, t) {
  if (t.openStart > n.depth)
    throw new aa("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new aa("Inconsistent open depths");
  return sm(n, e, t, 0);
}
function sm(n, e, t, i) {
  let r = n.index(i), s = n.node(i);
  if (r == e.index(i) && i < n.depth - t.openStart) {
    let o = sm(n, e, t, i + 1);
    return s.copy(s.content.replaceChild(r, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == i && e.depth == i) {
      let o = n.parent, a = o.content;
      return Fi(o, a.cut(0, n.parentOffset).append(t.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = xv(t, n);
      return Fi(s, am(n, o, a, e, i));
    }
  else return Fi(s, la(n, e, i));
}
function om(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new aa("Cannot join " + e.type.name + " onto " + n.type.name);
}
function $c(n, e, t) {
  let i = n.node(t);
  return om(i, e.node(t)), i;
}
function Hi(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function ws(n, e, t, i) {
  let r = (e || n).node(t), s = 0, o = e ? e.index(t) : r.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (Hi(n.nodeAfter, i), s++));
  for (let a = s; a < o; a++)
    Hi(r.child(a), i);
  e && e.depth == t && e.textOffset && Hi(e.nodeBefore, i);
}
function Fi(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function am(n, e, t, i, r) {
  let s = n.depth > r && $c(n, e, r + 1), o = i.depth > r && $c(t, i, r + 1), a = [];
  return ws(null, n, r, a), s && o && e.index(r) == t.index(r) ? (om(s, o), Hi(Fi(s, am(n, e, t, i, r + 1)), a)) : (s && Hi(Fi(s, la(n, e, r + 1)), a), ws(e, t, r, a), o && Hi(Fi(o, la(t, i, r + 1)), a)), ws(i, null, r, a), new $(a);
}
function la(n, e, t) {
  let i = [];
  if (ws(null, n, t, i), n.depth > t) {
    let r = $c(n, e, t + 1);
    Hi(Fi(r, la(n, e, t + 1)), i);
  }
  return ws(e, null, t, i), new $(i);
}
function xv(n, e) {
  let t = e.depth - n.openStart, r = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    r = e.node(s).copy($.from(r));
  return {
    start: r.resolveNoCache(n.openStart + t),
    end: r.resolveNoCache(r.content.size - n.openEnd - t)
  };
}
class Ds {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.pos = e, this.path = t, this.parentOffset = i, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let i = this.pos - this.path[this.path.length - 1], r = e.child(t);
    return i ? e.child(t).cut(i) : r;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let i = this.path[t * 3], r = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      r += i.child(s).nodeSize;
    return r;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return Ve.none;
    if (this.textOffset)
      return e.child(t).marks;
    let i = e.maybeChild(t - 1), r = e.maybeChild(t);
    if (!i) {
      let a = i;
      i = r, r = a;
    }
    let s = i.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!r || !s[o].isInSet(r.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let i = t.marks, r = e.parent.maybeChild(e.index());
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!r || !i[s].isInSet(r.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let i = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); i >= 0; i--)
      if (e.pos <= this.end(i) && (!t || t(this.node(i))))
        return new ca(this, e, i);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let i = [], r = 0, s = t;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), c = s - l;
      if (i.push(o, a, r + l), !c || (o = o.child(a), o.isText))
        break;
      s = c - 1, r += l + 1;
    }
    return new Ds(t, i, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let i = uf.get(e);
    if (i)
      for (let s = 0; s < i.elts.length; s++) {
        let o = i.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      uf.set(e, i = new wv());
    let r = i.elts[i.i] = Ds.resolve(e, t);
    return i.i = (i.i + 1) % kv, r;
  }
}
class wv {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const kv = 12, uf = /* @__PURE__ */ new WeakMap();
class ca {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, i) {
    this.$from = e, this.$to = t, this.depth = i;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const Sv = /* @__PURE__ */ Object.create(null);
let Bn = class Bc {
  /**
  @internal
  */
  constructor(e, t, i, r = Ve.none) {
    this.type = e, this.attrs = t, this.marks = r, this.content = i || $.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, i, r = 0) {
    this.content.nodesBetween(e, t, i, r, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, t, i, r) {
    return this.content.textBetween(e, t, i, r);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, i) {
    return this.type == e && oa(this.attrs, t || e.defaultAttrs || Sv) && Ve.sameSet(this.marks, i || Ve.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Bc(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Bc(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, i = !1) {
    if (e == t)
      return Y.empty;
    let r = this.resolve(e), s = this.resolve(t), o = i ? 0 : r.sharedDepth(t), a = r.start(o), c = r.node(o).content.cut(r.pos - a, s.pos - a);
    return new Y(c, r.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, i) {
    return yv(this.resolve(e), this.resolve(t), i);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: i, offset: r } = t.content.findIndex(e);
      if (t = t.maybeChild(i), !t)
        return null;
      if (r == e || t.isText)
        return t;
      e -= r + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: i } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: i };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: i } = this.content.findIndex(e);
    if (i < e)
      return { node: this.content.child(t), index: t, offset: i };
    let r = this.content.child(t - 1);
    return { node: r, index: t - 1, offset: i - r.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Ds.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Ds.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, i) {
    let r = !1;
    return t > e && this.nodesBetween(e, t, (s) => (i.isInSet(s.marks) && (r = !0), !r)), r;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), lm(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, i = $.empty, r = 0, s = i.childCount) {
    let o = this.contentMatchAt(e).matchFragment(i, r, s), a = o && o.matchFragment(this.content, t);
    if (!a || !a.validEnd)
      return !1;
    for (let l = r; l < s; l++)
      if (!this.type.allowsMarks(i.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, i, r) {
    if (r && !this.type.allowsMarks(r))
      return !1;
    let s = this.contentMatchAt(e).matchType(i), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Ve.none;
    for (let t = 0; t < this.marks.length; t++) {
      let i = this.marks[t];
      i.type.checkAttrs(i.attrs), e = i.addToSet(e);
    }
    if (!Ve.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let i;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      i = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, i);
    }
    let r = $.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, r, i);
    return s.type.checkAttrs(s.attrs), s;
  }
};
Bn.prototype.text = void 0;
class ua extends Bn {
  /**
  @internal
  */
  constructor(e, t, i, r) {
    if (super(e, t, null, r), !i)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = i;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : lm(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new ua(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new ua(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function lm(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class Ui {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let i = new Cv(e, t);
    if (i.next == null)
      return Ui.empty;
    let r = cm(i);
    i.next && i.err("Unexpected trailing text");
    let s = Lv(Nv(r));
    return Rv(s, i), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, i = e.childCount) {
    let r = this;
    for (let s = t; r && s < i; s++)
      r = r.matchType(e.child(s).type);
    return r;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let i = 0; i < e.next.length; i++)
        if (this.next[t].type == e.next[i].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, i = 0) {
    let r = [this];
    function s(o, a) {
      let l = o.matchFragment(e, i);
      if (l && (!t || l.validEnd))
        return $.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: d } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && r.indexOf(d) == -1) {
          r.push(d);
          let f = s(d, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == e)
        return this.wrapCache[i + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), i = [{ match: this, type: null, via: null }];
    for (; i.length; ) {
      let r = i.shift(), s = r.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = r; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in t) && (!r.type || l.validEnd) && (i.push({ match: a.contentMatch, type: a, via: r }), t[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(i) {
      e.push(i);
      for (let r = 0; r < i.next.length; r++)
        e.indexOf(i.next[r].next) == -1 && t(i.next[r].next);
    }
    return t(this), e.map((i, r) => {
      let s = r + (i.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < i.next.length; o++)
        s += (o ? ", " : "") + i.next[o].type.name + "->" + e.indexOf(i.next[o].next);
      return s;
    }).join(`
`);
  }
}
Ui.empty = new Ui(!0);
class Cv {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function cm(n) {
  let e = [];
  do
    e.push(Tv(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function Tv(n) {
  let e = [];
  do
    e.push(Ev(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Ev(n) {
  let e = Ov(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = Av(n, e);
    else
      break;
  return e;
}
function df(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function Av(n, e) {
  let t = df(n), i = t;
  return n.eat(",") && (n.next != "}" ? i = df(n) : i = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: i, expr: e };
}
function Mv(n, e) {
  let t = n.nodeTypes, i = t[e];
  if (i)
    return [i];
  let r = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && r.push(o);
  }
  return r.length == 0 && n.err("No node type or group '" + e + "' found"), r;
}
function Ov(n) {
  if (n.eat("(")) {
    let e = cm(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = Mv(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function Nv(n) {
  let e = [[]];
  return r(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function i(o, a, l) {
    let c = { term: l, to: a };
    return e[o].push(c), c;
  }
  function r(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, c) => l.concat(s(c, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return c;
        r(c, a = t());
      }
    else if (o.type == "star") {
      let l = t();
      return i(a, l), r(s(o.expr, l), l), [i(l)];
    } else if (o.type == "plus") {
      let l = t();
      return r(s(o.expr, a), l), r(s(o.expr, l), l), [i(l)];
    } else {
      if (o.type == "opt")
        return [i(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          r(s(o.expr, l), u), l = u;
        }
        if (o.max == -1)
          r(s(o.expr, l), l);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            i(l, u), r(s(o.expr, l), u), l = u;
          }
        return [i(l)];
      } else {
        if (o.type == "name")
          return [i(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function um(n, e) {
  return e - n;
}
function ff(n, e) {
  let t = [];
  return i(e), t.sort(um);
  function i(r) {
    let s = n[r];
    if (s.length == 1 && !s[0].term)
      return i(s[0].to);
    t.push(r);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && t.indexOf(l) == -1 && i(l);
    }
  }
}
function Lv(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(ff(n, 0));
  function t(i) {
    let r = [];
    i.forEach((o) => {
      n[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < r.length; u++)
          r[u][0] == a && (c = r[u][1]);
        ff(n, l).forEach((u) => {
          c || r.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[i.join(",")] = new Ui(i.indexOf(n.length - 1) > -1);
    for (let o = 0; o < r.length; o++) {
      let a = r[o][1].sort(um);
      s.next.push({ type: r[o][0], next: e[a.join(",")] || t(a) });
    }
    return s;
  }
}
function Rv(n, e) {
  for (let t = 0, i = [n]; t < i.length; t++) {
    let r = i[t], s = !r.validEnd, o = [];
    for (let a = 0; a < r.next.length; a++) {
      let { type: l, next: c } = r.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), i.indexOf(c) == -1 && i.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function dm(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let i = n[t];
    if (!i.hasDefault)
      return null;
    e[t] = i.default;
  }
  return e;
}
function fm(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i in n) {
    let r = e && e[i];
    if (r === void 0) {
      let s = n[i];
      if (s.hasDefault)
        r = s.default;
      else
        throw new RangeError("No value supplied for attribute " + i);
    }
    t[i] = r;
  }
  return t;
}
function hm(n, e, t, i) {
  for (let r in e)
    if (!(r in n))
      throw new RangeError(`Unsupported attribute ${r} for ${t} of type ${r}`);
  for (let r in n) {
    let s = n[r];
    s.validate && s.validate(e[r]);
  }
}
function pm(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let i in e)
      t[i] = new Pv(n, i, e[i]);
  return t;
}
let hf = class mm {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.name = e, this.schema = t, this.spec = i, this.markSet = null, this.groups = i.group ? i.group.split(" ") : [], this.attrs = pm(e, i.attrs), this.defaultAttrs = dm(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(i.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Ui.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : fm(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, i) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Bn(this, this.computeAttrs(e), $.from(t), Ve.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, i) {
    return t = $.from(t), this.checkContent(t), new Bn(this, this.computeAttrs(e), t, Ve.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, i) {
    if (e = this.computeAttrs(e), t = $.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let r = this.contentMatch.matchFragment(t), s = r && r.fillBefore($.empty, !0);
    return s ? new Bn(this, e, t.append(s), Ve.setFrom(i)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let i = 0; i < e.childCount; i++)
      if (!this.allowsMarks(e.child(i).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    hm(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let i = 0; i < e.length; i++)
      this.allowsMarkType(e[i].type) ? t && t.push(e[i]) : t || (t = e.slice(0, i));
    return t ? t.length ? t : Ve.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let i = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => i[s] = new mm(s, t, o));
    let r = t.spec.topNode || "doc";
    if (!i[r])
      throw new RangeError("Schema is missing its top node type ('" + r + "')");
    if (!i.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in i.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return i;
  }
};
function Iv(n, e, t) {
  let i = t.split("|");
  return (r) => {
    let s = r === null ? "null" : typeof r;
    if (i.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${i} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class Pv {
  constructor(e, t, i) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(i, "default"), this.default = i.default, this.validate = typeof i.validate == "string" ? Iv(e, t, i.validate) : i.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class tl {
  /**
  @internal
  */
  constructor(e, t, i, r) {
    this.name = e, this.rank = t, this.schema = i, this.spec = r, this.attrs = pm(e, r.attrs), this.excluded = null;
    let s = dm(this.attrs);
    this.instance = s ? new Ve(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Ve(this, fm(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let i = /* @__PURE__ */ Object.create(null), r = 0;
    return e.forEach((s, o) => i[s] = new tl(s, r++, t, o)), i;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    hm(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class gm {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let r in e)
      t[r] = e[r];
    t.nodes = yt.from(e.nodes), t.marks = yt.from(e.marks || {}), this.nodes = hf.compile(this.spec.nodes, this), this.marks = tl.compile(this.spec.marks, this);
    let i = /* @__PURE__ */ Object.create(null);
    for (let r in this.nodes) {
      if (r in this.marks)
        throw new RangeError(r + " can not be both a node and a mark");
      let s = this.nodes[r], o = s.spec.content || "", a = s.spec.marks;
      if (s.contentMatch = i[o] || (i[o] = Ui.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = a == "_" ? null : a ? pf(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let r in this.marks) {
      let s = this.marks[r], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : pf(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, i, r) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof hf) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, i, r);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let i = this.nodes.text;
    return new ua(i, i.defaultAttrs, e, Ve.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Bn.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Ve.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function pf(n, e) {
  let t = [];
  for (let i = 0; i < e.length; i++) {
    let r = e[i], s = n.marks[r], o = s;
    if (s)
      t.push(s);
    else
      for (let a in n.marks) {
        let l = n.marks[a];
        (r == "_" || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && t.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
  }
  return t;
}
function Dv(n) {
  return n.tag != null;
}
function $v(n) {
  return n.style != null;
}
let br = class zc {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let i = this.matchedStyles = [];
    t.forEach((r) => {
      if (Dv(r))
        this.tags.push(r);
      else if ($v(r)) {
        let s = /[^=]*/.exec(r.style)[0];
        i.indexOf(s) < 0 && i.push(s), this.styles.push(r);
      }
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let s = e.nodes[r.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let i = new gf(this, t, !1);
    return i.addAll(e, Ve.none, t.from, t.to), i.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let i = new gf(this, t, !0);
    return i.addAll(e, Ve.none, t.from, t.to), Y.maxOpen(i.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, i) {
    for (let r = i ? this.tags.indexOf(i) + 1 : 0; r < this.tags.length; r++) {
      let s = this.tags[r];
      if (Hv(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, i, r) {
    for (let s = r ? this.styles.indexOf(r) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !i.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let l = o.getAttrs(t);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function i(r) {
      let s = r.priority == null ? 50 : r.priority, o = 0;
      for (; o < t.length; o++) {
        let a = t[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      t.splice(o, 0, r);
    }
    for (let r in e.marks) {
      let s = e.marks[r].spec.parseDOM;
      s && s.forEach((o) => {
        i(o = _f(o)), o.mark || o.ignore || o.clearMark || (o.mark = r);
      });
    }
    for (let r in e.nodes) {
      let s = e.nodes[r].spec.parseDOM;
      s && s.forEach((o) => {
        i(o = _f(o)), o.node || o.ignore || o.mark || (o.node = r);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new zc(e, zc.schemaRules(e)));
  }
};
const _m = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, Bv = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, bm = { ol: !0, ul: !0 }, $s = 1, Hc = 2, Wo = 4;
function mf(n, e, t) {
  return e != null ? (e ? $s : 0) | (e === "full" ? Hc : 0) : n && n.whitespace == "pre" ? $s | Hc : t & -5;
}
class wo {
  constructor(e, t, i, r, s, o) {
    this.type = e, this.attrs = t, this.marks = i, this.solid = r, this.options = o, this.content = [], this.activeMarks = Ve.none, this.match = s || (o & Wo ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore($.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let i = this.type.contentMatch, r;
        return (r = i.findWrapping(e.type)) ? (this.match = i, r) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & $s)) {
      let i = this.content[this.content.length - 1], r;
      if (i && i.isText && (r = /[ \t\r\n\u000c]+$/.exec(i.text))) {
        let s = i;
        i.text.length == r[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - r[0].length));
      }
    }
    let t = $.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore($.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !_m.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class gf {
  constructor(e, t, i) {
    this.parser = e, this.options = t, this.isOpen = i, this.open = 0, this.localPreserveWS = !1;
    let r = t.topNode, s, o = mf(null, t.preserveWhitespace, 0) | (i ? Wo : 0);
    r ? s = new wo(r.type, r.attrs, Ve.none, !0, t.topMatch || r.type.contentMatch, o) : i ? s = new wo(null, null, Ve.none, !0, null, o) : s = new wo(e.schema.topNodeType, null, Ve.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let i = e.nodeValue, r = this.top, s = r.options & Hc ? "full" : this.localPreserveWS || (r.options & $s) > 0;
    if (s === "full" || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(i)) {
      if (s)
        s !== "full" ? i = i.replace(/\r?\n|\r/g, " ") : i = i.replace(/\r\n?/g, `
`);
      else if (i = i.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(i) && this.open == this.nodes.length - 1) {
        let o = r.content[r.content.length - 1], a = e.previousSibling;
        (!o || a && a.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (i = i.slice(1));
      }
      i && this.insertNode(this.parser.schema.text(i), t), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, i) {
    let r = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), a;
    bm.hasOwnProperty(o) && this.parser.normalizeLists && zv(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, i));
    e: if (l ? l.ignore : Bv.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (_m.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let d = l && l.skip ? t : this.readStyles(e, t);
      d && this.addAll(e, d), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = r;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let i = e.style;
    if (i && i.length)
      for (let r = 0; r < this.parser.matchedStyles.length; r++) {
        let s = this.parser.matchedStyles[r], o = i.getPropertyValue(s);
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, o, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? t = t.filter((c) => !l.clearMark(c)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, i, r) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), i) || this.leafFallback(e, i);
      else {
        let l = this.enter(o, t.attrs || null, i, t.preserveWhitespace);
        l && (s = !0, i = l);
      }
    else {
      let l = this.parser.schema.marks[t.mark];
      i = i.concat(l.create(t.attrs));
    }
    let a = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, i, r);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, i));
    else {
      let l = e;
      typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, i), this.findAround(e, l, !1);
    }
    s && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, i, r) {
    let s = i || 0;
    for (let o = i ? e.childNodes[i] : e.firstChild, a = r == null ? null : e.childNodes[r]; o != a; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t) {
    let i, r;
    for (let s = this.open; s >= 0; s--) {
      let o = this.nodes[s], a = o.findWrapping(e);
      if (a && (!i || i.length > a.length) && (i = a, r = o, !a.length) || o.solid)
        break;
    }
    if (!i)
      return null;
    this.sync(r);
    for (let s = 0; s < i.length; s++)
      t = this.enterInner(i[s], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let r = this.textblockFromContext();
      r && (t = this.enterInner(r, null, t));
    }
    let i = this.findPlace(e, t);
    if (i) {
      this.closeExtra();
      let r = this.top;
      r.match && (r.match = r.match.matchType(e.type));
      let s = Ve.none;
      for (let o of i.concat(e.marks))
        (r.type ? r.type.allowsMarkType(o.type) : bf(o.type, e.type)) && (s = o.addToSet(s));
      return r.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, i, r) {
    let s = this.findPlace(e.create(t), i);
    return s && (s = this.enterInner(e, t, i, !0, r)), s;
  }
  // Open a node of the given type
  enterInner(e, t, i, r = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let a = mf(e, s, o.options);
    o.options & Wo && o.content.length == 0 && (a |= Wo);
    let l = Ve.none;
    return i = i.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : bf(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new wo(e, t, l, r, null, a)), this.open++, i;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= $s);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let i = this.nodes[t].content;
      for (let r = i.length - 1; r >= 0; r--)
        e += i[r].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].node == e && this.find[i].offset == t && (this.find[i].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, i) {
    if (e != t && this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && t.compareDocumentPosition(this.find[r].node) & (i ? 2 : 4) && (this.find[r].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), i = this.options.context, r = !this.isOpen && (!i || i.parent.type == this.nodes[0].type), s = -(i ? i.depth + 1 : 0) + (r ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = t[a];
        if (c == "") {
          if (a == t.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && r ? this.nodes[l].type : i && l >= s ? i.node(l - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let i = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (i && i.isTextblock && i.defaultAttrs)
          return i;
      }
    for (let t in this.parser.schema.nodes) {
      let i = this.parser.schema.nodes[t];
      if (i.isTextblock && i.defaultAttrs)
        return i;
    }
  }
}
function zv(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let i = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    i && bm.hasOwnProperty(i) && t ? (t.appendChild(e), e = t) : i == "li" ? t = e : i && (t = null);
  }
}
function Hv(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function _f(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function bf(n, e) {
  let t = e.schema.nodes;
  for (let i in t) {
    let r = t[i];
    if (!r.allowsMarkType(n))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(r.contentMatch))
      return !0;
  }
}
class Yi {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, i) {
    i || (i = Il(t).createDocumentFragment());
    let r = i, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          r = s.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, r]), r.appendChild(u.dom), r = u.contentDOM || u.dom);
        }
      }
      r.appendChild(this.serializeNodeInner(o, t));
    }), i;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: i, contentDOM: r } = Uo(Il(t), this.nodes[e.type.name](e), null, e.attrs);
    if (r) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, r);
    }
    return i;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let i = this.serializeNodeInner(e, t);
    for (let r = e.marks.length - 1; r >= 0; r--) {
      let s = this.serializeMark(e.marks[r], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(i), i = s.dom);
    }
    return i;
  }
  /**
  @internal
  */
  serializeMark(e, t, i = {}) {
    let r = this.marks[e.type.name];
    return r && Uo(Il(i), r(e, t), null, e.attrs);
  }
  static renderSpec(e, t, i = null, r) {
    return Uo(e, t, i, r);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Yi(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = vf(e.nodes);
    return t.text || (t.text = (i) => i.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return vf(e.marks);
  }
}
function vf(n) {
  let e = {};
  for (let t in n) {
    let i = n[t].spec.toDOM;
    i && (e[t] = i);
  }
  return e;
}
function Il(n) {
  return n.document || window.document;
}
const yf = /* @__PURE__ */ new WeakMap();
function Fv(n) {
  let e = yf.get(n);
  return e === void 0 && yf.set(n, e = Vv(n)), e;
}
function Vv(n) {
  let e = null;
  function t(i) {
    if (i && typeof i == "object")
      if (Array.isArray(i))
        if (typeof i[0] == "string")
          e || (e = []), e.push(i);
        else
          for (let r = 0; r < i.length; r++)
            t(i[r]);
      else
        for (let r in i)
          t(i[r]);
  }
  return t(n), e;
}
function Uo(n, e, t, i) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let r = e[0], s;
  if (typeof r != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (i && (s = Fv(i)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = r.indexOf(" ");
  o > 0 && (t = r.slice(0, o), r = r.slice(o + 1));
  let a, l = t ? n.createElementNS(t, r) : n.createElement(r), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: h, contentDOM: p } = Uo(n, f, t, i);
      if (l.appendChild(h), p) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = p;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const vm = 65535, ym = Math.pow(2, 16);
function jv(n, e) {
  return n + e * ym;
}
function xf(n) {
  return n & vm;
}
function Wv(n) {
  return (n - (n & vm)) / ym;
}
const xm = 1, wm = 2, Ko = 4, km = 8;
class Fc {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.pos = e, this.delInfo = t, this.recover = i;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & km) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (xm | Ko)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (wm | Ko)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Ko) > 0;
  }
}
class Yt {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Yt.empty)
      return Yt.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, i = xf(e);
    if (!this.inverted)
      for (let r = 0; r < i; r++)
        t += this.ranges[r * 3 + 2] - this.ranges[r * 3 + 1];
    return this.ranges[i * 3] + t + Wv(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, i) {
    let r = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : t : t, h = l + r + (f < 0 ? 0 : u);
        if (i)
          return h;
        let p = e == (t < 0 ? l : d) ? null : jv(a / 3, e - l), b = e == l ? wm : e == d ? xm : Ko;
        return (t < 0 ? e != l : e != d) && (b |= km), new Fc(h, b, p);
      }
      r += u - c;
    }
    return i ? e + r : new Fc(e + r, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let i = 0, r = xf(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == r * 3)
        return !0;
      i += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let r = 0, s = 0; r < this.ranges.length; r += 3) {
      let o = this.ranges[r], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[r + t], u = this.ranges[r + i];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Yt(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Yt.empty : new Yt(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Yt.empty = new Yt([]);
class vr {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], t, i = 0, r = e.length) {
    this.maps = e, this.mirror = t, this.from = i, this.to = r;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new vr(this.maps, this.mirror, e, t);
  }
  /**
  @internal
  */
  copy() {
    return new vr(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, i = this.maps.length; t < e.maps.length; t++) {
      let r = e.getMirror(t);
      this.appendMap(e.maps[t], r != null && r < t ? i + r : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, i = this.maps.length + e.maps.length; t >= 0; t--) {
      let r = e.getMirror(t);
      this.appendMap(e.maps[t].invert(), r != null && r > t ? i - r - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new vr();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let i = this.from; i < this.to; i++)
      e = this.maps[i].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, i) {
    let r = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, t);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      r |= a.delInfo, e = a.pos;
    }
    return i ? e : new Fc(e, r, null);
  }
}
const Pl = /* @__PURE__ */ Object.create(null);
class Lt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Yt.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let i = Pl[t.stepType];
    if (!i)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return i.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Pl)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Pl[e] = t, t.prototype.jsonID = e, t;
  }
}
class ot {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new ot(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new ot(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, i, r) {
    try {
      return ot.ok(e.replace(t, i, r));
    } catch (s) {
      if (s instanceof aa)
        return ot.fail(s.message);
      throw s;
    }
  }
}
function Lu(n, e, t) {
  let i = [];
  for (let r = 0; r < n.childCount; r++) {
    let s = n.child(r);
    s.content.size && (s = s.copy(Lu(s.content, e, s))), s.isInline && (s = e(s, t, r)), i.push(s);
  }
  return $.fromArray(i);
}
class gi extends Lt {
  /**
  Create a mark step.
  */
  constructor(e, t, i) {
    super(), this.from = e, this.to = t, this.mark = i;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), i = e.resolve(this.from), r = i.node(i.sharedDepth(this.to)), s = new Y(Lu(t.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), r), t.openStart, t.openEnd);
    return ot.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new wn(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deleted && i.deleted || t.pos >= i.pos ? null : new gi(t.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof gi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new gi(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new gi(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Lt.jsonID("addMark", gi);
class wn extends Lt {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, i) {
    super(), this.from = e, this.to = t, this.mark = i;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), i = new Y(Lu(t.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e), t.openStart, t.openEnd);
    return ot.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new gi(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deleted && i.deleted || t.pos >= i.pos ? null : new wn(t.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof wn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new wn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new wn(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Lt.jsonID("removeMark", wn);
class _i extends Lt {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return ot.fail("No node at mark step's position");
    let i = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return ot.fromReplace(e, this.pos, this.pos + 1, new Y($.from(i), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let i = this.mark.addToSet(t.marks);
      if (i.length == t.marks.length) {
        for (let r = 0; r < t.marks.length; r++)
          if (!t.marks[r].isInSet(i))
            return new _i(this.pos, t.marks[r]);
        return new _i(this.pos, this.mark);
      }
    }
    return new Pr(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new _i(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _i(t.pos, e.markFromJSON(t.mark));
  }
}
Lt.jsonID("addNodeMark", _i);
class Pr extends Lt {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return ot.fail("No node at mark step's position");
    let i = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return ot.fromReplace(e, this.pos, this.pos + 1, new Y($.from(i), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new _i(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Pr(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Pr(t.pos, e.markFromJSON(t.mark));
  }
}
Lt.jsonID("removeNodeMark", Pr);
class mt extends Lt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, i, r = !1) {
    super(), this.from = e, this.to = t, this.slice = i, this.structure = r;
  }
  apply(e) {
    return this.structure && Vc(e, this.from, this.to) ? ot.fail("Structure replace would overwrite content") : ot.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Yt([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new mt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deletedAcross && i.deletedAcross ? null : new mt(t.pos, Math.max(t.pos, i.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof mt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? Y.empty : new Y(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new mt(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? Y.empty : new Y(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new mt(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new mt(t.from, t.to, Y.fromJSON(e, t.slice), !!t.structure);
  }
}
Lt.jsonID("replace", mt);
class _t extends Lt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, i, r, s, o, a = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = i, this.gapTo = r, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Vc(e, this.from, this.gapFrom) || Vc(e, this.gapTo, this.to)))
      return ot.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return ot.fail("Gap is not a flat range");
    let i = this.slice.insertAt(this.insert, t.content);
    return i ? ot.fromReplace(e, this.from, this.to, i) : ot.fail("Content does not fit in gap");
  }
  getMap() {
    return new Yt([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new _t(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? i.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && i.deletedAcross || r < t.pos || s > i.pos ? null : new _t(t.pos, i.pos, r, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _t(t.from, t.to, t.gapFrom, t.gapTo, Y.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Lt.jsonID("replaceAround", _t);
function Vc(n, e, t) {
  let i = n.resolve(e), r = t - e, s = i.depth;
  for (; r > 0 && s > 0 && i.indexAfter(s) == i.node(s).childCount; )
    s--, r--;
  if (r > 0) {
    let o = i.node(s).maybeChild(i.indexAfter(s));
    for (; r > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, r--;
    }
  }
  return !1;
}
function Uv(n, e, t, i) {
  let r = [], s = [], o, a;
  n.doc.nodesBetween(e, t, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!i.isInSet(d) && u.type.allowsMarkType(i.type)) {
      let f = Math.max(c, e), h = Math.min(c + l.nodeSize, t), p = i.addToSet(d);
      for (let b = 0; b < d.length; b++)
        d[b].isInSet(p) || (o && o.to == f && o.mark.eq(d[b]) ? o.to = h : r.push(o = new wn(f, h, d[b])));
      a && a.to == f ? a.to = h : s.push(a = new gi(f, h, i));
    }
  }), r.forEach((l) => n.step(l)), s.forEach((l) => n.step(l));
}
function Kv(n, e, t, i) {
  let r = [], s = 0;
  n.doc.nodesBetween(e, t, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (i instanceof tl) {
      let c = o.marks, u;
      for (; u = i.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else i ? i.isInSet(o.marks) && (l = [i]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, t);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let h = 0; h < r.length; h++) {
          let p = r[h];
          p.step == s - 1 && d.eq(r[h].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : r.push({ style: d, from: Math.max(a, e), to: c, step: s });
      }
    }
  }), r.forEach((o) => n.step(new wn(o.from, o.to, o.style)));
}
function Ru(n, e, t, i = t.contentMatch, r = !0) {
  let s = n.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l), u = a + c.nodeSize, d = i.matchType(c.type);
    if (!d)
      o.push(new mt(a, u, Y.empty));
    else {
      i = d;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new wn(a, u, c.marks[f]));
      if (r && c.isText && t.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, p;
        for (; f = h.exec(c.text); )
          p || (p = new Y($.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new mt(a + f.index, a + f.index + f[0].length, p));
      }
    }
    a = u;
  }
  if (!i.validEnd) {
    let l = i.fillBefore($.empty, !0);
    n.replace(a, a, new Y(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    n.step(o[l]);
}
function qv(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function Ur(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let i = n.depth; ; --i) {
    let r = n.$from.node(i), s = n.$from.index(i), o = n.$to.indexAfter(i);
    if (i < n.depth && r.canReplace(s, o, t))
      return i;
    if (i == 0 || r.type.spec.isolating || !qv(r, s, o))
      break;
  }
  return null;
}
function Gv(n, e, t) {
  let { $from: i, $to: r, depth: s } = e, o = i.before(s + 1), a = r.after(s + 1), l = o, c = a, u = $.empty, d = 0;
  for (let p = s, b = !1; p > t; p--)
    b || i.index(p) > 0 ? (b = !0, u = $.from(i.node(p).copy(u)), d++) : l--;
  let f = $.empty, h = 0;
  for (let p = s, b = !1; p > t; p--)
    b || r.after(p + 1) < r.end(p) ? (b = !0, f = $.from(r.node(p).copy(f)), h++) : c++;
  n.step(new _t(l, c, o, a, new Y(u.append(f), d, h), u.size - d, !0));
}
function Iu(n, e, t = null, i = n) {
  let r = Jv(n, e), s = r && Xv(i, e);
  return s ? r.map(wf).concat({ type: e, attrs: t }).concat(s.map(wf)) : null;
}
function wf(n) {
  return { type: n, attrs: null };
}
function Jv(n, e) {
  let { parent: t, startIndex: i, endIndex: r } = n, s = t.contentMatchAt(i).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(i, r, o) ? s : null;
}
function Xv(n, e) {
  let { parent: t, startIndex: i, endIndex: r } = n, s = t.child(i), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = i; l && c < r; c++)
    l = l.matchType(t.child(c).type);
  return !l || !l.validEnd ? null : o;
}
function Yv(n, e, t) {
  let i = $.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (i.size) {
      let a = t[o].type.contentMatch.matchFragment(i);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    i = $.from(t[o].type.create(t[o].attrs, i));
  }
  let r = e.start, s = e.end;
  n.step(new _t(r, s, r, s, new Y(i, 0, 0), t.length, !0));
}
function Zv(n, e, t, i, r) {
  if (!i.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, a) => {
    let l = typeof r == "function" ? r(o) : r;
    if (o.isTextblock && !o.hasMarkup(i, l) && Qv(n.doc, n.mapping.slice(s).map(a), i)) {
      let c = null;
      if (i.schema.linebreakReplacement) {
        let h = i.whitespace == "pre", p = !!i.contentMatch.matchType(i.schema.linebreakReplacement);
        h && !p ? c = !1 : !h && p && (c = !0);
      }
      c === !1 && Cm(n, o, a, s), Ru(n, n.mapping.slice(s).map(a, 1), i, void 0, c === null);
      let u = n.mapping.slice(s), d = u.map(a, 1), f = u.map(a + o.nodeSize, 1);
      return n.step(new _t(d, f, d + 1, f - 1, new Y($.from(i.create(l, null, o.marks)), 0, 0), 1, !0)), c === !0 && Sm(n, o, a, s), !1;
    }
  });
}
function Sm(n, e, t, i) {
  e.forEach((r, s) => {
    if (r.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(r.text); ) {
        let l = n.mapping.slice(i).map(t + 1 + s + o.index);
        n.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function Cm(n, e, t, i) {
  e.forEach((r, s) => {
    if (r.type == r.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(i).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function Qv(n, e, t) {
  let i = n.resolve(e), r = i.index();
  return i.parent.canReplaceWith(r, r + 1, t);
}
function ey(n, e, t, i, r) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(i, null, r || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new _t(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new Y($.from(o), 0, 0), 1, !0));
}
function Zn(n, e, t = 1, i) {
  let r = n.resolve(e), s = r.depth - t, o = i && i[i.length - 1] || r.parent;
  if (s < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !o.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount)))
    return !1;
  for (let c = r.depth - 1, u = t - 2; c > s; c--, u--) {
    let d = r.node(c), f = r.index(c);
    if (d.type.spec.isolating)
      return !1;
    let h = d.content.cutByIndex(f, d.childCount), p = i && i[u + 1];
    p && (h = h.replaceChild(0, p.type.create(p.attrs)));
    let b = i && i[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !b.type.validContent(h))
      return !1;
  }
  let a = r.indexAfter(s), l = i && i[0];
  return r.node(s).canReplaceWith(a, a, l ? l.type : r.node(s + 1).type);
}
function ty(n, e, t = 1, i) {
  let r = n.doc.resolve(e), s = $.empty, o = $.empty;
  for (let a = r.depth, l = r.depth - t, c = t - 1; a > l; a--, c--) {
    s = $.from(r.node(a).copy(s));
    let u = i && i[c];
    o = $.from(u ? u.type.create(u.attrs, o) : r.node(a).copy(o));
  }
  n.step(new mt(e, e, new Y(s.append(o), t, t), !0));
}
function Si(n, e) {
  let t = n.resolve(e), i = t.index();
  return Tm(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(i, i + 1);
}
function ny(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: i } = n.type.schema;
  for (let r = 0; r < e.childCount; r++) {
    let s = e.child(r), o = s.type == i ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function Tm(n, e) {
  return !!(n && e && !n.isLeaf && ny(n, e));
}
function nl(n, e, t = -1) {
  let i = n.resolve(e);
  for (let r = i.depth; ; r--) {
    let s, o, a = i.index(r);
    if (r == i.depth ? (s = i.nodeBefore, o = i.nodeAfter) : t > 0 ? (s = i.node(r + 1), a++, o = i.node(r).maybeChild(a)) : (s = i.node(r).maybeChild(a - 1), o = i.node(r + 1)), s && !s.isTextblock && Tm(s, o) && i.node(r).canReplace(a, a + 1))
      return e;
    if (r == 0)
      break;
    e = t < 0 ? i.before(r) : i.after(r);
  }
}
function iy(n, e, t) {
  let i = null, { linebreakReplacement: r } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (r && o.inlineContent) {
    let u = o.whitespace == "pre", d = !!o.contentMatch.matchType(r);
    u && !d ? i = !1 : !u && d && (i = !0);
  }
  let a = n.steps.length;
  if (i === !1) {
    let u = n.doc.resolve(e + t);
    Cm(n, u.node(), u.before(), a);
  }
  o.inlineContent && Ru(n, e + t - 1, o, s.node().contentMatchAt(s.index()), i == null);
  let l = n.mapping.slice(a), c = l.map(e - t);
  if (n.step(new mt(c, l.map(e + t, -1), Y.empty, !0)), i === !0) {
    let u = n.doc.resolve(c);
    Sm(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function ry(n, e, t) {
  let i = n.resolve(e);
  if (i.parent.canReplaceWith(i.index(), i.index(), t))
    return e;
  if (i.parentOffset == 0)
    for (let r = i.depth - 1; r >= 0; r--) {
      let s = i.index(r);
      if (i.node(r).canReplaceWith(s, s, t))
        return i.before(r + 1);
      if (s > 0)
        return null;
    }
  if (i.parentOffset == i.parent.content.size)
    for (let r = i.depth - 1; r >= 0; r--) {
      let s = i.indexAfter(r);
      if (i.node(r).canReplaceWith(s, s, t))
        return i.after(r + 1);
      if (s < i.node(r).childCount)
        return null;
    }
  return null;
}
function Em(n, e, t) {
  let i = n.resolve(e);
  if (!t.content.size)
    return e;
  let r = t.content;
  for (let s = 0; s < t.openStart; s++)
    r = r.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = i.depth; o >= 0; o--) {
      let a = o == i.depth ? 0 : i.pos <= (i.start(o + 1) + i.end(o + 1)) / 2 ? -1 : 1, l = i.index(o) + (a > 0 ? 1 : 0), c = i.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(l, l, r);
      else {
        let d = c.contentMatchAt(l).findWrapping(r.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? i.pos : a < 0 ? i.before(o + 1) : i.after(o + 1);
    }
  return null;
}
function il(n, e, t = e, i = Y.empty) {
  if (e == t && !i.size)
    return null;
  let r = n.resolve(e), s = n.resolve(t);
  return Am(r, s, i) ? new mt(e, t, i) : new sy(r, s, i).fit();
}
function Am(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class sy {
  constructor(e, t, i) {
    this.$from = e, this.$to = t, this.unplaced = i, this.frontier = [], this.placed = $.empty;
    for (let r = 0; r <= e.depth; r++) {
      let s = e.node(r);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(r))
      });
    }
    for (let r = e.depth; r > 0; r--)
      this.placed = $.from(e.node(r).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, i = this.$from, r = this.close(e < 0 ? this.$to : i.doc.resolve(e));
    if (!r)
      return null;
    let s = this.placed, o = i.depth, a = r.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new Y(s, o, a);
    return e > -1 ? new _t(i.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || i.pos != this.$to.pos ? new mt(i.pos, r.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, i = 0, r = this.unplaced.openEnd; i < e; i++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (r = 0), s.type.spec.isolating && r <= i) {
        e = i;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let i = t == 1 ? e : this.unplaced.openStart; i >= 0; i--) {
        let r, s = null;
        i ? (s = Dl(this.unplaced.content, i - 1).firstChild, r = s.content) : r = this.unplaced.content;
        let o = r.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (t == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore($.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: i, frontierDepth: a, parent: s, inject: d };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: i, frontierDepth: a, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: i } = this.unplaced, r = Dl(e, t);
    return !r.childCount || r.firstChild.isLeaf ? !1 : (this.unplaced = new Y(e, t + 1, Math.max(i, r.size + t >= e.size - i ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: i } = this.unplaced, r = Dl(e, t);
    if (r.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + r.size;
      this.unplaced = new Y(ps(e, t - 1, 1), t - 1, s ? t - 1 : i);
    } else
      this.unplaced = new Y(ps(e, t, 1), t, i);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: i, inject: r, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let b = 0; b < s.length; b++)
        this.openFrontierNode(s[b]);
    let o = this.unplaced, a = i ? i.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[t];
    if (r) {
      for (let b = 0; b < r.childCount; b++)
        u.push(r.child(b));
      d = d.matchFragment(r);
    }
    let h = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let b = a.child(c), m = d.matchType(b.type);
      if (!m)
        break;
      c++, (c > 1 || l == 0 || b.content.size) && (d = m, u.push(Mm(b.mark(f.allowedMarks(b.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1)));
    }
    let p = c == a.childCount;
    p || (h = -1), this.placed = ms(this.placed, t, $.from(u)), this.frontier[t].match = d, p && h < 0 && i && i.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let b = 0, m = a; b < h; b++) {
      let g = m.lastChild;
      this.frontier.push({ type: g.type, match: g.contentMatchAt(g.childCount) }), m = g.content;
    }
    this.unplaced = p ? e == 0 ? Y.empty : new Y(ps(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new Y(ps(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !$l(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: i } = this.$to, r = this.$to.after(i);
    for (; i > 1 && r == this.$to.end(--i); )
      ++r;
    return r;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: i, type: r } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = $l(e, t, r, i, s);
      if (o) {
        for (let a = t - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = $l(e, a, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = ms(this.placed, t.depth, t.fit)), e = t.move;
    for (let i = t.depth + 1; i <= e.depth; i++) {
      let r = e.node(i), s = r.type.contentMatch.fillBefore(r.content, !0, e.index(i));
      this.openFrontierNode(r.type, r.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, i) {
    let r = this.frontier[this.depth];
    r.match = r.match.matchType(e), this.placed = ms(this.placed, this.depth, $.from(e.create(t, i))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore($.empty, !0);
    t.childCount && (this.placed = ms(this.placed, this.frontier.length, t));
  }
}
function ps(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(ps(n.firstChild.content, e - 1, t)));
}
function ms(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(ms(n.lastChild.content, e - 1, t)));
}
function Dl(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function Mm(n, e, t) {
  if (e <= 0)
    return n;
  let i = n.content;
  return e > 1 && (i = i.replaceChild(0, Mm(i.firstChild, e - 1, i.childCount == 1 ? t - 1 : 0))), e > 0 && (i = n.type.contentMatch.fillBefore(i).append(i), t <= 0 && (i = i.append(n.type.contentMatch.matchFragment(i).fillBefore($.empty, !0)))), n.copy(i);
}
function $l(n, e, t, i, r) {
  let s = n.node(e), o = r ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let a = i.fillBefore(s.content, !0, o);
  return a && !oy(t, s.content, o) ? a : null;
}
function oy(n, e, t) {
  for (let i = t; i < e.childCount; i++)
    if (!n.allowsMarks(e.child(i).marks))
      return !0;
  return !1;
}
function ay(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function ly(n, e, t, i) {
  if (!i.size)
    return n.deleteRange(e, t);
  let r = n.doc.resolve(e), s = n.doc.resolve(t);
  if (Am(r, s, i))
    return n.step(new mt(e, t, i));
  let o = Nm(r, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let a = -(r.depth + 1);
  o.unshift(a);
  for (let f = r.depth, h = r.pos - 1; f > 0; f--, h--) {
    let p = r.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? a = f : r.before(f) == h && o.splice(1, 0, -f);
  }
  let l = o.indexOf(a), c = [], u = i.openStart;
  for (let f = i.content, h = 0; ; h++) {
    let p = f.firstChild;
    if (c.push(p), h == i.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h = c[f], p = ay(h.type);
    if (p && !h.sameMarkup(r.node(Math.abs(a) - 1)))
      u = f;
    else if (p || !h.type.isTextblock)
      break;
  }
  for (let f = i.openStart; f >= 0; f--) {
    let h = (f + u + 1) % (i.openStart + 1), p = c[h];
    if (p)
      for (let b = 0; b < o.length; b++) {
        let m = o[(b + l) % o.length], g = !0;
        m < 0 && (g = !1, m = -m);
        let v = r.node(m - 1), x = r.index(m - 1);
        if (v.canReplaceWith(x, x, p.type, p.marks))
          return n.replace(r.before(m), g ? s.after(m) : t, new Y(Om(i.content, 0, i.openStart, h), h, i.openEnd));
      }
  }
  let d = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, i), !(n.steps.length > d)); f--) {
    let h = o[f];
    h < 0 || (e = r.before(h), t = s.after(h));
  }
}
function Om(n, e, t, i, r) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(Om(s.content, e + 1, t, i, s)));
  }
  if (e > i) {
    let s = r.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore($.empty, !0));
  }
  return n;
}
function cy(n, e, t, i) {
  if (!i.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let r = ry(n.doc, e, i.type);
    r != null && (e = t = r);
  }
  n.replaceRange(e, t, new Y($.from(i), 0, 0));
}
function uy(n, e, t) {
  let i = n.doc.resolve(e), r = n.doc.resolve(t), s = Nm(i, r);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || i.node(a).type.contentMatch.validEnd)
      return n.delete(i.start(a), r.end(a));
    if (a > 0 && (l || i.node(a - 1).canReplace(i.index(a - 1), r.indexAfter(a - 1))))
      return n.delete(i.before(a), r.after(a));
  }
  for (let o = 1; o <= i.depth && o <= r.depth; o++)
    if (e - i.start(o) == i.depth - o && t > i.end(o) && r.end(o) - t != r.depth - o && i.start(o - 1) == r.start(o - 1) && i.node(o - 1).canReplace(i.index(o - 1), r.index(o - 1)))
      return n.delete(i.before(o), t);
  n.delete(e, t);
}
function Nm(n, e) {
  let t = [], i = Math.min(n.depth, e.depth);
  for (let r = i; r >= 0; r--) {
    let s = n.start(r);
    if (s < n.pos - (n.depth - r) || e.end(r) > e.pos + (e.depth - r) || n.node(r).type.spec.isolating || e.node(r).type.spec.isolating)
      break;
    (s == e.start(r) || r == n.depth && r == e.depth && n.parent.inlineContent && e.parent.inlineContent && r && e.start(r - 1) == s - 1) && t.push(r);
  }
  return t;
}
class yr extends Lt {
  /**
  Construct an attribute step.
  */
  constructor(e, t, i) {
    super(), this.pos = e, this.attr = t, this.value = i;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return ot.fail("No node at attribute step's position");
    let i = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      i[s] = t.attrs[s];
    i[this.attr] = this.value;
    let r = t.type.create(i, null, t.marks);
    return ot.fromReplace(e, this.pos, this.pos + 1, new Y($.from(r), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Yt.empty;
  }
  invert(e) {
    return new yr(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new yr(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new yr(t.pos, t.attr, t.value);
  }
}
Lt.jsonID("attr", yr);
class Bs extends Lt {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e.attrs)
      t[r] = e.attrs[r];
    t[this.attr] = this.value;
    let i = e.type.create(t, e.content, e.marks);
    return ot.ok(i);
  }
  getMap() {
    return Yt.empty;
  }
  invert(e) {
    return new Bs(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Bs(t.attr, t.value);
  }
}
Lt.jsonID("docAttr", Bs);
let Dr = class extends Error {
};
Dr = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Dr.prototype = Object.create(Error.prototype);
Dr.prototype.constructor = Dr;
Dr.prototype.name = "TransformError";
class Pu {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new vr();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Dr(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, i = Y.empty) {
    let r = il(this.doc, e, t, i);
    return r && this.step(r), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, i) {
    return this.replace(e, t, new Y($.from(i), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, Y.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, i) {
    return ly(this, e, t, i), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, i) {
    return cy(this, e, t, i), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return uy(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return Gv(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return iy(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return Yv(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, i, r = null) {
    return Zv(this, e, t, i, r), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, i = null, r) {
    return ey(this, e, t, i, r), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, i) {
    return this.step(new yr(e, t, i)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new Bs(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new _i(e, t)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    if (!(t instanceof Ve)) {
      let i = this.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at position " + e);
      if (t = t.isInSet(i.marks), !t)
        return this;
    }
    return this.step(new Pr(e, t)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, t = 1, i) {
    return ty(this, e, t, i), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, i) {
    return Uv(this, e, t, i), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, i) {
    return Kv(this, e, t, i), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, i) {
    return Ru(this, e, t, i), this;
  }
}
const Bl = /* @__PURE__ */ Object.create(null);
class pe {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, i) {
    this.$anchor = e, this.$head = t, this.ranges = i || [new Lm(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = Y.empty) {
    let i = t.content.lastChild, r = null;
    for (let a = 0; a < t.openEnd; a++)
      r = i, i = i.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a], u = e.mapping.slice(s);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? Y.empty : t), a == 0 && Cf(e, s, (i ? i.isInline : r && r.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let i = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      let { $from: o, $to: a } = r[s], l = e.mapping.slice(i), c = l.map(o.pos), u = l.map(a.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), Cf(e, i, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, i = !1) {
    let r = e.parent.inlineContent ? new ue(e) : cr(e.node(0), e.parent, e.pos, e.index(), t, i);
    if (r)
      return r;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? cr(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, i) : cr(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, i);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Ut(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return cr(e, e, 0, 0, 1) || new Ut(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return cr(e, e, e.content.size, e.childCount, -1) || new Ut(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let i = Bl[t.type];
    if (!i)
      throw new RangeError(`No selection type ${t.type} defined`);
    return i.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Bl)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Bl[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ue.between(this.$anchor, this.$head).getBookmark();
  }
}
pe.prototype.visible = !0;
class Lm {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let kf = !1;
function Sf(n) {
  !kf && !n.parent.inlineContent && (kf = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class ue extends pe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    Sf(e), Sf(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let i = e.resolve(t.map(this.head));
    if (!i.parent.inlineContent)
      return pe.near(i);
    let r = e.resolve(t.map(this.anchor));
    return new ue(r.parent.inlineContent ? r : i, i);
  }
  replace(e, t = Y.empty) {
    if (super.replace(e, t), t == Y.empty) {
      let i = this.$from.marksAcross(this.$to);
      i && e.ensureMarks(i);
    }
  }
  eq(e) {
    return e instanceof ue && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new rl(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ue(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, i = t) {
    let r = e.resolve(t);
    return new this(r, i == t ? r : e.resolve(i));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, i) {
    let r = e.pos - t.pos;
    if ((!i || r) && (i = r >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = pe.findFrom(t, i, !0) || pe.findFrom(t, -i, !0);
      if (s)
        t = s.$head;
      else
        return pe.near(t, i);
    }
    return e.parent.inlineContent || (r == 0 ? e = t : (e = (pe.findFrom(e, -i, !0) || pe.findFrom(e, i, !0)).$anchor, e.pos < t.pos != r < 0 && (e = t))), new ue(e, t);
  }
}
pe.jsonID("text", ue);
class rl {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new rl(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ue.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ae extends pe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, i = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, i), this.node = t;
  }
  map(e, t) {
    let { deleted: i, pos: r } = t.mapResult(this.anchor), s = e.resolve(r);
    return i ? pe.near(s) : new ae(s);
  }
  content() {
    return new Y($.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ae && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Du(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ae(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new ae(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ae.prototype.visible = !1;
pe.jsonID("node", ae);
class Du {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: i } = e.mapResult(this.anchor);
    return t ? new rl(i, i) : new Du(i);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), i = t.nodeAfter;
    return i && ae.isSelectable(i) ? new ae(t) : pe.near(t);
  }
}
class Ut extends pe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = Y.empty) {
    if (t == Y.empty) {
      e.delete(0, e.doc.content.size);
      let i = pe.atStart(e.doc);
      i.eq(e.selection) || e.setSelection(i);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Ut(e);
  }
  map(e) {
    return new Ut(e);
  }
  eq(e) {
    return e instanceof Ut;
  }
  getBookmark() {
    return dy;
  }
}
pe.jsonID("all", Ut);
const dy = {
  map() {
    return this;
  },
  resolve(n) {
    return new Ut(n);
  }
};
function cr(n, e, t, i, r, s = !1) {
  if (e.inlineContent)
    return ue.create(n, t);
  for (let o = i - (r > 0 ? 0 : 1); r > 0 ? o < e.childCount : o >= 0; o += r) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && ae.isSelectable(a))
        return ae.create(n, t - (r < 0 ? a.nodeSize : 0));
    } else {
      let l = cr(n, a, t + r, r < 0 ? a.childCount : 0, r, s);
      if (l)
        return l;
    }
    t += a.nodeSize * r;
  }
  return null;
}
function Cf(n, e, t) {
  let i = n.steps.length - 1;
  if (i < e)
    return;
  let r = n.steps[i];
  if (!(r instanceof mt || r instanceof _t))
    return;
  let s = n.mapping.maps[i], o;
  s.forEach((a, l, c, u) => {
    o == null && (o = u);
  }), n.setSelection(pe.near(n.doc.resolve(o), t));
}
const Tf = 1, Ef = 2, Af = 4;
class fy extends Pu {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Tf) & -3, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Tf) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Ef, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Ve.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Ef) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & -3, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let i = this.selection;
    return t && (e = e.mark(this.storedMarks || (i.empty ? i.$from.marks() : i.$from.marksAcross(i.$to) || Ve.none))), i.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, i) {
    let r = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
    {
      if (i == null && (i = t), i = i ?? t, !e)
        return this.deleteRange(t, i);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = i == t ? o.marks() : o.marksAcross(this.doc.resolve(i));
      }
      return this.replaceRangeWith(t, i, r.text(e, s)), this.selection.empty || this.setSelection(pe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Af, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Af) > 0;
  }
}
function Mf(n, e) {
  return !e || !n ? n : n.bind(e);
}
class gs {
  constructor(e, t, i) {
    this.name = e, this.init = Mf(t.init, i), this.apply = Mf(t.apply, i);
  }
}
const hy = [
  new gs("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new gs("selection", {
    init(n, e) {
      return n.selection || pe.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new gs("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, i) {
      return i.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new gs("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class zl {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = hy.slice(), t && t.forEach((i) => {
      if (this.pluginsByKey[i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + i.key + ")");
      this.plugins.push(i), this.pluginsByKey[i.key] = i, i.spec.state && this.fields.push(new gs(i.key, i.spec.state, i));
    });
  }
}
class hr {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != t) {
        let r = this.config.plugins[i];
        if (r.spec.filterTransaction && !r.spec.filterTransaction.call(r, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], i = this.applyInner(e), r = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = r ? r[o].n : 0, c = r ? r[o].state : this, u = l < t.length && a.spec.appendTransaction.call(a, l ? t.slice(l) : t, c, i);
          if (u && i.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !r) {
              r = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                r.push(d < o ? { state: i, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), i = i.applyInner(u), s = !0;
          }
          r && (r[o] = { state: i, n: t.length });
        }
      }
      if (!s)
        return { state: i, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new hr(this.config), i = this.config.fields;
    for (let r = 0; r < i.length; r++) {
      let s = i[r];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new fy(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new zl(e.doc ? e.doc.type.schema : e.schema, e.plugins), i = new hr(t);
    for (let r = 0; r < t.fields.length; r++)
      i[t.fields[r].name] = t.fields[r].init(e, i);
    return i;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new zl(this.schema, e.plugins), i = t.fields, r = new hr(t);
    for (let s = 0; s < i.length; s++) {
      let o = i[s].name;
      r[o] = this.hasOwnProperty(o) ? this[o] : i[s].init(e, r);
    }
    return r;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((i) => i.toJSON())), e && typeof e == "object")
      for (let i in e) {
        if (i == "doc" || i == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let r = e[i], s = r.spec.state;
        s && s.toJSON && (t[i] = s.toJSON.call(r, this[r.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, i) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let r = new zl(e.schema, e.plugins), s = new hr(r);
    return r.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Bn.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = pe.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (i)
          for (let a in i) {
            let l = i[a], c = l.spec.state;
            if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, a)) {
              s[o.name] = c.fromJSON.call(l, e, t[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function Rm(n, e, t) {
  for (let i in n) {
    let r = n[i];
    r instanceof Function ? r = r.bind(e) : i == "handleDOMEvents" && (r = Rm(r, e, {})), t[i] = r;
  }
  return t;
}
class Ge {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Rm(e.props, this, this.props), this.key = e.key ? e.key.key : Im("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Hl = /* @__PURE__ */ Object.create(null);
function Im(n) {
  return n in Hl ? n + "$" + ++Hl[n] : (Hl[n] = 0, n + "$");
}
class lt {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = Im(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const xt = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, $r = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let jc = null;
const Gn = function(n, e, t) {
  let i = jc || (jc = document.createRange());
  return i.setEnd(n, t ?? n.nodeValue.length), i.setStart(n, e || 0), i;
}, py = function() {
  jc = null;
}, Ki = function(n, e, t, i) {
  return t && (Of(n, e, t, i, -1) || Of(n, e, t, i, 1));
}, my = /^(img|br|input|textarea|hr)$/i;
function Of(n, e, t, i, r) {
  for (; ; ) {
    if (n == t && e == i)
      return !0;
    if (e == (r < 0 ? 0 : dn(n))) {
      let s = n.parentNode;
      if (!s || s.nodeType != 1 || eo(n) || my.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = xt(n) + (r < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (r < 0 ? -1 : 0)], n.contentEditable == "false")
        return !1;
      e = r < 0 ? dn(n) : 0;
    } else
      return !1;
  }
}
function dn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function gy(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = dn(n);
    } else if (n.parentNode && !eo(n))
      e = xt(n), n = n.parentNode;
    else
      return null;
  }
}
function _y(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !eo(n))
      e = xt(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function by(n, e, t) {
  for (let i = e == 0, r = e == dn(n); i || r; ) {
    if (n == t)
      return !0;
    let s = xt(n);
    if (n = n.parentNode, !n)
      return !1;
    i = i && s == 0, r = r && s == dn(n);
  }
}
function eo(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const sl = function(n) {
  return n.focusNode && Ki(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Oi(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function vy(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function yy(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let i = n.caretPositionFromPoint(e, t);
      if (i)
        return { node: i.offsetNode, offset: Math.min(dn(i.offsetNode), i.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let i = n.caretRangeFromPoint(e, t);
    if (i)
      return { node: i.startContainer, offset: Math.min(dn(i.startContainer), i.startOffset) };
  }
}
const zn = typeof navigator < "u" ? navigator : null, Nf = typeof document < "u" ? document : null, Ci = zn && zn.userAgent || "", Wc = /Edge\/(\d+)/.exec(Ci), Pm = /MSIE \d/.exec(Ci), Uc = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ci), Kt = !!(Pm || Uc || Wc), vi = Pm ? document.documentMode : Uc ? +Uc[1] : Wc ? +Wc[1] : 0, Sn = !Kt && /gecko\/(\d+)/i.test(Ci);
Sn && +(/Firefox\/(\d+)/.exec(Ci) || [0, 0])[1];
const Kc = !Kt && /Chrome\/(\d+)/.exec(Ci), At = !!Kc, Dm = Kc ? +Kc[1] : 0, Pt = !Kt && !!zn && /Apple Computer/.test(zn.vendor), Br = Pt && (/Mobile\/\w+/.test(Ci) || !!zn && zn.maxTouchPoints > 2), un = Br || (zn ? /Mac/.test(zn.platform) : !1), xy = zn ? /Win/.test(zn.platform) : !1, Xn = /Android \d/.test(Ci), to = !!Nf && "webkitFontSmoothing" in Nf.documentElement.style, wy = to ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function ky(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function jn(n, e) {
  return typeof n == "number" ? n : n[e];
}
function Sy(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, i = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * i
  };
}
function Lf(n, e, t) {
  let i = n.someProp("scrollThreshold") || 0, r = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = $r(o);
      continue;
    }
    let a = o, l = a == s.body, c = l ? ky(s) : Sy(a), u = 0, d = 0;
    if (e.top < c.top + jn(i, "top") ? d = -(c.top - e.top + jn(r, "top")) : e.bottom > c.bottom - jn(i, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + jn(r, "top") - c.top : e.bottom - c.bottom + jn(r, "bottom")), e.left < c.left + jn(i, "left") ? u = -(c.left - e.left + jn(r, "left")) : e.right > c.right - jn(i, "right") && (u = e.right - c.right + jn(r, "right")), u || d)
      if (l)
        s.defaultView.scrollBy(u, d);
      else {
        let h = a.scrollLeft, p = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let b = a.scrollLeft - h, m = a.scrollTop - p;
        e = { left: e.left - b, top: e.top - m, right: e.right - b, bottom: e.bottom - m };
      }
    let f = l ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : $r(o);
  }
}
function Cy(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), i, r;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = n.root.elementFromPoint(s, o);
    if (!a || a == n.dom || !n.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= t - 20) {
      i = a, r = l.top;
      break;
    }
  }
  return { refDOM: i, refTop: r, stack: $m(n.dom) };
}
function $m(n) {
  let e = [], t = n.ownerDocument;
  for (let i = n; i && (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), n != t); i = $r(i))
    ;
  return e;
}
function Ty({ refDOM: n, refTop: e, stack: t }) {
  let i = n ? n.getBoundingClientRect().top : 0;
  Bm(t, i == 0 ? 0 : i - e);
}
function Bm(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: i, top: r, left: s } = n[t];
    i.scrollTop != r + e && (i.scrollTop = r + e), i.scrollLeft != s && (i.scrollLeft = s);
  }
}
let or = null;
function Ey(n) {
  if (n.setActive)
    return n.setActive();
  if (or)
    return n.focus(or);
  let e = $m(n);
  n.focus(or == null ? {
    get preventScroll() {
      return or = { preventScroll: !0 }, !0;
    }
  } : void 0), or || (or = !1, Bm(e, 0));
}
function zm(n, e) {
  let t, i = 2e8, r, s = 0, o = e.top, a = e.top, l, c;
  for (let u = n.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Gn(u).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let p = f[h];
      if (p.top <= o && p.bottom >= a) {
        o = Math.max(p.bottom, o), a = Math.min(p.top, a);
        let b = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (b < i) {
          t = u, i = b, r = b && t.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && b && (s = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = d + 1);
    }
  }
  return !t && l && (t = l, r = c, i = 0), t && t.nodeType == 3 ? Ay(t, r) : !t || i && t.nodeType == 1 ? { node: n, offset: s } : zm(t, r);
}
function Ay(n, e) {
  let t = n.nodeValue.length, i = document.createRange();
  for (let r = 0; r < t; r++) {
    i.setEnd(n, r + 1), i.setStart(n, r);
    let s = oi(i, 1);
    if (s.top != s.bottom && $u(e, s))
      return { node: n, offset: r + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function $u(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function My(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function Oy(n, e, t) {
  let { node: i, offset: r } = zm(e, t), s = -1;
  if (i.nodeType == 1 && !i.firstChild) {
    let o = i.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(i, r, s);
}
function Ny(n, e, t, i) {
  let r = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let a = n.docView.nearestDesc(s, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!o && l.left > i.left || l.top > i.top ? r = a.posBefore : (!o && l.right < i.left || l.bottom < i.top) && (r = a.posAfter), o = !0), !a.contentDOM && r < 0 && !a.node.isText))
      return (a.node.isBlock ? i.top < (l.top + l.bottom) / 2 : i.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    s = a.dom.parentNode;
  }
  return r > -1 ? r : n.docView.posFromDOM(e, t, -1);
}
function Hm(n, e, t) {
  let i = n.childNodes.length;
  if (i && t.top < t.bottom)
    for (let r = Math.max(0, Math.min(i - 1, Math.floor(i * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = r; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if ($u(e, c))
            return Hm(o, e, c);
        }
      }
      if ((s = (s + 1) % i) == r)
        break;
    }
  return n;
}
function Ly(n, e) {
  let t = n.dom.ownerDocument, i, r = 0, s = yy(t, e.left, e.top);
  s && ({ node: i, offset: r } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), a;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!$u(e, c) || (o = Hm(n.dom, e, c), !o))
      return null;
  }
  if (Pt)
    for (let c = o; i && c; c = $r(c))
      c.draggable && (i = void 0);
  if (o = My(o, e), i) {
    if (Sn && i.nodeType == 1 && (r = Math.min(r, i.childNodes.length), r < i.childNodes.length)) {
      let u = i.childNodes[r], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && r++;
    }
    let c;
    to && r && i.nodeType == 1 && (c = i.childNodes[r - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && r--, i == n.dom && r == i.childNodes.length - 1 && i.lastChild.nodeType == 1 && e.top > i.lastChild.getBoundingClientRect().bottom ? a = n.state.doc.content.size : (r == 0 || i.nodeType != 1 || i.childNodes[r - 1].nodeName != "BR") && (a = Ny(n, i, r, e));
  }
  a == null && (a = Oy(n, o, e));
  let l = n.docView.nearestDesc(o, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function Rf(n) {
  return n.top < n.bottom || n.left < n.right;
}
function oi(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let i = t[e < 0 ? 0 : t.length - 1];
    if (Rf(i))
      return i;
  }
  return Array.prototype.find.call(t, Rf) || n.getBoundingClientRect();
}
const Ry = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Fm(n, e, t) {
  let { node: i, offset: r, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = to || Sn;
  if (i.nodeType == 3)
    if (o && (Ry.test(i.nodeValue) || (t < 0 ? !r : r == i.nodeValue.length))) {
      let l = oi(Gn(i, r, r), t);
      if (Sn && r && /\s/.test(i.nodeValue[r - 1]) && r < i.nodeValue.length) {
        let c = oi(Gn(i, r - 1, r - 1), -1);
        if (c.top == l.top) {
          let u = oi(Gn(i, r, r + 1), -1);
          if (u.top != l.top)
            return ns(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = r, c = r, u = t < 0 ? 1 : -1;
      return t < 0 && !r ? (c++, u = -1) : t >= 0 && r == i.nodeValue.length ? (l--, u = 1) : t < 0 ? l-- : c++, ns(oi(Gn(i, l, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && r && (t < 0 || r == dn(i))) {
      let l = i.childNodes[r - 1];
      if (l.nodeType == 1)
        return Fl(l.getBoundingClientRect(), !1);
    }
    if (s == null && r < dn(i)) {
      let l = i.childNodes[r];
      if (l.nodeType == 1)
        return Fl(l.getBoundingClientRect(), !0);
    }
    return Fl(i.getBoundingClientRect(), t >= 0);
  }
  if (s == null && r && (t < 0 || r == dn(i))) {
    let l = i.childNodes[r - 1], c = l.nodeType == 3 ? Gn(l, dn(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return ns(oi(c, 1), !1);
  }
  if (s == null && r < dn(i)) {
    let l = i.childNodes[r];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? Gn(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return ns(oi(c, -1), !0);
  }
  return ns(oi(i.nodeType == 3 ? Gn(i) : i, -t), t >= 0);
}
function ns(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function Fl(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function Vm(n, e, t) {
  let i = n.state, r = n.root.activeElement;
  i != e && n.updateState(e), r != n.dom && n.focus();
  try {
    return t();
  } finally {
    i != e && n.updateState(i), r != n.dom && r && r.focus();
  }
}
function Iy(n, e, t) {
  let i = e.selection, r = t == "up" ? i.$from : i.$to;
  return Vm(n, e, () => {
    let { node: s } = n.docView.domFromPos(r.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let a = n.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = Fm(n, r.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Gn(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const Py = /[\u0590-\u08ac]/;
function Dy(n, e, t) {
  let { $head: i } = e.selection;
  if (!i.parent.isTextblock)
    return !1;
  let r = i.parentOffset, s = !r, o = r == i.parent.content.size, a = n.domSelection();
  return a ? !Py.test(i.parent.textContent) || !a.modify ? t == "left" || t == "backward" ? s : o : Vm(n, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = n.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", t, "character");
    let h = i.depth ? n.docView.domAfterPos(i.before()) : n.dom, { focusNode: p, focusOffset: b } = n.domSelectionRange(), m = p && !h.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && c == b;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), m;
  }) : i.pos == i.start() || i.pos == i.end();
}
let If = null, Pf = null, Df = !1;
function $y(n, e, t) {
  return If == e && Pf == t ? Df : (If = e, Pf = t, Df = t == "up" || t == "down" ? Iy(n, e, t) : Dy(n, e, t));
}
const fn = 0, $f = 1, Ni = 2, Hn = 3;
class no {
  constructor(e, t, i, r) {
    this.parent = e, this.children = t, this.dom = i, this.contentDOM = r, this.dirty = fn, i.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, i) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, i = this.posAtStart; ; t++) {
      let r = this.children[t];
      if (r == e)
        return i;
      i += r.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, i) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (i < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let r;
    if (e == this.dom && this.contentDOM)
      r = t > xt(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      r = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            r = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (r == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            r = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return r ?? i > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let i = !0, r = e; r; r = r.parentNode) {
      let s = this.getDesc(r), o;
      if (s && (!t || s.node))
        if (i && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          i = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let i = t; i; i = i.parent)
      if (i == this)
        return t;
  }
  posFromDOM(e, t, i) {
    for (let r = e; r; r = r.parentNode) {
      let s = this.getDesc(r);
      if (s)
        return s.localPosFromDOM(e, t, i);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, i = 0; t < this.children.length; t++) {
      let r = this.children[t], s = i + r.size;
      if (i == e && s != i) {
        for (; !r.border && r.children.length; )
          for (let o = 0; o < r.children.length; o++) {
            let a = r.children[o];
            if (a.size) {
              r = a;
              break;
            }
          }
        return r;
      }
      if (e < s)
        return r.descAt(e - i - r.border);
      i = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let i = 0, r = 0;
    for (let s = 0; i < this.children.length; i++) {
      let o = this.children[i], a = s + o.size;
      if (a > e || o instanceof Wm) {
        r = e - s;
        break;
      }
      s = a;
    }
    if (r)
      return this.children[i].domFromPos(r - this.children[i].border, t);
    for (let s; i && !(s = this.children[i - 1]).size && s instanceof jm && s.side >= 0; i--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = i ? this.children[i - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); i--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? xt(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = i < this.children.length ? this.children[i] : null, !(!s || s.dom.parentNode == this.contentDOM); i++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? xt(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, i = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let r = -1, s = -1;
    for (let o = i, a = 0; ; a++) {
      let l = this.children[a], c = o + l.size;
      if (r == -1 && e <= c) {
        let u = o + l.border;
        if (e >= u && t <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, t, u);
        e = o;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            r = xt(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        r == -1 && (r = 0);
      }
      if (r > -1 && (c > t || a == this.children.length - 1)) {
        t = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            s = xt(d.dom);
            break;
          }
          t += d.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: r, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: i } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || i == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[i];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, i, r = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let h = 0, p = 0; h < this.children.length; h++) {
      let b = this.children[h], m = p + b.size;
      if (s > p && o < m)
        return b.setSelection(e - p - b.border, t - p - b.border, i, r);
      p = m;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = t == e ? a : this.domFromPos(t, t ? -1 : 1), c = i.root.getSelection(), u = i.domSelectionRange(), d = !1;
    if ((Sn || Pt) && e == t) {
      let { node: h, offset: p } = a;
      if (h.nodeType == 3) {
        if (d = !!(p && h.nodeValue[p - 1] == `
`), d && p == h.nodeValue.length)
          for (let b = h, m; b; b = b.parentNode) {
            if (m = b.nextSibling) {
              m.nodeName == "BR" && (a = l = { node: m.parentNode, offset: xt(m) + 1 });
              break;
            }
            let g = b.pmViewDesc;
            if (g && g.node && g.node.isBlock)
              break;
          }
      } else {
        let b = h.childNodes[p - 1];
        d = b && (b.nodeName == "BR" || b.contentEditable == "false");
      }
    }
    if (Sn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let h = u.focusNode.childNodes[u.focusOffset];
      h && h.contentEditable == "false" && (r = !0);
    }
    if (!(r || d && Pt) && Ki(a.node, a.offset, u.anchorNode, u.anchorOffset) && Ki(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !d) {
      c.collapse(a.node, a.offset);
      try {
        e != t && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let p = a;
        a = l, l = p;
      }
      let h = document.createRange();
      h.setEnd(l.node, l.offset), h.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let i = 0, r = 0; r < this.children.length; r++) {
      let s = this.children[r], o = i + s.size;
      if (i == o ? e <= o && t >= i : e < o && t > i) {
        let a = i + s.border, l = o - s.border;
        if (e >= a && t <= l) {
          this.dirty = e == i || t == o ? Ni : $f, e == a && t == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Hn : s.markDirty(e - a, t - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Ni : Hn;
      }
      i = o;
    }
    this.dirty = Ni;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let i = e == 1 ? Ni : $f;
      t.dirty < i && (t.dirty = i);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class jm extends no {
  constructor(e, t, i, r) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(i, () => {
      if (!s)
        return r;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == fn && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class By extends no {
  constructor(e, t, i, r) {
    super(e, [], t, null), this.textDOM = i, this.text = r;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class qi extends no {
  constructor(e, t, i, r, s) {
    super(e, [], i, r), this.mark = t, this.spec = s;
  }
  static create(e, t, i, r) {
    let s = r.nodeViews[t.type.name], o = s && s(t, r, i);
    return (!o || !o.dom) && (o = Yi.renderSpec(document, t.type.spec.toDOM(t, i), null, t.attrs)), new qi(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & Hn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Hn && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != fn) {
      let i = this.parent;
      for (; !i.node; )
        i = i.parent;
      i.dirty < this.dirty && (i.dirty = this.dirty), this.dirty = fn;
    }
  }
  slice(e, t, i) {
    let r = qi.create(this.parent, this.mark, !0, i), s = this.children, o = this.size;
    t < o && (s = Gc(s, t, o, i)), e > 0 && (s = Gc(s, 0, e, i));
    for (let a = 0; a < s.length; a++)
      s[a].parent = r;
    return r.children = s, r;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class yi extends no {
  constructor(e, t, i, r, s, o, a, l, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = i, this.innerDeco = r, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, i, r, s, o) {
    let a = s.nodeViews[t.type.name], l, c = a && a(t, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, i, r), u = c && c.dom, d = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = Yi.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !d && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = qm(u, i, t), c ? l = new zy(e, t, i, r, u, d || null, f, c, s, o + 1) : t.isText ? new ol(e, t, i, r, u, f, s) : new yi(e, t, i, r, u, d || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let i = this.children[t];
        if (this.dom.contains(i.dom.parentNode)) {
          e.contentElement = i.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => $.empty);
    }
    return e;
  }
  matchesNode(e, t, i) {
    return this.dirty == fn && e.eq(this.node) && da(t, this.outerDeco) && i.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let i = this.node.inlineContent, r = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new Fy(this, o && o.node, e);
    Wy(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, i, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Ve.none : this.node.child(u).marks, i, e), l.placeWidget(c, e, r);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, i, e);
      let h;
      l.findNodeMatch(c, u, d, f) || a && e.state.selection.from > r && e.state.selection.to < r + c.nodeSize && (h = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c, u, d, h, e) || l.updateNextNode(c, u, d, e, f, r) || l.addNode(c, u, d, e, r), r += c.nodeSize;
    }), l.syncToMarks([], i, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Ni) && (o && this.protectLocalComposition(e, o), Um(this.contentDOM, this.children, e), Br && Uy(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: i, to: r } = e.state.selection;
    if (!(e.state.selection instanceof ue) || i < t || r > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, a = Ky(this.node.content, o, i - t, r - t);
      return a < 0 ? null : { node: s, pos: a, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: i, text: r }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new By(this, s, t, r);
    e.input.compositionNodes.push(o), this.children = Gc(this.children, i, i + r.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, i, r) {
    return this.dirty == Hn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, i, r), !0);
  }
  updateInner(e, t, i, r) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = i, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = fn;
  }
  updateOuterDeco(e) {
    if (da(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, i = this.dom;
    this.dom = Km(this.dom, this.nodeDOM, qc(this.outerDeco, this.node, t), qc(e, this.node, t)), this.dom != i && (i.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Bf(n, e, t, i, r) {
  qm(i, e, n);
  let s = new yi(void 0, n, e, t, i, i, i, r, 0);
  return s.contentDOM && s.updateChildren(r, 0), s;
}
class ol extends yi {
  constructor(e, t, i, r, s, o, a) {
    super(e, t, i, r, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, i, r) {
    return this.dirty == Hn || this.dirty != fn && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != fn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = fn, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, i) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, i);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, i) {
    let r = this.node.cut(e, t), s = document.createTextNode(r.text);
    return new ol(this.parent, r, this.outerDeco, this.innerDeco, s, s, i);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Hn);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Wm extends no {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == fn && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class zy extends yi {
  constructor(e, t, i, r, s, o, a, l, c, u) {
    super(e, t, i, r, s, o, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, i, r) {
    if (this.dirty == Hn)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, i);
      return s && this.updateInner(e, t, i, r), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, i, r);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, i, r) {
    this.spec.setSelection ? this.spec.setSelection(e, t, i.root) : super.setSelection(e, t, i, r);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function Um(n, e, t) {
  let i = n.firstChild, r = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == n) {
      for (; a != i; )
        i = zf(i), r = !0;
      i = i.nextSibling;
    } else
      r = !0, n.insertBefore(a, i);
    if (o instanceof qi) {
      let l = i ? i.previousSibling : n.lastChild;
      Um(o.contentDOM, o.children, t), i = l ? l.nextSibling : n.firstChild;
    }
  }
  for (; i; )
    i = zf(i), r = !0;
  r && t.trackWrites == n && (t.trackWrites = null);
}
const ks = function(n) {
  n && (this.nodeName = n);
};
ks.prototype = /* @__PURE__ */ Object.create(null);
const Li = [new ks()];
function qc(n, e, t) {
  if (n.length == 0)
    return Li;
  let i = t ? Li[0] : new ks(), r = [i];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && r.push(i = new ks(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (t && r.length == 1 && r.push(i = new ks(e.isInline ? "span" : "div")), a == "class" ? i.class = (i.class ? i.class + " " : "") + l : a == "style" ? i.style = (i.style ? i.style + ";" : "") + l : a != "nodeName" && (i[a] = l));
      }
    }
  }
  return r;
}
function Km(n, e, t, i) {
  if (t == Li && i == Li)
    return e;
  let r = e;
  for (let s = 0; s < i.length; s++) {
    let o = i[s], a = t[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && r != n && (l = r.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(r), a = Li[0]), r = l;
    }
    Hy(r, a || Li[0], o);
  }
  return r;
}
function Hy(n, e, t) {
  for (let i in e)
    i != "class" && i != "style" && i != "nodeName" && !(i in t) && n.removeAttribute(i);
  for (let i in t)
    i != "class" && i != "style" && i != "nodeName" && t[i] != e[i] && n.setAttribute(i, t[i]);
  if (e.class != t.class) {
    let i = e.class ? e.class.split(" ").filter(Boolean) : [], r = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.remove(i[s]);
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.add(r[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let i = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, r;
      for (; r = i.exec(e.style); )
        n.style.removeProperty(r[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function qm(n, e, t) {
  return Km(n, n, Li, qc(e, t, n.nodeType != 1));
}
function da(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function zf(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class Fy {
  constructor(e, t, i) {
    this.lock = t, this.view = i, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = Vy(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let i = e; i < t; i++)
        this.top.children[i].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, i) {
    let r = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; r < o && (r == s - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== !1; )
      r++;
    for (; r < s; )
      this.destroyRest(), this.top.dirty = fn, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = qi.create(this.top, e[s], t, i);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, i, r) {
    let s = -1, o;
    if (r >= this.preMatch.index && (o = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, i))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, t, i) && !this.preMatch.matched.has(c)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, i, r, s) {
    let o = this.top.children[r];
    return o.dirty == Hn && o.dom == o.contentDOM && (o.dirty = Ni), o.update(e, t, i, s) ? (this.destroyBetween(this.index, r), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let i = e.pmViewDesc;
        if (i) {
          for (let r = this.index; r < this.top.children.length; r++)
            if (this.top.children[r] == i)
              return r;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, i, r, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof yi) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != s)
          return !1;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Hn && da(t, l.outerDeco));
        if (!f && l.update(e, t, i, r))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, t, i, r, o)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Ni, d.updateChildren(r, o + 1), d.dirty = fn), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, i, r, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !da(i, e.outerDeco) || !r.eq(e.innerDeco))
      return null;
    let a = yi.create(this.top, t, i, r, s, o);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, i, r, s) {
    let o = yi.create(this.top, e, t, i, r, s);
    o.contentDOM && o.updateChildren(r, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, i) {
    let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (r && r.matchesWidget(e) && (e == r.widget || !r.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new jm(this.top, e, t, i);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof qi; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof ol) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Pt || At) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let i = document.createElement(e);
      e == "IMG" && (i.className = "ProseMirror-separator", i.alt = ""), e == "BR" && (i.className = "ProseMirror-trailingBreak");
      let r = new Wm(this.top, [], i, null);
      t != this.top ? t.children.push(r) : t.children.splice(this.index++, 0, r), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function Vy(n, e) {
  let t = e, i = t.children.length, r = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; r > 0; ) {
    let a;
    for (; ; )
      if (i) {
        let c = t.children[i - 1];
        if (c instanceof qi)
          t = c, i = c.children.length;
        else {
          a = c, i--;
          break;
        }
      } else {
        if (t == e)
          break e;
        i = t.parent.children.indexOf(t), t = t.parent;
      }
    let l = a.node;
    if (l) {
      if (l != n.child(r - 1))
        break;
      --r, s.set(a, r), o.push(a);
    }
  }
  return { index: r, matched: s, matches: o.reverse() };
}
function jy(n, e) {
  return n.type.side - e.type.side;
}
function Wy(n, e, t, i) {
  let r = e.locals(n), s = 0;
  if (r.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      i(u, r, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; o < r.length && r[o].to == s; ) {
      let m = r[o++];
      m.widget && (u ? (d || (d = [u])).push(m) : u = m);
    }
    if (u)
      if (d) {
        d.sort(jy);
        for (let m = 0; m < d.length; m++)
          t(d[m], c, !!l);
      } else
        t(u, c, !!l);
    let f, h;
    if (l)
      h = -1, f = l, l = null;
    else if (c < n.childCount)
      h = c, f = n.child(c++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= s && a.splice(m--, 1);
    for (; o < r.length && r[o].from <= s && r[o].to > s; )
      a.push(r[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let m = p;
      o < r.length && r[o].from < m && (m = r[o].from);
      for (let g = 0; g < a.length; g++)
        a[g].to < m && (m = a[g].to);
      m < p && (l = f.cut(m - s), f = f.cut(0, m - s), p = m, h = -1);
    } else
      for (; o < r.length && r[o].to < p; )
        o++;
    let b = f.isInline && !f.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    i(f, b, e.forChild(s, f), h), s = p;
  }
}
function Uy(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function Ky(n, e, t, i) {
  for (let r = 0, s = 0; r < n.childCount && s <= i; ) {
    let o = n.child(r++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; r < n.childCount; ) {
      let c = n.child(r++);
      if (s += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (s >= t) {
      if (s >= i && l.slice(i - e.length - a, i - a) == e)
        return i - e.length;
      let c = a < i ? l.lastIndexOf(e, i - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= t)
        return a + c;
      if (t == i && l.length >= i + e.length - a && l.slice(i - a, i - a + e.length) == e)
        return i;
    }
  }
  return -1;
}
function Gc(n, e, t, i, r) {
  let s = [];
  for (let o = 0, a = 0; o < n.length; o++) {
    let l = n[o], c = a, u = a += l.size;
    c >= t || u <= e ? s.push(l) : (c < e && s.push(l.slice(0, e - c, i)), r && (s.push(r), r = void 0), u > t && s.push(l.slice(t - c, l.size, i)));
  }
  return s;
}
function Bu(n, e = null) {
  let t = n.domSelectionRange(), i = n.state.doc;
  if (!t.focusNode)
    return null;
  let r = n.docView.nearestDesc(t.focusNode), s = r && r.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let a = i.resolve(o), l, c;
  if (sl(t)) {
    for (l = o; r && !r.node; )
      r = r.parent;
    let d = r.node;
    if (r && d.isAtom && ae.isSelectable(d) && r.parent && !(d.isInline && by(t.focusNode, t.focusOffset, r.dom))) {
      let f = r.posBefore;
      c = new ae(o == f ? a : i.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let d = o, f = o;
      for (let h = 0; h < t.rangeCount; h++) {
        let p = t.getRangeAt(h);
        d = Math.min(d, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, o] = f == n.state.selection.anchor ? [f, d] : [d, f], a = i.resolve(o);
    } else
      l = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = i.resolve(l);
  if (!c) {
    let d = e == "pointer" || n.state.selection.head < a.pos && !s ? 1 : -1;
    c = zu(n, u, a, d);
  }
  return c;
}
function Gm(n) {
  return n.editable ? n.hasFocus() : Xm(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function Qn(n, e = !1) {
  let t = n.state.selection;
  if (Jm(n, t), !!Gm(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && At) {
      let i = n.domSelectionRange(), r = n.domObserver.currentSelection;
      if (i.anchorNode && r.anchorNode && Ki(i.anchorNode, i.anchorOffset, r.anchorNode, r.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      Gy(n);
    else {
      let { anchor: i, head: r } = t, s, o;
      Hf && !(t instanceof ue) && (t.$from.parent.inlineContent || (s = Ff(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = Ff(n, t.to))), n.docView.setSelection(i, r, n, e), Hf && (s && Vf(s), o && Vf(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && qy(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const Hf = Pt || At && Dm < 63;
function Ff(n, e) {
  let { node: t, offset: i } = n.docView.domFromPos(e, 0), r = i < t.childNodes.length ? t.childNodes[i] : null, s = i ? t.childNodes[i - 1] : null;
  if (Pt && r && r.contentEditable == "false")
    return Vl(r);
  if ((!r || r.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (r)
      return Vl(r);
    if (s)
      return Vl(s);
  }
}
function Vl(n) {
  return n.contentEditable = "true", Pt && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function Vf(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function qy(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), i = t.anchorNode, r = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != i || t.anchorOffset != r) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!Gm(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function Gy(n) {
  let e = n.domSelection(), t = document.createRange();
  if (!e)
    return;
  let i = n.cursorWrapper.dom, r = i.nodeName == "IMG";
  r ? t.setStart(i.parentNode, xt(i) + 1) : t.setStart(i, 0), t.collapse(!0), e.removeAllRanges(), e.addRange(t), !r && !n.state.selection.visible && Kt && vi <= 11 && (i.disabled = !0, i.disabled = !1);
}
function Jm(n, e) {
  if (e instanceof ae) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (jf(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    jf(n);
}
function jf(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function zu(n, e, t, i) {
  return n.someProp("createSelectionBetween", (r) => r(n, e, t)) || ue.between(e, t, i);
}
function Wf(n) {
  return n.editable && !n.hasFocus() ? !1 : Xm(n);
}
function Xm(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Jy(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Ki(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Jc(n, e) {
  let { $anchor: t, $head: i } = n.selection, r = e > 0 ? t.max(i) : t.min(i), s = r.parent.inlineContent ? r.depth ? n.doc.resolve(e > 0 ? r.after() : r.before()) : null : r;
  return s && pe.findFrom(s, e);
}
function ai(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Uf(n, e, t) {
  let i = n.state.selection;
  if (i instanceof ue)
    if (t.indexOf("s") > -1) {
      let { $head: r } = i, s = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(r.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return ai(n, new ue(i.$anchor, o));
    } else if (i.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let r = Jc(n.state, e);
        return r && r instanceof ae ? ai(n, r) : !1;
      } else if (!(un && t.indexOf("m") > -1)) {
        let r = i.$head, s = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? r.pos - s.nodeSize : r.pos;
        return s.isAtom || (o = n.docView.descAt(a)) && !o.contentDOM ? ae.isSelectable(s) ? ai(n, new ae(e < 0 ? n.state.doc.resolve(r.pos - s.nodeSize) : r)) : to ? ai(n, new ue(n.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (i instanceof ae && i.node.isInline)
      return ai(n, new ue(e > 0 ? i.$to : i.$from));
    {
      let r = Jc(n.state, e);
      return r ? ai(n, r) : !1;
    }
  }
}
function fa(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Ss(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function ar(n, e) {
  return e < 0 ? Xy(n) : Yy(n);
}
function Xy(n) {
  let e = n.domSelectionRange(), t = e.focusNode, i = e.focusOffset;
  if (!t)
    return;
  let r, s, o = !1;
  for (Sn && t.nodeType == 1 && i < fa(t) && Ss(t.childNodes[i], -1) && (o = !0); ; )
    if (i > 0) {
      if (t.nodeType != 1)
        break;
      {
        let a = t.childNodes[i - 1];
        if (Ss(a, -1))
          r = t, s = --i;
        else if (a.nodeType == 3)
          t = a, i = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (Ym(t))
        break;
      {
        let a = t.previousSibling;
        for (; a && Ss(a, -1); )
          r = t.parentNode, s = xt(a), a = a.previousSibling;
        if (a)
          t = a, i = fa(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          i = 0;
        }
      }
    }
  o ? Xc(n, t, i) : r && Xc(n, r, s);
}
function Yy(n) {
  let e = n.domSelectionRange(), t = e.focusNode, i = e.focusOffset;
  if (!t)
    return;
  let r = fa(t), s, o;
  for (; ; )
    if (i < r) {
      if (t.nodeType != 1)
        break;
      let a = t.childNodes[i];
      if (Ss(a, 1))
        s = t, o = ++i;
      else
        break;
    } else {
      if (Ym(t))
        break;
      {
        let a = t.nextSibling;
        for (; a && Ss(a, 1); )
          s = a.parentNode, o = xt(a) + 1, a = a.nextSibling;
        if (a)
          t = a, i = 0, r = fa(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          i = r = 0;
        }
      }
    }
  s && Xc(n, s, o);
}
function Ym(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Zy(n, e) {
  for (; n && e == n.childNodes.length && !eo(n); )
    e = xt(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function Qy(n, e) {
  for (; n && !e && !eo(n); )
    e = xt(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function Xc(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = Zy(e, t)) ? (e = o, t = 0) : (s = Qy(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let i = n.domSelection();
  if (!i)
    return;
  if (sl(i)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), i.removeAllRanges(), i.addRange(s);
  } else i.extend && i.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: r } = n;
  setTimeout(() => {
    n.state == r && Qn(n);
  }, 50);
}
function Kf(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(At || xy) && t.parent.inlineContent) {
    let r = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > r.top && o < r.bottom && Math.abs(s.left - r.left) > 1)
        return s.left < r.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > r.top && o < r.bottom && Math.abs(s.left - r.left) > 1)
        return s.left > r.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function qf(n, e, t) {
  let i = n.state.selection;
  if (i instanceof ue && !i.empty || t.indexOf("s") > -1 || un && t.indexOf("m") > -1)
    return !1;
  let { $from: r, $to: s } = i;
  if (!r.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Jc(n.state, e);
    if (o && o instanceof ae)
      return ai(n, o);
  }
  if (!r.parent.inlineContent) {
    let o = e < 0 ? r : s, a = i instanceof Ut ? pe.near(o, e) : pe.findFrom(o, e);
    return a ? ai(n, a) : !1;
  }
  return !1;
}
function Gf(n, e) {
  if (!(n.state.selection instanceof ue))
    return !0;
  let { $head: t, $anchor: i, empty: r } = n.state.selection;
  if (!t.sameParent(i))
    return !0;
  if (!r)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function Jf(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function ex(n) {
  if (!Pt || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let i = e.firstChild;
    Jf(n, i, "true"), setTimeout(() => Jf(n, i, "false"), 20);
  }
  return !1;
}
function tx(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function nx(n, e) {
  let t = e.keyCode, i = tx(e);
  if (t == 8 || un && t == 72 && i == "c")
    return Gf(n, -1) || ar(n, -1);
  if (t == 46 && !e.shiftKey || un && t == 68 && i == "c")
    return Gf(n, 1) || ar(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || un && t == 66 && i == "c") {
    let r = t == 37 ? Kf(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Uf(n, r, i) || ar(n, r);
  } else if (t == 39 || un && t == 70 && i == "c") {
    let r = t == 39 ? Kf(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Uf(n, r, i) || ar(n, r);
  } else {
    if (t == 38 || un && t == 80 && i == "c")
      return qf(n, -1, i) || ar(n, -1);
    if (t == 40 || un && t == 78 && i == "c")
      return ex(n) || qf(n, 1, i) || ar(n, 1);
    if (i == (un ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function Hu(n, e) {
  n.someProp("transformCopied", (h) => {
    e = h(e, n);
  });
  let t = [], { content: i, openStart: r, openEnd: s } = e;
  for (; r > 1 && s > 1 && i.childCount == 1 && i.firstChild.childCount == 1; ) {
    r--, s--;
    let h = i.firstChild;
    t.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), i = h.content;
  }
  let o = n.someProp("clipboardSerializer") || Yi.fromSchema(n.state.schema), a = ig(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(i, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = ng[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let p = a.createElement(u[h]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${r} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (h) => h(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function Zm(n, e, t, i, r) {
  let s = r.parent.type.spec.code, o, a;
  if (!t && !e)
    return null;
  let l = e && (i || s || !t);
  if (l) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || i, n);
    }), s)
      return e ? new Y($.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Y.empty;
    let d = n.someProp("clipboardTextParser", (f) => f(e, r, i, n));
    if (d)
      a = d;
    else {
      let f = r.marks(), { schema: h } = n.state, p = Yi.fromSchema(h);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((b) => {
        let m = o.appendChild(document.createElement("p"));
        b && m.appendChild(p.serializeNode(h.text(b, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (d) => {
      t = d(t, n);
    }), o = ox(t), to && ax(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (a || (a = (n.someProp("clipboardParser") || n.someProp("domParser") || br.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: r,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !ix.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = lx(Xf(a, +u[1], +u[2]), u[4]);
  else if (a = Y.maxOpen(rx(a.content, r), !0), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let h = a.content.firstChild; d < a.openStart && !h.type.spec.isolating; d++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; f < a.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    a = Xf(a, d, f);
  }
  return n.someProp("transformPasted", (d) => {
    a = d(a, n);
  }), a;
}
const ix = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function rx(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let r = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((a) => {
      if (!o)
        return;
      let l = r.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && s.length && eg(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = tg(o[o.length - 1], s.length));
        let u = Qm(a, l);
        o.push(u), r = r.matchType(u.type), s = l;
      }
    }), o)
      return $.from(o);
  }
  return n;
}
function Qm(n, e, t = 0) {
  for (let i = e.length - 1; i >= t; i--)
    n = e[i].create(null, $.from(n));
  return n;
}
function eg(n, e, t, i, r) {
  if (r < n.length && r < e.length && n[r] == e[r]) {
    let s = eg(n, e, t, i.lastChild, r + 1);
    if (s)
      return i.copy(i.content.replaceChild(i.childCount - 1, s));
    if (i.contentMatchAt(i.childCount).matchType(r == n.length - 1 ? t.type : n[r + 1]))
      return i.copy(i.content.append($.from(Qm(t, n, r + 1))));
  }
}
function tg(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, tg(n.lastChild, e - 1)), i = n.contentMatchAt(n.childCount).fillBefore($.empty, !0);
  return n.copy(t.append(i));
}
function Yc(n, e, t, i, r, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, a = o.content;
  return n.childCount > 1 && (s = 0), r < i - 1 && (a = Yc(a, e, t, i, r + 1, s)), r >= t && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= r).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore($.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(a));
}
function Xf(n, e, t) {
  return e < n.openStart && (n = new Y(Yc(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new Y(Yc(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const ng = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Yf = null;
function ig() {
  return Yf || (Yf = document.implementation.createHTMLDocument("title"));
}
let jl = null;
function sx(n) {
  let e = window.trustedTypes;
  return e ? (jl || (jl = e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), jl.createHTML(n)) : n;
}
function ox(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = ig().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(n), r;
  if ((r = i && ng[i[1].toLowerCase()]) && (n = r.map((s) => "<" + s + ">").join("") + n + r.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = sx(n), r)
    for (let s = 0; s < r.length; s++)
      t = t.querySelector(r[s]) || t;
  return t;
}
function ax(n) {
  let e = n.querySelectorAll(At ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    i.childNodes.length == 1 && i.textContent == "" && i.parentNode && i.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), i);
  }
}
function lx(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, i;
  try {
    i = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: r, openStart: s, openEnd: o } = n;
  for (let a = i.length - 2; a >= 0; a -= 2) {
    let l = t.nodes[i[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    r = $.from(l.create(i[a + 1], r)), s++, o++;
  }
  return new Y(r, s, o);
}
const Dt = {}, $t = {}, cx = { touchstart: !0, touchmove: !0 };
class ux {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function dx(n) {
  for (let e in Dt) {
    let t = Dt[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (i) => {
      hx(n, i) && !Fu(n, i) && (n.editable || !(i.type in $t)) && t(n, i);
    }, cx[e] ? { passive: !0 } : void 0);
  }
  Pt && n.dom.addEventListener("input", () => null), Zc(n);
}
function bi(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function fx(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Zc(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (i) => Fu(n, i));
  });
}
function Fu(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let i = t[e.type];
    return i ? i(n, e) || e.defaultPrevented : !1;
  });
}
function hx(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function px(n, e) {
  !Fu(n, e) && Dt[e.type] && (n.editable || !(e.type in $t)) && Dt[e.type](n, e);
}
$t.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !sg(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Xn && At && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Br && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let i = Date.now();
      n.input.lastIOSEnter = i, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == i && (n.someProp("handleKeyDown", (r) => r(n, Oi(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (i) => i(n, t)) || nx(n, t) ? t.preventDefault() : bi(n, "key");
};
$t.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
$t.keypress = (n, e) => {
  let t = e;
  if (sg(n, t) || !t.charCode || t.ctrlKey && !t.altKey || un && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (r) => r(n, t))) {
    t.preventDefault();
    return;
  }
  let i = n.state.selection;
  if (!(i instanceof ue) || !i.$from.sameParent(i.$to)) {
    let r = String.fromCharCode(t.charCode);
    !/[\r\n]/.test(r) && !n.someProp("handleTextInput", (s) => s(n, i.$from.pos, i.$to.pos, r)) && n.dispatch(n.state.tr.insertText(r).scrollIntoView()), t.preventDefault();
  }
};
function al(n) {
  return { left: n.clientX, top: n.clientY };
}
function mx(n, e) {
  let t = e.x - n.clientX, i = e.y - n.clientY;
  return t * t + i * i < 100;
}
function Vu(n, e, t, i, r) {
  if (i == -1)
    return !1;
  let s = n.state.doc.resolve(i);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (a) => o > s.depth ? a(n, t, s.nodeAfter, s.before(o), r, !0) : a(n, t, s.node(o), s.before(o), r, !1)))
      return !0;
  return !1;
}
function xr(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let i = n.state.tr.setSelection(e);
  i.setMeta("pointer", !0), n.dispatch(i);
}
function gx(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), i = t.nodeAfter;
  return i && i.isAtom && ae.isSelectable(i) ? (xr(n, new ae(t)), !0) : !1;
}
function _x(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, i, r;
  t instanceof ae && (i = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ae.isSelectable(a)) {
      i && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? r = s.before(t.$from.depth) : r = s.before(o);
      break;
    }
  }
  return r != null ? (xr(n, ae.create(n.state.doc, r)), !0) : !1;
}
function bx(n, e, t, i, r) {
  return Vu(n, "handleClickOn", e, t, i) || n.someProp("handleClick", (s) => s(n, e, i)) || (r ? _x(n, t) : gx(n, t));
}
function vx(n, e, t, i) {
  return Vu(n, "handleDoubleClickOn", e, t, i) || n.someProp("handleDoubleClick", (r) => r(n, e, i));
}
function yx(n, e, t, i) {
  return Vu(n, "handleTripleClickOn", e, t, i) || n.someProp("handleTripleClick", (r) => r(n, e, i)) || xx(n, t, i);
}
function xx(n, e, t) {
  if (t.button != 0)
    return !1;
  let i = n.state.doc;
  if (e == -1)
    return i.inlineContent ? (xr(n, ue.create(i, 0, i.content.size)), !0) : !1;
  let r = i.resolve(e);
  for (let s = r.depth + 1; s > 0; s--) {
    let o = s > r.depth ? r.nodeAfter : r.node(s), a = r.before(s);
    if (o.inlineContent)
      xr(n, ue.create(i, a + 1, a + 1 + o.content.size));
    else if (ae.isSelectable(o))
      xr(n, ae.create(i, a));
    else
      continue;
    return !0;
  }
}
function ju(n) {
  return ha(n);
}
const rg = un ? "metaKey" : "ctrlKey";
Dt.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let i = ju(n), r = Date.now(), s = "singleClick";
  r - n.input.lastClick.time < 500 && mx(t, n.input.lastClick) && !t[rg] && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: r, x: t.clientX, y: t.clientY, type: s };
  let o = n.posAtCoords(al(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new wx(n, o, t, !!i)) : (s == "doubleClick" ? vx : yx)(n, o.pos, o.inside, t) ? t.preventDefault() : bi(n, "pointer"));
};
class wx {
  constructor(e, t, i, r) {
    this.view = e, this.pos = t, this.event = i, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!i[rg], this.allowDefault = i.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = r ? null : i.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (i.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof ae && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Sn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), bi(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Qn(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(al(e))), this.updateAllowDefault(e), this.allowDefault || !t ? bi(this.view, "pointer") : bx(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Pt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    At && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (xr(this.view, pe.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : bi(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), bi(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Dt.touchstart = (n) => {
  n.input.lastTouch = Date.now(), ju(n), bi(n, "pointer");
};
Dt.touchmove = (n) => {
  n.input.lastTouch = Date.now(), bi(n, "pointer");
};
Dt.contextmenu = (n) => ju(n);
function sg(n, e) {
  return n.composing ? !0 : Pt && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const kx = Xn ? 5e3 : -1;
$t.compositionstart = $t.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof ue && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((i) => i.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), ha(n, !0), n.markCursor = null;
    else if (ha(n, !e.selection.empty), Sn && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let i = n.domSelectionRange();
      for (let r = i.focusNode, s = i.focusOffset; r && r.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? r.lastChild : r.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let a = n.domSelection();
          a && a.collapse(o, o.nodeValue.length);
          break;
        } else
          r = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  og(n, kx);
};
$t.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, og(n, 20));
};
function og(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => ha(n), e));
}
function ag(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = Cx()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function Sx(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = gy(e.focusNode, e.focusOffset), i = _y(e.focusNode, e.focusOffset);
  if (t && i && t != i) {
    let r = i.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || i == s)
      return s;
    if (!r || !r.isText(i.nodeValue))
      return i;
    if (n.input.compositionNode == i) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return i;
    }
  }
  return t || i;
}
function Cx() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function ha(n, e = !1) {
  if (!(Xn && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), ag(n), e || n.docView && n.docView.dirty) {
      let t = Bu(n);
      return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !n.state.selection.empty ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function Tx(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let i = getSelection(), r = document.createRange();
  r.selectNodeContents(e), n.dom.blur(), i.removeAllRanges(), i.addRange(r), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const zs = Kt && vi < 15 || Br && wy < 604;
Dt.copy = $t.cut = (n, e) => {
  let t = e, i = n.state.selection, r = t.type == "cut";
  if (i.empty)
    return;
  let s = zs ? null : t.clipboardData, o = i.content(), { dom: a, text: l } = Hu(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : Tx(n, a), r && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function Ex(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function Ax(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, i = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (i.contentEditable = "true"), i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus();
  let r = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), i.parentNode && i.parentNode.removeChild(i), t ? Hs(n, i.value, null, r, e) : Hs(n, i.textContent, i.innerHTML, r, e);
  }, 50);
}
function Hs(n, e, t, i, r) {
  let s = Zm(n, e, t, i, n.state.selection.$from);
  if (n.someProp("handlePaste", (l) => l(n, r, s || Y.empty)))
    return !0;
  if (!s)
    return !1;
  let o = Ex(s), a = o ? n.state.tr.replaceSelectionWith(o, i) : n.state.tr.replaceSelection(s);
  return n.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function lg(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
$t.paste = (n, e) => {
  let t = e;
  if (n.composing && !Xn)
    return;
  let i = zs ? null : t.clipboardData, r = n.input.shiftKey && n.input.lastKeyCode != 45;
  i && Hs(n, lg(i), i.getData("text/html"), r, t) ? t.preventDefault() : Ax(n, t);
};
class cg {
  constructor(e, t, i) {
    this.slice = e, this.move = t, this.node = i;
  }
}
const ug = un ? "altKey" : "ctrlKey";
Dt.dragstart = (n, e) => {
  let t = e, i = n.input.mouseDown;
  if (i && i.done(), !t.dataTransfer)
    return;
  let r = n.state.selection, s = r.empty ? null : n.posAtCoords(al(t)), o;
  if (!(s && s.pos >= r.from && s.pos <= (r instanceof ae ? r.to - 1 : r.to))) {
    if (i && i.mightDrag)
      o = ae.create(n.state.doc, i.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let d = n.docView.nearestDesc(t.target, !0);
      d && d.node.type.spec.draggable && d != n.docView && (o = ae.create(n.state.doc, d.posBefore));
    }
  }
  let a = (o || n.state.selection).content(), { dom: l, text: c, slice: u } = Hu(n, a);
  (!t.dataTransfer.files.length || !At || Dm > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(zs ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", zs || t.dataTransfer.setData("text/plain", c), n.dragging = new cg(u, !t[ug], o);
};
Dt.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
$t.dragover = $t.dragenter = (n, e) => e.preventDefault();
$t.drop = (n, e) => {
  let t = e, i = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let r = n.posAtCoords(al(t));
  if (!r)
    return;
  let s = n.state.doc.resolve(r.pos), o = i && i.slice;
  o ? n.someProp("transformPasted", (p) => {
    o = p(o, n);
  }) : o = Zm(n, lg(t.dataTransfer), zs ? null : t.dataTransfer.getData("text/html"), !1, s);
  let a = !!(i && !t[ug]);
  if (n.someProp("handleDrop", (p) => p(n, t, o || Y.empty, a))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let l = o ? Em(n.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let c = n.state.tr;
  if (a) {
    let { node: p } = i;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let h = c.doc.resolve(u);
  if (d && ae.isSelectable(o.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ae(h));
  else {
    let p = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((b, m, g, v) => p = v), c.setSelection(zu(n, h, c.doc.resolve(p)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
Dt.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && Qn(n);
  }, 20));
};
Dt.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
Dt.beforeinput = (n, e) => {
  if (At && Xn && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: i } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != i || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Oi(8, "Backspace")))))
        return;
      let { $cursor: r } = n.state.selection;
      r && r.pos > 0 && n.dispatch(n.state.tr.delete(r.pos - 1, r.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in $t)
  Dt[n] = $t[n];
function Fs(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class pa {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || Vi, this.side = this.spec.side || 0;
  }
  map(e, t, i, r) {
    let { pos: s, deleted: o } = e.mapResult(t.from + r, this.side < 0 ? -1 : 1);
    return o ? null : new gt(s - i, s - i, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof pa && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Fs(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class xi {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Vi;
  }
  map(e, t, i, r) {
    let s = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - i, o = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - i;
    return s >= o ? null : new gt(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof xi && Fs(this.attrs, e.attrs) && Fs(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof xi;
  }
  destroy() {
  }
}
class Wu {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Vi;
  }
  map(e, t, i, r) {
    let s = e.mapResult(t.from + r, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + r, -1);
    return o.deleted || o.pos <= s.pos ? null : new gt(s.pos - i, o.pos - i, this);
  }
  valid(e, t) {
    let { index: i, offset: r } = e.content.findIndex(t.from), s;
    return r == t.from && !(s = e.child(i)).isText && r + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof Wu && Fs(this.attrs, e.attrs) && Fs(this.spec, e.spec);
  }
  destroy() {
  }
}
class gt {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.type = i;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new gt(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, i) {
    return this.type.map(e, this, t, i);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, i) {
    return new gt(e, e, new pa(t, i));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, i, r) {
    return new gt(e, t, new xi(i, r));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, i, r) {
    return new gt(e, t, new Wu(i, r));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof xi;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof pa;
  }
}
const ur = [], Vi = {};
class je {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : ur, this.children = t.length ? t : ur;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? ma(t, e, 0, Vi) : Et;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, i) {
    let r = [];
    return this.findInner(e ?? 0, t ?? 1e9, r, 0, i), r;
  }
  findInner(e, t, i, r, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= t && a.to >= e && (!s || s(a.spec)) && i.push(a.copy(a.from + r, a.to + r));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, t - a, i, r + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, i) {
    return this == Et || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, i || Vi);
  }
  /**
  @internal
  */
  mapInner(e, t, i, r, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, i, r);
      l && l.type.valid(t, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? Mx(this.children, o || [], e, t, i, r, s) : o ? new je(o.sort(ji), ur) : Et;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == Et ? je.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, i) {
    let r, s = 0;
    e.forEach((a, l) => {
      let c = l + i, u;
      if (u = fg(t, a, c)) {
        for (r || (r = this.children.slice()); s < r.length && r[s] < l; )
          s += 3;
        r[s] == l ? r[s + 2] = r[s + 2].addInner(a, u, c + 1) : r.splice(s, 0, l, l + a.nodeSize, ma(u, a, c + 1, Vi)), s += 3;
      }
    });
    let o = dg(s ? hg(t) : t, -i);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new je(o.length ? this.local.concat(o).sort(ji) : this.local, r || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Et ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let i = this.children, r = this.local;
    for (let s = 0; s < i.length; s += 3) {
      let o, a = i[s] + t, l = i[s + 1] + t;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      i == this.children && (i = this.children.slice());
      let c = i[s + 2].removeInner(o, a + 1);
      c != Et ? i[s + 2] = c : (i.splice(s, 3), s -= 3);
    }
    if (r.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < r.length; a++)
            r[a].eq(o, t) && (r == this.local && (r = this.local.slice()), r.splice(a--, 1));
    }
    return i == this.children && r == this.local ? this : r.length || i.length ? new je(r, i) : Et;
  }
  forChild(e, t) {
    if (this == Et)
      return this;
    if (t.isLeaf)
      return je.empty;
    let i, r;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (i = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof xi) {
        let c = Math.max(s, l.from) - s, u = Math.min(o, l.to) - s;
        c < u && (r || (r = [])).push(l.copy(c, u));
      }
    }
    if (r) {
      let a = new je(r.sort(ji), ur);
      return i ? new di([a, i]) : a;
    }
    return i || Et;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof je) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return Uu(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Et)
      return ur;
    if (e.inlineContent || !this.local.some(xi.is))
      return this.local;
    let t = [];
    for (let i = 0; i < this.local.length; i++)
      this.local[i].type instanceof xi || t.push(this.local[i]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
je.empty = new je([], []);
je.removeOverlap = Uu;
const Et = je.empty;
class di {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const i = this.members.map((r) => r.map(e, t, Vi));
    return di.from(i);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return je.empty;
    let i = [];
    for (let r = 0; r < this.members.length; r++) {
      let s = this.members[r].forChild(e, t);
      s != Et && (s instanceof di ? i = i.concat(s.members) : i.push(s));
    }
    return di.from(i);
  }
  eq(e) {
    if (!(e instanceof di) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, i = !0;
    for (let r = 0; r < this.members.length; r++) {
      let s = this.members[r].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          i && (t = t.slice(), i = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? Uu(i ? t : t.sort(ji)) : ur;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Et;
      case 1:
        return e[0];
      default:
        return new di(e.every((t) => t instanceof je) ? e : e.reduce((t, i) => t.concat(i instanceof je ? i : i.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function Mx(n, e, t, i, r, s, o) {
  let a = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let d = 0;
    t.maps[c].forEach((f, h, p, b) => {
      let m = b - p - (h - f);
      for (let g = 0; g < a.length; g += 3) {
        let v = a[g + 1];
        if (v < 0 || f > v + u - d)
          continue;
        let x = a[g] + u - d;
        h >= x ? a[g + 1] = f <= x ? -2 : -1 : f >= u && m && (a[g] += m, a[g + 1] += m);
      }
      d += m;
    }), u = t.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), d = u - r;
      if (d < 0 || d >= i.content.size) {
        l = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), h = f - r, { index: p, offset: b } = i.content.findIndex(d), m = i.maybeChild(p);
      if (m && b == d && b + m.nodeSize == h) {
        let g = a[c + 2].mapInner(t, m, u + 1, n[c] + s + 1, o);
        g != Et ? (a[c] = d, a[c + 1] = h, a[c + 2] = g) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = Ox(a, n, e, t, r, s, o), u = ma(c, i, 0, o);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h = u.children[d];
      for (; f < a.length && a[f] < h; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new je(e.sort(ji), a);
}
function dg(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let i = 0; i < n.length; i++) {
    let r = n[i];
    t.push(new gt(r.from + e, r.to + e, r.type));
  }
  return t;
}
function Ox(n, e, t, i, r, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(i, r, c);
      d ? t.push(d) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < n.length; l += 3)
    n[l + 1] == -1 && a(n[l + 2], e[l] + s + 1);
  return t;
}
function fg(n, e, t) {
  if (e.isLeaf)
    return null;
  let i = t + e.nodeSize, r = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < i && ((r || (r = [])).push(o), n[s] = null);
  return r;
}
function hg(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function ma(n, e, t, i) {
  let r = [], s = !1;
  e.forEach((a, l) => {
    let c = fg(n, a, l + t);
    if (c) {
      s = !0;
      let u = ma(c, a, t + l + 1, i);
      u != Et && r.push(l, l + a.nodeSize, u);
    }
  });
  let o = dg(s ? hg(n) : n, -t).sort(ji);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (i.onRemove && i.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || r.length ? new je(o, r) : Et;
}
function ji(n, e) {
  return n.from - e.from || n.to - e.to;
}
function Uu(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let i = e[t];
    if (i.from != i.to)
      for (let r = t + 1; r < e.length; r++) {
        let s = e[r];
        if (s.from == i.from) {
          s.to != i.to && (e == n && (e = n.slice()), e[r] = s.copy(s.from, i.to), Zf(e, r + 1, s.copy(i.to, s.to)));
          continue;
        } else {
          s.from < i.to && (e == n && (e = n.slice()), e[t] = i.copy(i.from, s.from), Zf(e, r, i.copy(s.from, i.to)));
          break;
        }
      }
  }
  return e;
}
function Zf(n, e, t) {
  for (; e < n.length && ji(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function Wl(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let i = t(n.state);
    i && i != Et && e.push(i);
  }), n.cursorWrapper && e.push(je.create(n.state.doc, [n.cursorWrapper.deco])), di.from(e);
}
const Nx = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, Lx = Kt && vi <= 11;
class Rx {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class Ix {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Rx(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((i) => {
      for (let r = 0; r < i.length; r++)
        this.queue.push(i[r]);
      Kt && vi <= 11 && i.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Lx && (this.onCharData = (i) => {
      this.queue.push({ target: i.target, type: "characterData", oldValue: i.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Nx)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Wf(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Qn(this.view);
      if (Kt && vi <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Ki(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), i;
    for (let s = e.focusNode; s; s = $r(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = $r(s))
      if (t.has(s)) {
        i = s;
        break;
      }
    let r = i && this.view.docView.nearestDesc(i);
    if (r && r.ignoreMutation({
      type: "selection",
      target: i.nodeType == 3 ? i.parentNode : i
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let i = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(i) && Wf(e) && !this.ignoreSelectionChange(i), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let d = this.registerMutation(t[u], l);
        d && (s = s < 0 ? d.from : Math.min(d.from, s), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (a = !0));
      }
    if (Sn && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let h = f.parentNode;
          h && h.nodeName == "LI" && (!d || $x(e, d) != h) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && sl(i) && (c = Bu(e)) && c.eq(pe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Qn(e), this.currentSelection.set(i), e.scrollToSelection()) : (s > -1 || r) && (s > -1 && (e.docView.markDirty(s, o), Px(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(i) || Qn(e), this.currentSelection.set(i));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let i = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (i == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !i || i.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        t.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (i.contentDOM && i.contentDOM != i.dom && !i.contentDOM.contains(e.target))
        return { from: i.posBefore, to: i.posAfter };
      let r = e.previousSibling, s = e.nextSibling;
      if (Kt && vi <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (r = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = r && r.parentNode == e.target ? xt(r) + 1 : 0, a = i.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? xt(s) : e.target.childNodes.length, c = i.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border } : (this.lastChangedTextNode = e.target, {
      from: i.posAtStart,
      to: i.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let Qf = /* @__PURE__ */ new WeakMap(), eh = !1;
function Px(n) {
  if (!Qf.has(n) && (Qf.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Sn, eh)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), eh = !0;
  }
}
function th(n, e) {
  let t = e.startContainer, i = e.startOffset, r = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return Ki(o.node, o.offset, r, s) && ([t, i, r, s] = [r, s, t, i]), { anchorNode: t, anchorOffset: i, focusNode: r, focusOffset: s };
}
function Dx(n, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(n.root)[0];
    if (r)
      return th(n, r);
  }
  let t;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), t = r.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", i, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", i, !0), t ? th(n, t) : null;
}
function $x(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let i = n.docView.nearestDesc(t, !0);
    if (i && i.node.isBlock)
      return t;
  }
  return null;
}
function Bx(n, e, t) {
  let { node: i, fromOffset: r, toOffset: s, from: o, to: a } = n.docView.parseRange(e, t), l = n.domSelectionRange(), c, u = l.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], sl(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), At && n.input.lastKeyCode === 8)
    for (let m = s; m > r; m--) {
      let g = i.childNodes[m - 1], v = g.pmViewDesc;
      if (g.nodeName == "BR" && !v) {
        s = m;
        break;
      }
      if (!v || v.size)
        break;
    }
  let d = n.state.doc, f = n.someProp("domParser") || br.fromSchema(n.state.schema), h = d.resolve(o), p = null, b = f.parse(i, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: r,
    to: s,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: zx,
    context: h
  });
  if (c && c[0].pos != null) {
    let m = c[0].pos, g = c[1] && c[1].pos;
    g == null && (g = m), p = { anchor: m + o, head: g + o };
  }
  return { doc: b, sel: p, from: o, to: a };
}
function zx(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (Pt && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || Pt && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const Hx = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Fx(n, e, t, i, r) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let A = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, _ = Bu(n, A);
    if (_ && !n.state.selection.eq(_)) {
      if (At && Xn && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (M) => M(n, Oi(13, "Enter"))))
        return;
      let T = n.state.tr.setSelection(_);
      A == "pointer" ? T.setMeta("pointer", !0) : A == "key" && T.scrollIntoView(), s && T.setMeta("composition", s), n.dispatch(T);
    }
    return;
  }
  let o = n.state.doc.resolve(e), a = o.sharedDepth(t);
  e = o.before(a + 1), t = n.state.doc.resolve(t).after(a + 1);
  let l = n.state.selection, c = Bx(n, e, t), u = n.state.doc, d = u.slice(c.from, c.to), f, h;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, h = "end") : (f = n.state.selection.from, h = "start"), n.input.lastKeyCode = null;
  let p = Wx(d.content, c.doc.content, c.from, f, h);
  if (p && n.input.domChangeCount++, (Br && n.input.lastIOSEnter > Date.now() - 225 || Xn) && r.some((A) => A.nodeType == 1 && !Hx.test(A.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (A) => A(n, Oi(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (i && l instanceof ue && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let A = nh(n, n.state.doc, c.sel);
        if (A && !A.eq(n.state.selection)) {
          let _ = n.state.tr.setSelection(A);
          s && _.setMeta("composition", s), n.dispatch(_);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof ue && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), Kt && vi <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == " " && (p.start--, p.endA--, p.endB--);
  let b = c.doc.resolveNoCache(p.start - c.from), m = c.doc.resolveNoCache(p.endB - c.from), g = u.resolve(p.start), v = b.sameParent(m) && b.parent.inlineContent && g.end() >= p.endA, x;
  if ((Br && n.input.lastIOSEnter > Date.now() - 225 && (!v || r.some((A) => A.nodeName == "DIV" || A.nodeName == "P")) || !v && b.pos < c.doc.content.size && !b.sameParent(m) && (x = pe.findFrom(c.doc.resolve(b.pos + 1), 1, !0)) && x.head == m.pos) && n.someProp("handleKeyDown", (A) => A(n, Oi(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > p.start && jx(u, p.start, p.endA, b, m) && n.someProp("handleKeyDown", (A) => A(n, Oi(8, "Backspace")))) {
    Xn && At && n.domObserver.suppressSelectionUpdates();
    return;
  }
  At && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), Xn && !v && b.start() != m.start() && m.parentOffset == 0 && b.depth == m.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, m = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(A) {
      return A(n, Oi(13, "Enter"));
    });
  }, 20));
  let w = p.start, S = p.endA, k, C, y;
  if (v) {
    if (b.pos == m.pos)
      Kt && vi <= 11 && b.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => Qn(n), 20)), k = n.state.tr.delete(w, S), C = u.resolve(p.start).marksAcross(u.resolve(p.endA));
    else if (
      // Adding or removing a mark
      p.endA == p.endB && (y = Vx(b.parent.content.cut(b.parentOffset, m.parentOffset), g.parent.content.cut(g.parentOffset, p.endA - g.start())))
    )
      k = n.state.tr, y.type == "add" ? k.addMark(w, S, y.mark) : k.removeMark(w, S, y.mark);
    else if (b.parent.child(b.index()).isText && b.index() == m.index() - (m.textOffset ? 0 : 1)) {
      let A = b.parent.textBetween(b.parentOffset, m.parentOffset);
      if (n.someProp("handleTextInput", (_) => _(n, w, S, A)))
        return;
      k = n.state.tr.insertText(A, w, S);
    }
  }
  if (k || (k = n.state.tr.replace(w, S, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel) {
    let A = nh(n, k.doc, c.sel);
    A && !(At && n.composing && A.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (A.head == w || A.head == k.mapping.map(S) - 1) || Kt && A.empty && A.head == w) && k.setSelection(A);
  }
  C && k.ensureMarks(C), s && k.setMeta("composition", s), n.dispatch(k.scrollIntoView());
}
function nh(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : zu(n, e.resolve(t.anchor), e.resolve(t.head));
}
function Vx(n, e) {
  let t = n.firstChild.marks, i = e.firstChild.marks, r = t, s = i, o, a, l;
  for (let u = 0; u < i.length; u++)
    r = i[u].removeFromSet(r);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (r.length == 1 && s.length == 0)
    a = r[0], o = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (r.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if ($.from(c).eq(n))
    return { mark: a, type: o };
}
function jx(n, e, t, i, r) {
  if (
    // The content must have shrunk
    t - e <= r.pos - i.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Ul(i, !0, !1) < r.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!i.parent.isTextblock) {
    let a = s.nodeAfter;
    return a != null && t == e + a.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(Ul(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || Ul(o, !0, !1) < t ? !1 : i.parent.content.cut(i.parentOffset).eq(o.parent.content);
}
function Ul(n, e, t) {
  let i = n.depth, r = e ? n.end() : n.pos;
  for (; i > 0 && (e || n.indexAfter(i) == n.node(i).childCount); )
    i--, r++, e = !1;
  if (t) {
    let s = n.node(i).maybeChild(n.indexAfter(i));
    for (; s && !s.isLeaf; )
      s = s.firstChild, r++;
  }
  return r;
}
function Wx(n, e, t, i, r) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: a } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (r == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    i -= o + l - s;
  }
  if (o < s && n.size < e.size) {
    let l = i <= s && i >= o ? s - i : 0;
    s -= l, s && s < e.size && ih(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), a = s + (a - o), o = s;
  } else if (a < s) {
    let l = i <= s && i >= a ? s - i : 0;
    s -= l, s && s < n.size && ih(n.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
function ih(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class Ux {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ux(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(lh), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = oh(this), sh(this), this.nodeViews = ah(this), this.docView = Bf(this.state.doc, rh(this), Wl(this), this.dom, this), this.domObserver = new Ix(this, (i, r, s, o) => Fx(this, i, r, s, o)), this.domObserver.start(), dx(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Zc(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(lh), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let i in this._props)
      t[i] = this._props[i];
    t.state = this.state;
    for (let i in e)
      t[i] = e[i];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var i;
    let r = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (ag(this), o = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != t.plugins;
    if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let h = ah(this);
      qx(h, this.nodeViews) && (this.nodeViews = h, s = !0);
    }
    (a || t.handleDOMEvents != this._props.handleDOMEvents) && Zc(this), this.editable = oh(this), sh(this);
    let l = Wl(this), c = rh(this), u = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", d = s || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(r.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && Cy(this);
    if (o) {
      this.domObserver.stop();
      let h = d && (Kt || At) && !this.composing && !r.selection.empty && !e.selection.empty && Kx(r.selection, e.selection);
      if (d) {
        let p = At ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = Sx(this)), (s || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Bf(e.doc, c, l, this.dom, this)), p && !this.trackWrites && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Jy(this)) ? Qn(this, h) : (Jm(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), !((i = this.dragging) === null || i === void 0) && i.node && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && Ty(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof ae) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && Lf(this, t.getBoundingClientRect(), e);
      } else
        Lf(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let i = this.directPlugins[t];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let i = this.state.plugins[t];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let i = this.pluginViews[t];
        i.update && i.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let i = e.node, r = -1;
    if (this.state.doc.nodeAt(i.from) == i.node)
      r = i.from;
    else {
      let s = i.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == i.node && (r = s);
    }
    this.dragging = new cg(e.slice, e.move, r < 0 ? void 0 : ae.create(this.state.doc, r));
  }
  someProp(e, t) {
    let i = this._props && this._props[e], r;
    if (i != null && (r = t ? t(i) : i))
      return r;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (r = t ? t(a) : a))
        return r;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (r = t ? t(a) : a))
          return r;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Kt) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && Ey(this.dom), Qn(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return Ly(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return Fm(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, i = -1) {
    let r = this.docView.posFromDOM(e, t, i);
    if (r == null)
      throw new RangeError("DOM position not inside the editor");
    return r;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return $y(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return Hs(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return Hs(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return Hu(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (fx(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Wl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, py());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return px(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let t = this._props.dispatchTransaction;
    t ? t.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Pt && this.root.nodeType === 11 && vy(this.dom.ownerDocument) == this.dom && Dx(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function rh(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let i in t)
        i == "class" ? e.class += " " + t[i] : i == "style" ? e.style = (e.style ? e.style + ";" : "") + t[i] : !e[i] && i != "contenteditable" && i != "nodeName" && (e[i] = String(t[i]));
  }), e.translate || (e.translate = "no"), [gt.node(0, n.state.doc.content.size, e)];
}
function sh(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: gt.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function oh(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function Kx(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function ah(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    for (let r in i)
      Object.prototype.hasOwnProperty.call(e, r) || (e[r] = i[r]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function qx(n, e) {
  let t = 0, i = 0;
  for (let r in n) {
    if (n[r] != e[r])
      return !0;
    t++;
  }
  for (let r in e)
    i++;
  return t != i;
}
function lh(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var ki = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ga = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Gx = typeof navigator < "u" && /Mac/.test(navigator.platform), Jx = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var wt = 0; wt < 10; wt++) ki[48 + wt] = ki[96 + wt] = String(wt);
for (var wt = 1; wt <= 24; wt++) ki[wt + 111] = "F" + wt;
for (var wt = 65; wt <= 90; wt++)
  ki[wt] = String.fromCharCode(wt + 32), ga[wt] = String.fromCharCode(wt);
for (var Kl in ki) ga.hasOwnProperty(Kl) || (ga[Kl] = ki[Kl]);
function Xx(n) {
  var e = Gx && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || Jx && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? ga : ki)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const Yx = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function Zx(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let i, r, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      Yx ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return i && (t = "Alt-" + t), r && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function Qx(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[Zx(t)] = n[t];
  return e;
}
function ql(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function ew(n) {
  return new Ge({ props: { handleKeyDown: Ku(n) } });
}
function Ku(n) {
  let e = Qx(n);
  return function(t, i) {
    let r = Xx(i), s, o = e[ql(r, i)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (r.length == 1 && r != " ") {
      if (i.shiftKey) {
        let a = e[ql(r, i, !1)];
        if (a && a(t.state, t.dispatch, t))
          return !0;
      }
      if ((i.shiftKey || i.altKey || i.metaKey || r.charCodeAt(0) > 127) && (s = ki[i.keyCode]) && s != r) {
        let a = e[ql(s, i)];
        if (a && a(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const qu = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function pg(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const mg = (n, e, t) => {
  let i = pg(n, t);
  if (!i)
    return !1;
  let r = Gu(i);
  if (!r) {
    let o = i.blockRange(), a = o && Ur(o);
    return a == null ? !1 : (e && e(n.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = r.nodeBefore;
  if (Sg(n, r, e, -1))
    return !0;
  if (i.parent.content.size == 0 && (zr(s, "end") || ae.isSelectable(s)))
    for (let o = i.depth; ; o--) {
      let a = il(n.doc, i.before(o), i.after(o), Y.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = n.tr.step(a);
          l.setSelection(zr(s, "end") ? pe.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : ae.create(l.doc, r.pos - s.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || i.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && r.depth == i.depth - 1 ? (e && e(n.tr.delete(r.pos - s.nodeSize, r.pos).scrollIntoView()), !0) : !1;
}, tw = (n, e, t) => {
  let i = pg(n, t);
  if (!i)
    return !1;
  let r = Gu(i);
  return r ? gg(n, r, e) : !1;
}, nw = (n, e, t) => {
  let i = bg(n, t);
  if (!i)
    return !1;
  let r = Ju(i);
  return r ? gg(n, r, e) : !1;
};
function gg(n, e, t) {
  let i = e.nodeBefore, r = i, s = e.pos - 1;
  for (; !r.isTextblock; s--) {
    if (r.type.spec.isolating)
      return !1;
    let u = r.lastChild;
    if (!u)
      return !1;
    r = u;
  }
  let o = e.nodeAfter, a = o, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = il(n.doc, s, l, Y.empty);
  if (!c || c.from != s || c instanceof mt && c.slice.size >= l - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(ue.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function zr(n, e, t = !1) {
  for (let i = n; i; i = e == "start" ? i.firstChild : i.lastChild) {
    if (i.isTextblock)
      return !0;
    if (t && i.childCount != 1)
      return !1;
  }
  return !1;
}
const _g = (n, e, t) => {
  let { $head: i, empty: r } = n.selection, s = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : i.parentOffset > 0)
      return !1;
    s = Gu(i);
  }
  let o = s && s.nodeBefore;
  return !o || !ae.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ae.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function Gu(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function bg(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const vg = (n, e, t) => {
  let i = bg(n, t);
  if (!i)
    return !1;
  let r = Ju(i);
  if (!r)
    return !1;
  let s = r.nodeAfter;
  if (Sg(n, r, e, 1))
    return !0;
  if (i.parent.content.size == 0 && (zr(s, "start") || ae.isSelectable(s))) {
    let o = il(n.doc, i.before(), i.after(), Y.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = n.tr.step(o);
        a.setSelection(zr(s, "start") ? pe.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : ae.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && r.depth == i.depth - 1 ? (e && e(n.tr.delete(r.pos, r.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, yg = (n, e, t) => {
  let { $head: i, empty: r } = n.selection, s = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : i.parentOffset < i.parent.content.size)
      return !1;
    s = Ju(i);
  }
  let o = s && s.nodeAfter;
  return !o || !ae.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ae.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function Ju(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const iw = (n, e) => {
  let t = n.selection, i = t instanceof ae, r;
  if (i) {
    if (t.node.isTextblock || !Si(n.doc, t.from))
      return !1;
    r = t.from;
  } else if (r = nl(n.doc, t.from, -1), r == null)
    return !1;
  if (e) {
    let s = n.tr.join(r);
    i && s.setSelection(ae.create(s.doc, r - n.doc.resolve(r).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, rw = (n, e) => {
  let t = n.selection, i;
  if (t instanceof ae) {
    if (t.node.isTextblock || !Si(n.doc, t.to))
      return !1;
    i = t.to;
  } else if (i = nl(n.doc, t.to, 1), i == null)
    return !1;
  return e && e(n.tr.join(i).scrollIntoView()), !0;
}, sw = (n, e) => {
  let { $from: t, $to: i } = n.selection, r = t.blockRange(i), s = r && Ur(r);
  return s == null ? !1 : (e && e(n.tr.lift(r, s).scrollIntoView()), !0);
}, xg = (n, e) => {
  let { $head: t, $anchor: i } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(i) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function Xu(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const ow = (n, e) => {
  let { $head: t, $anchor: i } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(i))
    return !1;
  let r = t.node(-1), s = t.indexAfter(-1), o = Xu(r.contentMatchAt(s));
  if (!o || !r.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = t.after(), l = n.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(pe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, wg = (n, e) => {
  let t = n.selection, { $from: i, $to: r } = t;
  if (t instanceof Ut || i.parent.inlineContent || r.parent.inlineContent)
    return !1;
  let s = Xu(r.parent.contentMatchAt(r.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!i.parentOffset && r.index() < r.parent.childCount ? i : r).pos, a = n.tr.insert(o, s.createAndFill());
    a.setSelection(ue.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, kg = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (Zn(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let i = t.blockRange(), r = i && Ur(i);
  return r == null ? !1 : (e && e(n.tr.lift(i, r).scrollIntoView()), !0);
};
function aw(n) {
  return (e, t) => {
    let { $from: i, $to: r } = e.selection;
    if (e.selection instanceof ae && e.selection.node.isBlock)
      return !i.parentOffset || !Zn(e.doc, i.pos) ? !1 : (t && t(e.tr.split(i.pos).scrollIntoView()), !0);
    if (!i.depth)
      return !1;
    let s = [], o, a, l = !1, c = !1;
    for (let h = i.depth; ; h--)
      if (i.node(h).isBlock) {
        l = i.end(h) == i.pos + (i.depth - h), c = i.start(h) == i.pos - (i.depth - h), a = Xu(i.node(h - 1).contentMatchAt(i.indexAfter(h - 1))), s.unshift(l && a ? { type: a } : null), o = h;
        break;
      } else {
        if (h == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof ue || e.selection instanceof Ut) && u.deleteSelection();
    let d = u.mapping.map(i.pos), f = Zn(u.doc, d, s.length, s);
    if (f || (s[0] = a ? { type: a } : null, f = Zn(u.doc, d, s.length, s)), u.split(d, s.length, s), !l && c && i.node(o).type != a) {
      let h = u.mapping.map(i.before(o)), p = u.doc.resolve(h);
      a && i.node(o - 1).canReplaceWith(p.index(), p.index() + 1, a) && u.setNodeMarkup(u.mapping.map(i.before(o)), a);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const lw = aw(), cw = (n, e) => {
  let { $from: t, to: i } = n.selection, r, s = t.sharedDepth(i);
  return s == 0 ? !1 : (r = t.before(s), e && e(n.tr.setSelection(ae.create(n.doc, r))), !0);
};
function uw(n, e, t) {
  let i = e.nodeBefore, r = e.nodeAfter, s = e.index();
  return !i || !r || !i.type.compatibleContent(r.type) ? !1 : !i.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(r.isTextblock || Si(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function Sg(n, e, t, i) {
  let r = e.nodeBefore, s = e.nodeAfter, o, a, l = r.type.spec.isolating || s.type.spec.isolating;
  if (!l && uw(n, e, t))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (a = r.contentMatchAt(r.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let h = e.pos + s.nodeSize, p = $.empty;
      for (let g = o.length - 1; g >= 0; g--)
        p = $.from(o[g].create(null, p));
      p = $.from(r.copy(p));
      let b = n.tr.step(new _t(e.pos - 1, h, e.pos, h, new Y(p, 1, 0), o.length, !0)), m = b.doc.resolve(h + 2 * o.length);
      m.nodeAfter && m.nodeAfter.type == r.type && Si(b.doc, m.pos) && b.join(m.pos), t(b.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || i > 0 && l ? null : pe.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Ur(d);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(d, f).scrollIntoView()), !0;
  if (c && zr(s, "start", !0) && zr(r, "end")) {
    let h = r, p = [];
    for (; p.push(h), !h.isTextblock; )
      h = h.lastChild;
    let b = s, m = 1;
    for (; !b.isTextblock; b = b.firstChild)
      m++;
    if (h.canReplace(h.childCount, h.childCount, b.content)) {
      if (t) {
        let g = $.empty;
        for (let x = p.length - 1; x >= 0; x--)
          g = $.from(p[x].copy(g));
        let v = n.tr.step(new _t(e.pos - p.length, e.pos + s.nodeSize, e.pos + m, e.pos + s.nodeSize - m, new Y(g, p.length, 0), 0, !0));
        t(v.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Cg(n) {
  return function(e, t) {
    let i = e.selection, r = n < 0 ? i.$from : i.$to, s = r.depth;
    for (; r.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return r.node(s).isTextblock ? (t && t(e.tr.setSelection(ue.create(e.doc, n < 0 ? r.start(s) : r.end(s)))), !0) : !1;
  };
}
const dw = Cg(-1), fw = Cg(1);
function hw(n, e = null) {
  return function(t, i) {
    let { $from: r, $to: s } = t.selection, o = r.blockRange(s), a = o && Iu(o, n, e);
    return a ? (i && i(t.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function ch(n, e = null) {
  return function(t, i) {
    let r = !1;
    for (let s = 0; s < t.selection.ranges.length && !r; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, a, (l, c) => {
        if (r)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(n, e)))
          if (l.type == n)
            r = !0;
          else {
            let u = t.doc.resolve(c), d = u.index();
            r = u.parent.canReplaceWith(d, d + 1, n);
          }
      });
    }
    if (!r)
      return !1;
    if (i) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = t.selection.ranges[o];
        s.setBlockType(a, l, n, e);
      }
      i(s.scrollIntoView());
    }
    return !0;
  };
}
function Yu(...n) {
  return function(e, t, i) {
    for (let r = 0; r < n.length; r++)
      if (n[r](e, t, i))
        return !0;
    return !1;
  };
}
Yu(qu, mg, _g);
Yu(qu, vg, yg);
Yu(xg, wg, kg, lw);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function pw(n, e = null) {
  return function(t, i) {
    let { $from: r, $to: s } = t.selection, o = r.blockRange(s);
    if (!o)
      return !1;
    let a = i ? t.tr : null;
    return mw(a, o, n, e) ? (i && i(a.scrollIntoView()), !0) : !1;
  };
}
function mw(n, e, t, i = null) {
  let r = !1, s = e, o = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = o.resolve(e.start - 2);
    s = new ca(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new ca(e.$from, o.resolve(e.$to.end(e.depth)), e.depth)), r = !0;
  }
  let a = Iu(s, t, i, e);
  return a ? (n && gw(n, e, a, r, t), !0) : !1;
}
function gw(n, e, t, i, r) {
  let s = $.empty;
  for (let u = t.length - 1; u >= 0; u--)
    s = $.from(t[u].type.create(t[u].attrs, s));
  n.step(new _t(e.start - (i ? 2 : 0), e.end, e.start, e.end, new Y(s, 0, 0), t.length, !0));
  let o = 0;
  for (let u = 0; u < t.length; u++)
    t[u].type == r && (o = u + 1);
  let a = t.length - o, l = e.start + t.length - (i ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && Zn(n.doc, l, a) && (n.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return n;
}
function _w(n) {
  return function(e, t) {
    let { $from: i, $to: r } = e.selection, s = i.blockRange(r, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? i.node(s.depth - 1).type == n ? bw(e, t, n, s) : vw(e, t, s) : !0 : !1;
  };
}
function bw(n, e, t, i) {
  let r = n.tr, s = i.end, o = i.$to.end(i.depth);
  s < o && (r.step(new _t(s - 1, o, s, o, new Y($.from(t.create(null, i.parent.copy())), 1, 0), 1, !0)), i = new ca(r.doc.resolve(i.$from.pos), r.doc.resolve(o), i.depth));
  const a = Ur(i);
  if (a == null)
    return !1;
  r.lift(i, a);
  let l = r.mapping.map(s, -1) - 1;
  return Si(r.doc, l) && r.join(l), e(r.scrollIntoView()), !0;
}
function vw(n, e, t) {
  let i = n.tr, r = t.parent;
  for (let h = t.end, p = t.endIndex - 1, b = t.startIndex; p > b; p--)
    h -= r.child(p).nodeSize, i.delete(h - 1, h + 1);
  let s = i.doc.resolve(t.start), o = s.nodeAfter;
  if (i.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let a = t.startIndex == 0, l = t.endIndex == r.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? $.empty : $.from(r))))
    return !1;
  let d = s.pos, f = d + o.nodeSize;
  return i.step(new _t(d - (a ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new Y((a ? $.empty : $.from(r.copy($.empty))).append(l ? $.empty : $.from(r.copy($.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(i.scrollIntoView()), !0;
}
function yw(n) {
  return function(e, t) {
    let { $from: i, $to: r } = e.selection, s = i.blockRange(r, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != n)
      return !1;
    if (t) {
      let c = l.lastChild && l.lastChild.type == a.type, u = $.from(c ? n.create() : null), d = new Y($.from(n.create(null, $.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, h = s.end;
      t(e.tr.step(new _t(f - (c ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
var xw = Object.defineProperty, Tg = (n, e) => {
  for (var t in e)
    xw(n, t, { get: e[t], enumerable: !0 });
};
function io(n) {
  const { state: e, transaction: t } = n;
  let { selection: i } = t, { doc: r } = t, { storedMarks: s } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return i;
    },
    get doc() {
      return r;
    },
    get tr() {
      return i = t.selection, r = t.doc, s = t.storedMarks, t;
    }
  };
}
var ro = class {
  constructor(n) {
    this.editor = n.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = n.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: n, editor: e, state: t } = this, { view: i } = e, { tr: r } = t, s = this.buildProps(r);
    return Object.fromEntries(
      Object.entries(n).map(([o, a]) => [o, (...c) => {
        const u = a(...c)(s);
        return !r.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(r), u;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(n, e = !0) {
    const { rawCommands: t, editor: i, state: r } = this, { view: s } = i, o = [], a = !!n, l = n || r.tr, c = () => (!a && e && !l.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(l), o.every((d) => d === !0)), u = {
      ...Object.fromEntries(
        Object.entries(t).map(([d, f]) => [d, (...p) => {
          const b = this.buildProps(l, e), m = f(...p)(b);
          return o.push(m), u;
        }])
      ),
      run: c
    };
    return u;
  }
  createCan(n) {
    const { rawCommands: e, state: t } = this, i = !1, r = n || t.tr, s = this.buildProps(r, i);
    return {
      ...Object.fromEntries(
        Object.entries(e).map(([a, l]) => [a, (...c) => l(...c)({ ...s, dispatch: void 0 })])
      ),
      chain: () => this.createChain(r, i)
    };
  }
  buildProps(n, e = !0) {
    const { rawCommands: t, editor: i, state: r } = this, { view: s } = i, o = {
      tr: n,
      editor: i,
      view: s,
      state: io({
        state: r,
        transaction: n
      }),
      dispatch: e ? () => {
      } : void 0,
      chain: () => this.createChain(n, e),
      can: () => this.createCan(n),
      get commands() {
        return Object.fromEntries(
          Object.entries(t).map(([a, l]) => [a, (...c) => l(...c)(o)])
        );
      }
    };
    return o;
  }
}, ww = class {
  constructor() {
    this.callbacks = {};
  }
  on(n, e) {
    return this.callbacks[n] || (this.callbacks[n] = []), this.callbacks[n].push(e), this;
  }
  emit(n, ...e) {
    const t = this.callbacks[n];
    return t && t.forEach((i) => i.apply(this, e)), this;
  }
  off(n, e) {
    const t = this.callbacks[n];
    return t && (e ? this.callbacks[n] = t.filter((i) => i !== e) : delete this.callbacks[n]), this;
  }
  once(n, e) {
    const t = (...i) => {
      this.off(n, t), e.apply(this, i);
    };
    return this.on(n, t);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function Zu(n, e) {
  const t = new Pu(n);
  return e.forEach((i) => {
    i.steps.forEach((r) => {
      t.step(r);
    });
  }), t;
}
var Eg = (n) => {
  const e = n.childNodes;
  for (let t = e.length - 1; t >= 0; t -= 1) {
    const i = e[t];
    i.nodeType === 3 && i.nodeValue && /^(\n\s\s|\n)$/.test(i.nodeValue) ? n.removeChild(i) : i.nodeType === 1 && Eg(i);
  }
  return n;
};
function pr(n) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
  return Eg(t);
}
function Hr(n, e, t) {
  if (n instanceof Bn || n instanceof $)
    return n;
  t = {
    slice: !0,
    parseOptions: {},
    ...t
  };
  const i = typeof n == "object" && n !== null, r = typeof n == "string";
  if (i)
    try {
      if (Array.isArray(n) && n.length > 0)
        return $.fromArray(n.map((a) => e.nodeFromJSON(a)));
      const o = e.nodeFromJSON(n);
      return t.errorOnInvalidContent && o.check(), o;
    } catch (s) {
      if (t.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", s), Hr("", e, t);
    }
  if (r) {
    if (t.errorOnInvalidContent) {
      let o = !1, a = "";
      const l = new gm({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (o = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (t.slice ? br.fromSchema(l).parseSlice(pr(n), t.parseOptions) : br.fromSchema(l).parse(pr(n), t.parseOptions), t.errorOnInvalidContent && o)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const s = br.fromSchema(e);
    return t.slice ? s.parseSlice(pr(n), t.parseOptions).content : s.parse(pr(n), t.parseOptions);
  }
  return Hr("", e, t);
}
function _a(n, e, t = {}, i = {}) {
  return Hr(n, e, {
    slice: !1,
    parseOptions: t,
    errorOnInvalidContent: i.errorOnInvalidContent
  });
}
function Ag(n) {
  for (let e = 0; e < n.edgeCount; e += 1) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function kw(n, e) {
  const t = [];
  return n.descendants((i, r) => {
    e(i) && t.push({
      node: i,
      pos: r
    });
  }), t;
}
function Mg(n, e, t) {
  const i = [];
  return n.nodesBetween(e.from, e.to, (r, s) => {
    t(r) && i.push({
      node: r,
      pos: s
    });
  }), i;
}
function Qu(n, e) {
  for (let t = n.depth; t > 0; t -= 1) {
    const i = n.node(t);
    if (e(i))
      return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: i
      };
  }
}
function Zi(n) {
  return (e) => Qu(e.$from, n);
}
function oe(n, e, t) {
  return n.config[e] === void 0 && n.parent ? oe(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
    ...t,
    parent: n.parent ? oe(n.parent, e, t) : null
  }) : n.config[e];
}
function ll(n) {
  return n.map((e) => {
    const t = {
      name: e.name,
      options: e.options,
      storage: e.storage
    }, i = oe(e, "addExtensions", t);
    return i ? [e, ...ll(i())] : e;
  }).flat(10);
}
function so(n, e) {
  const t = Yi.fromSchema(e).serializeFragment(n), r = document.implementation.createHTMLDocument().createElement("div");
  return r.appendChild(t), r.innerHTML;
}
function ed(n) {
  return typeof n == "function";
}
function Me(n, e = void 0, ...t) {
  return ed(n) ? e ? n.bind(e)(...t) : n(...t) : n;
}
function Og(n = {}) {
  return Object.keys(n).length === 0 && n.constructor === Object;
}
function Fr(n) {
  const e = n.filter((r) => r.type === "extension"), t = n.filter((r) => r.type === "node"), i = n.filter((r) => r.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: i
  };
}
function td(n) {
  const e = [], { nodeExtensions: t, markExtensions: i } = Fr(n), r = [...t, ...i], s = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return n.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage,
      extensions: r
    }, l = oe(
      o,
      "addGlobalAttributes",
      a
    );
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...s,
              ...h
            }
          });
        });
      });
    });
  }), r.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = oe(
      o,
      "addAttributes",
      a
    );
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...s,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: o.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function Te(...n) {
  return n.filter((e) => !!e).reduce((e, t) => {
    const i = { ...e };
    return Object.entries(t).forEach(([r, s]) => {
      if (!i[r]) {
        i[r] = s;
        return;
      }
      if (r === "class") {
        const a = s ? String(s).split(" ") : [], l = i[r] ? i[r].split(" ") : [], c = a.filter((u) => !l.includes(u));
        i[r] = [...l, ...c].join(" ");
      } else if (r === "style") {
        const a = s ? s.split(";").map((u) => u.trim()).filter(Boolean) : [], l = i[r] ? i[r].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), i[r] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        i[r] = s;
    }), i;
  }, {});
}
function Vs(n, e) {
  return e.filter((t) => t.type === n.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
    [t.name]: n.attrs[t.name]
  }).reduce((t, i) => Te(t, i), {});
}
function Ng(n) {
  return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n;
}
function Qc(n, e) {
  return "style" in n ? n : {
    ...n,
    getAttrs: (t) => {
      const i = n.getAttrs ? n.getAttrs(t) : n.attrs;
      if (i === !1)
        return !1;
      const r = e.reduce((s, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(t) : Ng(t.getAttribute(o.name));
        return a == null ? s : {
          ...s,
          [o.name]: a
        };
      }, {});
      return { ...i, ...r };
    }
  };
}
function uh(n) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(n).filter(([e, t]) => e === "attrs" && Og(t) ? !1 : t != null)
  );
}
function nd(n, e) {
  var t;
  const i = td(n), { nodeExtensions: r, markExtensions: s } = Fr(n), o = (t = r.find((c) => oe(c, "topNode"))) == null ? void 0 : t.name, a = Object.fromEntries(
    r.map((c) => {
      const u = i.filter((g) => g.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = n.reduce((g, v) => {
        const x = oe(v, "extendNodeSchema", d);
        return {
          ...g,
          ...x ? x(c) : {}
        };
      }, {}), h = uh({
        ...f,
        content: Me(oe(c, "content", d)),
        marks: Me(oe(c, "marks", d)),
        group: Me(oe(c, "group", d)),
        inline: Me(oe(c, "inline", d)),
        atom: Me(oe(c, "atom", d)),
        selectable: Me(oe(c, "selectable", d)),
        draggable: Me(oe(c, "draggable", d)),
        code: Me(oe(c, "code", d)),
        whitespace: Me(oe(c, "whitespace", d)),
        linebreakReplacement: Me(
          oe(c, "linebreakReplacement", d)
        ),
        defining: Me(oe(c, "defining", d)),
        isolating: Me(oe(c, "isolating", d)),
        attrs: Object.fromEntries(
          u.map((g) => {
            var v, x;
            return [
              g.name,
              { default: (v = g == null ? void 0 : g.attribute) == null ? void 0 : v.default, validate: (x = g == null ? void 0 : g.attribute) == null ? void 0 : x.validate }
            ];
          })
        )
      }), p = Me(oe(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (g) => Qc(g, u)
      ));
      const b = oe(c, "renderHTML", d);
      b && (h.toDOM = (g) => b({
        node: g,
        HTMLAttributes: Vs(g, u)
      }));
      const m = oe(c, "renderText", d);
      return m && (h.toText = m), [c.name, h];
    })
  ), l = Object.fromEntries(
    s.map((c) => {
      const u = i.filter((m) => m.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = n.reduce((m, g) => {
        const v = oe(g, "extendMarkSchema", d);
        return {
          ...m,
          ...v ? v(c) : {}
        };
      }, {}), h = uh({
        ...f,
        inclusive: Me(oe(c, "inclusive", d)),
        excludes: Me(oe(c, "excludes", d)),
        group: Me(oe(c, "group", d)),
        spanning: Me(oe(c, "spanning", d)),
        code: Me(oe(c, "code", d)),
        attrs: Object.fromEntries(
          u.map((m) => {
            var g, v;
            return [
              m.name,
              { default: (g = m == null ? void 0 : m.attribute) == null ? void 0 : g.default, validate: (v = m == null ? void 0 : m.attribute) == null ? void 0 : v.validate }
            ];
          })
        )
      }), p = Me(oe(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (m) => Qc(m, u)
      ));
      const b = oe(c, "renderHTML", d);
      return b && (h.toDOM = (m) => b({
        mark: m,
        HTMLAttributes: Vs(m, u)
      })), [c.name, h];
    })
  );
  return new gm({
    topNode: o,
    nodes: a,
    marks: l
  });
}
function Lg(n) {
  const e = n.filter((t, i) => n.indexOf(t) !== i);
  return Array.from(new Set(e));
}
function cl(n) {
  return n.sort((t, i) => {
    const r = oe(t, "priority") || 100, s = oe(i, "priority") || 100;
    return r > s ? -1 : r < s ? 1 : 0;
  });
}
function ul(n) {
  const e = cl(ll(n)), t = Lg(e.map((i) => i.name));
  return t.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${t.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`
  ), e;
}
function dl(n, e) {
  const t = ul(n);
  return nd(t, e);
}
function Sw(n, e) {
  const t = dl(e), i = Bn.fromJSON(t, n);
  return so(i.content, t);
}
function Rg(n, e) {
  const t = dl(e), i = pr(n);
  return br.fromSchema(t).parse(i).toJSON();
}
function id(n, e, t) {
  const { from: i, to: r } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = t || {};
  let a = "";
  return n.nodesBetween(i, r, (l, c, u, d) => {
    var f;
    l.isBlock && c > i && (a += s);
    const h = o == null ? void 0 : o[l.type.name];
    if (h)
      return u && (a += h({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) == null ? void 0 : f.slice(Math.max(i, c) - c, r - c));
  }), a;
}
function rd(n, e) {
  const t = {
    from: 0,
    to: n.content.size
  };
  return id(n, t, e);
}
function fl(n) {
  return Object.fromEntries(
    Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])
  );
}
function Cw(n, e, t) {
  const { blockSeparator: i = `

`, textSerializers: r = {} } = t || {}, s = dl(e), o = Bn.fromJSON(s, n);
  return rd(o, {
    blockSeparator: i,
    textSerializers: {
      ...fl(s),
      ...r
    }
  });
}
function Fn(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
    return e.marks[n];
  }
  return n;
}
function sd(n, e) {
  const t = Fn(e, n.schema), { from: i, to: r, empty: s } = n.selection, o = [];
  s ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(i, r, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === t.name);
  return a ? { ...a.attrs } : {};
}
function nt(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
    return e.nodes[n];
  }
  return n;
}
function Ig(n, e) {
  const t = nt(e, n.schema), { from: i, to: r } = n.selection, s = [];
  n.doc.nodesBetween(i, r, (a) => {
    s.push(a);
  });
  const o = s.reverse().find((a) => a.type.name === t.name);
  return o ? { ...o.attrs } : {};
}
function oo(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function od(n, e) {
  const t = oo(
    typeof e == "string" ? e : e.name,
    n.schema
  );
  return t === "node" ? Ig(n, e) : t === "mark" ? sd(n, e) : {};
}
function Pg(n, e = JSON.stringify) {
  const t = {};
  return n.filter((i) => {
    const r = e(i);
    return Object.prototype.hasOwnProperty.call(t, r) ? !1 : t[r] = !0;
  });
}
function Tw(n) {
  const e = Pg(n);
  return e.length === 1 ? e : e.filter((t, i) => !e.filter((s, o) => o !== i).some((s) => t.oldRange.from >= s.oldRange.from && t.oldRange.to <= s.oldRange.to && t.newRange.from >= s.newRange.from && t.newRange.to <= s.newRange.to));
}
function ad(n) {
  const { mapping: e, steps: t } = n, i = [];
  return e.maps.forEach((r, s) => {
    const o = [];
    if (r.ranges.length)
      r.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = t[s];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const c = e.slice(s).map(a, -1), u = e.slice(s).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      i.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), Tw(i);
}
function Dg(n, e = 0) {
  const i = n.type === n.type.schema.topNodeType ? 0 : 1, r = e, s = r + n.nodeSize, o = n.marks.map((c) => {
    const u = {
      type: c.type.name
    };
    return Object.keys(c.attrs).length && (u.attrs = { ...c.attrs }), u;
  }), a = { ...n.attrs }, l = {
    type: n.type.name,
    from: r,
    to: s
  };
  return Object.keys(a).length && (l.attrs = a), o.length && (l.marks = o), n.content.childCount && (l.content = [], n.forEach((c, u) => {
    var d;
    (d = l.content) == null || d.push(Dg(c, e + u + i));
  })), n.text && (l.text = n.text), l;
}
function hl(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
function js(n, e, t = { strict: !0 }) {
  const i = Object.keys(e);
  return i.length ? i.every((r) => t.strict ? e[r] === n[r] : hl(e[r]) ? e[r].test(n[r]) : e[r] === n[r]) : !0;
}
function $g(n, e, t = {}) {
  return n.find((i) => i.type === e && js(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(t).map((r) => [r, i.attrs[r]])),
    t
  ));
}
function dh(n, e, t = {}) {
  return !!$g(n, e, t);
}
function pl(n, e, t) {
  var i;
  if (!n || !e)
    return;
  let r = n.parent.childAfter(n.parentOffset);
  if ((!r.node || !r.node.marks.some((u) => u.type === e)) && (r = n.parent.childBefore(n.parentOffset)), !r.node || !r.node.marks.some((u) => u.type === e) || (t = t || ((i = r.node.marks[0]) == null ? void 0 : i.attrs), !$g([...r.node.marks], e, t)))
    return;
  let o = r.index, a = n.start() + r.offset, l = o + 1, c = a + r.node.nodeSize;
  for (; o > 0 && dh([...n.parent.child(o - 1).marks], e, t); )
    o -= 1, a -= n.parent.child(o).nodeSize;
  for (; l < n.parent.childCount && dh([...n.parent.child(l).marks], e, t); )
    c += n.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function ml(n, e, t) {
  const i = [];
  return n === e ? t.resolve(n).marks().forEach((r) => {
    const s = t.resolve(n), o = pl(s, r.type);
    o && i.push({
      mark: r,
      ...o
    });
  }) : t.nodesBetween(n, e, (r, s) => {
    !r || (r == null ? void 0 : r.nodeSize) === void 0 || i.push(
      ...r.marks.map((o) => ({
        from: s,
        to: s + r.nodeSize,
        mark: o
      }))
    );
  }), i;
}
var Bg = (n, e, t, i = 20) => {
  const r = n.doc.resolve(t);
  let s = i, o = null;
  for (; s > 0 && o === null; ) {
    const a = r.node(s);
    (a == null ? void 0 : a.type.name) === e ? o = a : s -= 1;
  }
  return [o, s];
};
function qo(n, e) {
  return e.nodes[n] || e.marks[n] || null;
}
function Cs(n, e, t) {
  return Object.fromEntries(
    Object.entries(t).filter(([i]) => {
      const r = n.find((s) => s.type === e && s.name === i);
      return r ? r.attribute.keepOnSplit : !1;
    })
  );
}
var zg = (n, e = 500) => {
  let t = "";
  const i = n.parentOffset;
  return n.parent.nodesBetween(Math.max(0, i - e), i, (r, s, o, a) => {
    var l, c;
    const u = ((c = (l = r.type.spec).toText) == null ? void 0 : c.call(l, {
      node: r,
      pos: s,
      parent: o,
      index: a
    })) || r.textContent || "%leaf%";
    t += r.isAtom && !r.isText ? u : u.slice(0, Math.max(0, i - s));
  }), t;
};
function ba(n, e, t = {}) {
  const { empty: i, ranges: r } = n.selection, s = e ? Fn(e, n.schema) : null;
  if (i)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((d) => s ? s.name === d.type.name : !0).find((d) => js(d.attrs, t, { strict: !1 }));
  let o = 0;
  const a = [];
  if (r.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, p = f.pos;
    n.doc.nodesBetween(h, p, (b, m) => {
      if (!b.isText && !b.marks.length)
        return;
      const g = Math.max(h, m), v = Math.min(p, m + b.nodeSize), x = v - g;
      o += x, a.push(
        ...b.marks.map((w) => ({
          mark: w,
          from: g,
          to: v
        }))
      );
    });
  }), o === 0)
    return !1;
  const l = a.filter((d) => s ? s.name === d.mark.type.name : !0).filter((d) => js(d.mark.attrs, t, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => s ? d.mark.type !== s && d.mark.type.excludes(s) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= o;
}
function ti(n, e, t = {}) {
  const { from: i, to: r, empty: s } = n.selection, o = e ? nt(e, n.schema) : null, a = [];
  n.doc.nodesBetween(i, r, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(i, f), p = Math.min(r, f + d.nodeSize);
    a.push({
      node: d,
      from: h,
      to: p
    });
  });
  const l = r - i, c = a.filter((d) => o ? o.name === d.node.type.name : !0).filter((d) => js(d.node.attrs, t, { strict: !1 }));
  return s ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
function Hg(n, e, t = {}) {
  if (!e)
    return ti(n, null, t) || ba(n, null, t);
  const i = oo(e, n.schema);
  return i === "node" ? ti(n, e, t) : i === "mark" ? ba(n, e, t) : !1;
}
var Fg = (n, e) => {
  const { $from: t, $to: i, $anchor: r } = n.selection;
  if (e) {
    const s = Zi((a) => a.type.name === e)(n.selection);
    if (!s)
      return !1;
    const o = n.doc.resolve(s.pos + 1);
    return r.pos + 1 === o.end();
  }
  return !(i.parentOffset < i.parent.nodeSize - 2 || t.pos !== i.pos);
}, Vg = (n) => {
  const { $from: e, $to: t } = n.selection;
  return !(e.parentOffset > 0 || e.pos !== t.pos);
};
function eu(n, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
}
function tu(n, e) {
  const { nodeExtensions: t } = Fr(e), i = t.find((o) => o.name === n);
  if (!i)
    return !1;
  const r = {
    name: i.name,
    options: i.options,
    storage: i.storage
  }, s = Me(oe(i, "group", r));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function ao(n, {
  checkChildren: e = !0,
  ignoreWhitespace: t = !1
} = {}) {
  var i;
  if (t) {
    if (n.type.name === "hardBreak")
      return !0;
    if (n.isText)
      return /^\s*$/m.test((i = n.text) != null ? i : "");
  }
  if (n.isText)
    return !n.text;
  if (n.isAtom || n.isLeaf)
    return !1;
  if (n.content.childCount === 0)
    return !0;
  if (e) {
    let r = !0;
    return n.content.forEach((s) => {
      r !== !1 && (ao(s, { ignoreWhitespace: t, checkChildren: e }) || (r = !1));
    }), r;
  }
  return !1;
}
function ld(n) {
  return n instanceof ae;
}
function cd(n) {
  return n instanceof ue;
}
function $n(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function Ew(n, e, t) {
  const r = n.state.doc.content.size, s = $n(e, 0, r), o = $n(t, 0, r), a = n.coordsAtPos(s), l = n.coordsAtPos(o, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - d, p = u - c, g = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: p,
    x: d,
    y: c
  };
  return {
    ...g,
    toJSON: () => g
  };
}
function ud(n, e = null) {
  if (!e)
    return null;
  const t = pe.atStart(n), i = pe.atEnd(n);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return i;
  const r = t.from, s = i.to;
  return e === "all" ? ue.create(n, $n(0, r, s), $n(n.content.size, r, s)) : ue.create(n, $n(e, r, s), $n(e, r, s));
}
function jg({
  json: n,
  validMarks: e,
  validNodes: t,
  options: i,
  rewrittenContent: r = []
}) {
  return n.marks && Array.isArray(n.marks) && (n.marks = n.marks.filter((s) => {
    const o = typeof s == "string" ? s : s.type;
    return e.has(o) ? !0 : (r.push({
      original: JSON.parse(JSON.stringify(s)),
      unsupported: o
    }), !1);
  })), n.content && Array.isArray(n.content) && (n.content = n.content.map(
    (s) => jg({
      json: s,
      validMarks: e,
      validNodes: t,
      options: i,
      rewrittenContent: r
    }).json
  ).filter((s) => s != null)), n.type && !t.has(n.type) ? (r.push({
    original: JSON.parse(JSON.stringify(n)),
    unsupported: n.type
  }), n.content && Array.isArray(n.content) && (i == null ? void 0 : i.fallbackToParagraph) !== !1 ? (n.type = "paragraph", {
    json: n,
    rewrittenContent: r
  }) : {
    json: null,
    rewrittenContent: r
  }) : { json: n, rewrittenContent: r };
}
function Aw(n, e, t) {
  return jg({
    json: n,
    validNodes: new Set(Object.keys(e.nodes)),
    validMarks: new Set(Object.keys(e.marks)),
    options: t
  });
}
function Wg(n, e, t) {
  const i = n.steps.length - 1;
  if (i < e)
    return;
  const r = n.steps[i];
  if (!(r instanceof mt || r instanceof _t))
    return;
  const s = n.mapping.maps[i];
  let o = 0;
  s.forEach((a, l, c, u) => {
    o === 0 && (o = u);
  }), n.setSelection(pe.near(n.doc.resolve(o), t));
}
var Qi = class {
  constructor(n) {
    this.find = n.find, this.handler = n.handler;
  }
}, Mw = (n, e) => {
  if (hl(e))
    return e.exec(n);
  const t = e(n);
  if (!t)
    return null;
  const i = [t.text];
  return i.index = t.index, i.input = n, i.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), i.push(t.replaceWith)), i;
};
function ko(n) {
  var e;
  const { editor: t, from: i, to: r, text: s, rules: o, plugin: a } = n, { view: l } = t;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(i);
  if (
    // check for code node
    c.parent.type.spec.code || (e = c.nodeBefore || c.nodeAfter) != null && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = zg(c) + s;
  return o.forEach((f) => {
    if (u)
      return;
    const h = Mw(d, f.find);
    if (!h)
      return;
    const p = l.state.tr, b = io({
      state: l.state,
      transaction: p
    }), m = {
      from: i - (h[0].length - s.length),
      to: r
    }, { commands: g, chain: v, can: x } = new ro({
      editor: t,
      state: b
    });
    f.handler({
      state: b,
      range: m,
      match: h,
      commands: g,
      chain: v,
      can: x
    }) === null || !p.steps.length || (p.setMeta(a, {
      transform: p,
      from: i,
      to: r,
      text: s
    }), l.dispatch(p), u = !0);
  }), u;
}
function Ug(n) {
  const { editor: e, rules: t } = n, i = new Ge({
    state: {
      init() {
        return null;
      },
      apply(r, s, o) {
        const a = r.getMeta(i);
        if (a)
          return a;
        const l = r.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = so($.from(u), o.schema);
          const { from: d } = l, f = d + u.length;
          ko({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: t,
            plugin: i
          });
        }), r.selectionSet || r.docChanged ? null : s;
      }
    },
    props: {
      handleTextInput(r, s, o, a) {
        return ko({
          editor: e,
          from: s,
          to: o,
          text: a,
          rules: t,
          plugin: i
        });
      },
      handleDOMEvents: {
        compositionend: (r) => (setTimeout(() => {
          const { $cursor: s } = r.state.selection;
          s && ko({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: t,
            plugin: i
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(r, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = r.state.selection;
        return o ? ko({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: t,
          plugin: i
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return i;
}
function Ow(n) {
  return Object.prototype.toString.call(n).slice(8, -1);
}
function _s(n) {
  return Ow(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
}
function dd(n, e) {
  const t = { ...n };
  return _s(n) && _s(e) && Object.keys(e).forEach((i) => {
    _s(e[i]) && _s(n[i]) ? t[i] = dd(n[i], e[i]) : t[i] = e[i];
  }), t;
}
var fd = class {
  constructor(n = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...n
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...Me(
        oe(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...Me(
        oe(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(n = {}) {
    const e = this.extend({
      ...this.config,
      addOptions: () => dd(this.options, n)
    });
    return e.name = this.name, e.parent = this.parent, e;
  }
  extend(n = {}) {
    const e = new this.constructor({ ...this.config, ...n });
    return e.parent = this, this.child = e, e.name = "name" in n ? n.name : e.parent.name, e;
  }
}, Qt = class Kg extends fd {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new Kg(t);
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: i } = e.state, r = e.state.selection.$from;
    if (r.pos === r.end()) {
      const o = r.marks();
      if (!!!o.find((c) => (c == null ? void 0 : c.type.name) === t.name))
        return !1;
      const l = o.find((c) => (c == null ? void 0 : c.type.name) === t.name);
      return l && i.removeStoredMark(l), i.insertText(" ", r.pos), e.view.dispatch(i), !0;
    }
    return !1;
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
};
function qg(n) {
  return typeof n == "number";
}
var gl = class {
  constructor(n) {
    this.find = n.find, this.handler = n.handler;
  }
}, Nw = (n, e, t) => {
  if (hl(e))
    return [...n.matchAll(e)];
  const i = e(n, t);
  return i ? i.map((r) => {
    const s = [r.text];
    return s.index = r.index, s.input = n, s.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(r.replaceWith)), s;
  }) : [];
};
function Lw(n) {
  const { editor: e, state: t, from: i, to: r, rule: s, pasteEvent: o, dropEvent: a } = n, { commands: l, chain: c, can: u } = new ro({
    editor: e,
    state: t
  }), d = [];
  return t.doc.nodesBetween(i, r, (h, p) => {
    if (!h.isTextblock || h.type.spec.code)
      return;
    const b = Math.max(i, p), m = Math.min(r, p + h.content.size), g = h.textBetween(b - p, m - p, void 0, "");
    Nw(g, s.find, o).forEach((x) => {
      if (x.index === void 0)
        return;
      const w = b + x.index + 1, S = w + x[0].length, k = {
        from: t.tr.mapping.map(w),
        to: t.tr.mapping.map(S)
      }, C = s.handler({
        state: t,
        range: k,
        match: x,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: o,
        dropEvent: a
      });
      d.push(C);
    });
  }), d.every((h) => h !== null);
}
var So = null, Rw = (n) => {
  var e;
  const t = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = t.clipboardData) == null || e.setData("text/html", n), t;
};
function Gg(n) {
  const { editor: e, rules: t } = n;
  let i = null, r = !1, s = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({
    state: u,
    from: d,
    to: f,
    rule: h,
    pasteEvt: p
  }) => {
    const b = u.tr, m = io({
      state: u,
      transaction: b
    });
    if (!(!Lw({
      editor: e,
      state: m,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: p,
      dropEvent: a
    }) || !b.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, b;
    }
  };
  return t.map((u) => new Ge({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (p) => {
        var b;
        i = (b = d.dom.parentElement) != null && b.contains(p.target) ? d.dom.parentElement : null, i && (So = e);
      }, h = () => {
        So && (So = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (s = i === d.dom.parentElement, a = f, !s) {
            const h = So;
            h != null && h.isEditable && setTimeout(() => {
              const p = h.state.selection;
              p && h.commands.deleteRange({ from: p.from, to: p.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var h;
          const p = (h = f.clipboardData) == null ? void 0 : h.getData("text/html");
          return o = f, r = !!(p != null && p.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, h) => {
      const p = d[0], b = p.getMeta("uiEvent") === "paste" && !r, m = p.getMeta("uiEvent") === "drop" && !s, g = p.getMeta("applyPasteRules"), v = !!g;
      if (!b && !m && !v)
        return;
      if (v) {
        let { text: S } = g;
        typeof S == "string" ? S = S : S = so($.from(S), h.schema);
        const { from: k } = g, C = k + S.length, y = Rw(S);
        return l({
          rule: u,
          state: h,
          from: k,
          to: { b: C },
          pasteEvt: y
        });
      }
      const x = f.doc.content.findDiffStart(h.doc.content), w = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!qg(x) || !w || x === w.b))
        return l({
          rule: u,
          state: h,
          from: x,
          to: w,
          pasteEvt: o
        });
    }
  }));
}
var _l = class {
  constructor(n, e) {
    this.splittableMarks = [], this.editor = e, this.extensions = ul(n), this.schema = nd(this.extensions, e), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((n, e) => {
      const t = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: qo(e.name, this.schema)
      }, i = oe(e, "addCommands", t);
      return i ? {
        ...n,
        ...i()
      } : n;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: n } = this, e = cl([...this.extensions].reverse()), t = [], i = [], r = e.map((s) => {
      const o = {
        name: s.name,
        options: s.options,
        storage: this.editor.extensionStorage[s.name],
        editor: n,
        type: qo(s.name, this.schema)
      }, a = [], l = oe(
        s,
        "addKeyboardShortcuts",
        o
      );
      let c = {};
      if (s.type === "mark" && oe(s, "exitable", o) && (c.ArrowRight = () => Qt.handleExit({ editor: n, mark: s })), l) {
        const p = Object.fromEntries(
          Object.entries(l()).map(([b, m]) => [b, () => m({ editor: n })])
        );
        c = { ...c, ...p };
      }
      const u = ew(c);
      a.push(u);
      const d = oe(s, "addInputRules", o);
      eu(s, n.options.enableInputRules) && d && t.push(...d());
      const f = oe(s, "addPasteRules", o);
      eu(s, n.options.enablePasteRules) && f && i.push(...f());
      const h = oe(
        s,
        "addProseMirrorPlugins",
        o
      );
      if (h) {
        const p = h();
        a.push(...p);
      }
      return a;
    }).flat();
    return [
      Ug({
        editor: n,
        rules: t
      }),
      ...Gg({
        editor: n,
        rules: i
      }),
      ...r
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return td(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: n } = this, { nodeExtensions: e } = Fr(this.extensions);
    return Object.fromEntries(
      e.filter((t) => !!oe(t, "addNodeView")).map((t) => {
        const i = this.attributes.filter((a) => a.type === t.name), r = {
          name: t.name,
          options: t.options,
          storage: this.editor.extensionStorage[t.name],
          editor: n,
          type: nt(t.name, this.schema)
        }, s = oe(t, "addNodeView", r);
        if (!s)
          return [];
        const o = (a, l, c, u, d) => {
          const f = Vs(a, i);
          return s()({
            // pass-through
            node: a,
            view: l,
            getPos: c,
            decorations: u,
            innerDecorations: d,
            // tiptap-specific
            editor: n,
            extension: t,
            HTMLAttributes: f
          });
        };
        return [t.name, o];
      })
    );
  }
  get markViews() {
    const { editor: n } = this, { markExtensions: e } = Fr(this.extensions);
    return Object.fromEntries(
      e.filter((t) => !!oe(t, "addMarkView")).map((t) => {
        const i = this.attributes.filter((a) => a.type === t.name), r = {
          name: t.name,
          options: t.options,
          storage: this.editor.extensionStorage[t.name],
          editor: n,
          type: Fn(t.name, this.schema)
        }, s = oe(t, "addMarkView", r);
        if (!s)
          return [];
        const o = (a, l, c) => {
          const u = Vs(a, i);
          return s()({
            // pass-through
            mark: a,
            view: l,
            inline: c,
            // tiptap-specific
            editor: n,
            extension: t,
            HTMLAttributes: u,
            updateAttributes: (d) => {
              md(a, n, d);
            }
          });
        };
        return [t.name, o];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const n = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      n.map((e) => [e.name, e.storage])
    ), n.forEach((e) => {
      var t;
      const i = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: qo(e.name, this.schema)
      };
      e.type === "mark" && ((t = Me(oe(e, "keepOnSplit", i))) == null || t) && this.splittableMarks.push(e.name);
      const r = oe(e, "onBeforeCreate", i), s = oe(e, "onCreate", i), o = oe(e, "onUpdate", i), a = oe(
        e,
        "onSelectionUpdate",
        i
      ), l = oe(e, "onTransaction", i), c = oe(e, "onFocus", i), u = oe(e, "onBlur", i), d = oe(e, "onDestroy", i);
      r && this.editor.on("beforeCreate", r), s && this.editor.on("create", s), o && this.editor.on("update", o), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
};
_l.resolve = ul;
_l.sort = cl;
_l.flatten = ll;
var Jg = {};
Tg(Jg, {
  ClipboardTextSerializer: () => Yg,
  Commands: () => Qg,
  Delete: () => e_,
  Drop: () => t_,
  Editable: () => n_,
  FocusEvents: () => r_,
  Keymap: () => s_,
  Paste: () => o_,
  Tabindex: () => a_,
  focusEventsPluginKey: () => i_
});
var ze = class Xg extends fd {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new Xg(t);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
}, Yg = ze.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: n } = this, { state: e, schema: t } = n, { doc: i, selection: r } = e, { ranges: s } = r, o = Math.min(...s.map((u) => u.$from.pos)), a = Math.max(...s.map((u) => u.$to.pos)), l = fl(t);
            return id(i, { from: o, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), Zg = {};
Tg(Zg, {
  blur: () => Iw,
  clearContent: () => Pw,
  clearNodes: () => Dw,
  command: () => $w,
  createParagraphNear: () => Bw,
  cut: () => zw,
  deleteCurrentNode: () => Hw,
  deleteNode: () => Fw,
  deleteRange: () => Vw,
  deleteSelection: () => jw,
  enter: () => Ww,
  exitCode: () => Uw,
  extendMarkRange: () => Kw,
  first: () => qw,
  focus: () => Gw,
  forEach: () => Jw,
  insertContent: () => Xw,
  insertContentAt: () => Zw,
  joinBackward: () => t2,
  joinDown: () => e2,
  joinForward: () => n2,
  joinItemBackward: () => i2,
  joinItemForward: () => r2,
  joinTextblockBackward: () => s2,
  joinTextblockForward: () => o2,
  joinUp: () => Qw,
  keyboardShortcut: () => l2,
  lift: () => c2,
  liftEmptyBlock: () => u2,
  liftListItem: () => d2,
  newlineInCode: () => f2,
  resetAttributes: () => h2,
  scrollIntoView: () => p2,
  selectAll: () => m2,
  selectNodeBackward: () => g2,
  selectNodeForward: () => _2,
  selectParentNode: () => b2,
  selectTextblockEnd: () => v2,
  selectTextblockStart: () => y2,
  setContent: () => x2,
  setMark: () => k2,
  setMeta: () => S2,
  setNode: () => C2,
  setNodeSelection: () => T2,
  setTextSelection: () => E2,
  sinkListItem: () => A2,
  splitBlock: () => M2,
  splitListItem: () => O2,
  toggleList: () => N2,
  toggleMark: () => L2,
  toggleNode: () => R2,
  toggleWrap: () => I2,
  undoInputRule: () => P2,
  unsetAllMarks: () => D2,
  unsetMark: () => $2,
  updateAttributes: () => B2,
  wrapIn: () => z2,
  wrapInList: () => H2
});
var Iw = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
  var t;
  n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) == null || t.removeAllRanges());
}), !0), Pw = (n = !0) => ({ commands: e }) => e.setContent("", { emitUpdate: n }), Dw = () => ({ state: n, tr: e, dispatch: t }) => {
  const { selection: i } = e, { ranges: r } = i;
  return t && r.forEach(({ $from: s, $to: o }) => {
    n.doc.nodesBetween(s.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const p = Ur(h);
      if (a.type.isTextblock) {
        const { defaultType: b } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(h.start, b);
      }
      (p || p === 0) && e.lift(h, p);
    });
  }), !0;
}, $w = (n) => (e) => n(e), Bw = () => ({ state: n, dispatch: e }) => wg(n, e), zw = (n, e) => ({ editor: t, tr: i }) => {
  const { state: r } = t, s = r.doc.slice(n.from, n.to);
  i.deleteRange(n.from, n.to);
  const o = i.mapping.map(e);
  return i.insert(o, s.content), i.setSelection(new ue(i.doc.resolve(Math.max(o - 1, 0)))), !0;
}, Hw = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, i = t.$anchor.node();
  if (i.content.size > 0)
    return !1;
  const r = n.selection.$anchor;
  for (let s = r.depth; s > 0; s -= 1)
    if (r.node(s).type === i.type) {
      if (e) {
        const a = r.before(s), l = r.after(s);
        n.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, Fw = (n) => ({ tr: e, state: t, dispatch: i }) => {
  const r = nt(n, t.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === r) {
      if (i) {
        const l = s.before(o), c = s.after(o);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, Vw = (n) => ({ tr: e, dispatch: t }) => {
  const { from: i, to: r } = n;
  return t && e.delete(i, r), !0;
}, jw = () => ({ state: n, dispatch: e }) => qu(n, e), Ww = () => ({ commands: n }) => n.keyboardShortcut("Enter"), Uw = () => ({ state: n, dispatch: e }) => ow(n, e), Kw = (n, e = {}) => ({ tr: t, state: i, dispatch: r }) => {
  const s = Fn(n, i.schema), { doc: o, selection: a } = t, { $from: l, from: c, to: u } = a;
  if (r) {
    const d = pl(l, s, e);
    if (d && d.from <= c && d.to >= u) {
      const f = ue.create(o, d.from, d.to);
      t.setSelection(f);
    }
  }
  return !0;
}, qw = (n) => (e) => {
  const t = typeof n == "function" ? n(e) : n;
  for (let i = 0; i < t.length; i += 1)
    if (t[i](e))
      return !0;
  return !1;
};
function bl() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Kr() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var Gw = (n = null, e = {}) => ({ editor: t, view: i, tr: r, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    (Kr() || bl()) && i.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (i.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (i.hasFocus() && n === null || n === !1)
    return !0;
  if (s && n === null && !cd(t.state.selection))
    return o(), !0;
  const a = ud(r.doc, n) || t.state.selection, l = t.state.selection.eq(a);
  return s && (l || r.setSelection(a), l && r.storedMarks && r.setStoredMarks(r.storedMarks), o()), !0;
}, Jw = (n, e) => (t) => n.every((i, r) => e(i, { ...t, index: r })), Xw = (n, e) => ({ tr: t, commands: i }) => i.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), Yw = (n) => !("type" in n), Zw = (n, e, t) => ({ tr: i, dispatch: r, editor: s }) => {
  var o;
  if (r) {
    t = {
      parseOptions: s.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...t
    };
    let a;
    const { selection: l } = s.state, c = (g) => {
      s.emit("contentError", {
        editor: s,
        error: g,
        disableCollaboration: () => {
          "collaboration" in s.storage && typeof s.storage.collaboration == "object" && s.storage.collaboration && (s.storage.collaboration.isDisabled = !0);
        }
      });
    }, u = {
      preserveWhitespace: "full",
      ...t.parseOptions
    };
    if (!t.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError)
      try {
        Hr(e, s.schema, {
          parseOptions: u,
          errorOnInvalidContent: !0
        });
      } catch (g) {
        c(g);
      }
    try {
      a = Hr(e, s.schema, {
        parseOptions: u,
        errorOnInvalidContent: (o = t.errorOnInvalidContent) != null ? o : s.options.enableContentCheck
      });
    } catch (g) {
      return c(g), !1;
    }
    let { from: d, to: f } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, h = !0, p = !0;
    if ((Yw(a) ? a : [a]).forEach((g) => {
      g.check(), h = h ? g.isText && g.marks.length === 0 : !1, p = p ? g.isBlock : !1;
    }), d === f && p) {
      const { parent: g } = i.doc.resolve(d);
      g.isTextblock && !g.type.spec.code && !g.childCount && (d -= 1, f += 1);
    }
    let m;
    if (h) {
      if (Array.isArray(e))
        m = e.map((g) => g.text || "").join("");
      else if (e instanceof $) {
        let g = "";
        e.forEach((v) => {
          v.text && (g += v.text);
        }), m = g;
      } else typeof e == "object" && e && e.text ? m = e.text : m = e;
      i.insertText(m, d, f);
    } else {
      m = a;
      const g = l.$from.parentOffset === 0, v = l.$from.node().isText || l.$from.node().isTextblock, x = l.$from.node().content.size > 0;
      g && v && x && (d = Math.max(0, d - 1)), i.replaceWith(d, f, m);
    }
    t.updateSelection && Wg(i, i.steps.length - 1, -1), t.applyInputRules && i.setMeta("applyInputRules", { from: d, text: m }), t.applyPasteRules && i.setMeta("applyPasteRules", { from: d, text: m });
  }
  return !0;
}, Qw = () => ({ state: n, dispatch: e }) => iw(n, e), e2 = () => ({ state: n, dispatch: e }) => rw(n, e), t2 = () => ({ state: n, dispatch: e }) => mg(n, e), n2 = () => ({ state: n, dispatch: e }) => vg(n, e), i2 = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const i = nl(n.doc, n.selection.$from.pos, -1);
    return i == null ? !1 : (t.join(i, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, r2 = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const i = nl(n.doc, n.selection.$from.pos, 1);
    return i == null ? !1 : (t.join(i, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, s2 = () => ({ state: n, dispatch: e }) => tw(n, e), o2 = () => ({ state: n, dispatch: e }) => nw(n, e);
function hd() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function a2(n) {
  const e = n.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let i, r, s, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      Kr() || hd() ? o = !0 : r = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return i && (t = `Alt-${t}`), r && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t;
}
var l2 = (n) => ({ editor: e, view: t, tr: i, dispatch: r }) => {
  const s = a2(n).split(/-(?!$)/), o = s.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (c) => c(t, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(i.mapping);
    u && r && i.maybeStep(u);
  }), !0;
}, c2 = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const r = nt(n, t.schema);
  return ti(t, r, e) ? sw(t, i) : !1;
}, u2 = () => ({ state: n, dispatch: e }) => kg(n, e), d2 = (n) => ({ state: e, dispatch: t }) => {
  const i = nt(n, e.schema);
  return _w(i)(e, t);
}, f2 = () => ({ state: n, dispatch: e }) => xg(n, e);
function nu(n, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(n).reduce((i, r) => (t.includes(r) || (i[r] = n[r]), i), {});
}
var h2 = (n, e) => ({ tr: t, state: i, dispatch: r }) => {
  let s = null, o = null;
  const a = oo(
    typeof n == "string" ? n : n.name,
    i.schema
  );
  return a ? (a === "node" && (s = nt(n, i.schema)), a === "mark" && (o = Fn(n, i.schema)), r && t.selection.ranges.forEach((l) => {
    i.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      s && s === c.type && t.setNodeMarkup(u, void 0, nu(c.attrs, e)), o && c.marks.length && c.marks.forEach((d) => {
        o === d.type && t.addMark(u, u + c.nodeSize, o.create(nu(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, p2 = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), m2 = () => ({ tr: n, dispatch: e }) => {
  if (e) {
    const t = new Ut(n.doc);
    n.setSelection(t);
  }
  return !0;
}, g2 = () => ({ state: n, dispatch: e }) => _g(n, e), _2 = () => ({ state: n, dispatch: e }) => yg(n, e), b2 = () => ({ state: n, dispatch: e }) => cw(n, e), v2 = () => ({ state: n, dispatch: e }) => fw(n, e), y2 = () => ({ state: n, dispatch: e }) => dw(n, e), x2 = (n, { errorOnInvalidContent: e, emitUpdate: t = !0, parseOptions: i = {} } = {}) => ({ editor: r, tr: s, dispatch: o, commands: a }) => {
  const { doc: l } = s;
  if (i.preserveWhitespace !== "full") {
    const c = _a(n, r.schema, i, {
      errorOnInvalidContent: e ?? r.options.enableContentCheck
    });
    return o && s.replaceWith(0, l.content.size, c).setMeta("preventUpdate", !t), !0;
  }
  return o && s.setMeta("preventUpdate", !t), a.insertContentAt({ from: 0, to: l.content.size }, n, {
    parseOptions: i,
    errorOnInvalidContent: e ?? r.options.enableContentCheck
  });
};
function w2(n, e, t) {
  var i;
  const { selection: r } = e;
  let s = null;
  if (cd(r) && (s = r.$cursor), s) {
    const a = (i = n.storedMarks) != null ? i : s.marks();
    return !!t.isInSet(a) || !a.some((l) => l.type.excludes(t));
  }
  const { ranges: o } = r;
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1;
    return n.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(t), p = !!t.isInSet(u.marks) || !u.marks.some((b) => b.type.excludes(t));
        c = h && p;
      }
      return !c;
    }), c;
  });
}
var k2 = (n, e = {}) => ({ tr: t, state: i, dispatch: r }) => {
  const { selection: s } = t, { empty: o, ranges: a } = s, l = Fn(n, i.schema);
  if (r)
    if (o) {
      const c = sd(i, l);
      t.addStoredMark(
        l.create({
          ...c,
          ...e
        })
      );
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        i.doc.nodesBetween(u, d, (f, h) => {
          const p = Math.max(h, u), b = Math.min(h + f.nodeSize, d);
          f.marks.find((g) => g.type === l) ? f.marks.forEach((g) => {
            l === g.type && t.addMark(
              p,
              b,
              l.create({
                ...g.attrs,
                ...e
              })
            );
          }) : t.addMark(p, b, l.create(e));
        });
      });
  return w2(i, t, l);
}, S2 = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), C2 = (n, e = {}) => ({ state: t, dispatch: i, chain: r }) => {
  const s = nt(n, t.schema);
  let o;
  return t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs), s.isTextblock ? r().command(({ commands: a }) => ch(s, { ...o, ...e })(t) ? !0 : a.clearNodes()).command(({ state: a }) => ch(s, { ...o, ...e })(a, i)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, T2 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: i } = e, r = $n(n, 0, i.content.size), s = ae.create(i, r);
    e.setSelection(s);
  }
  return !0;
}, E2 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: i } = e, { from: r, to: s } = typeof n == "number" ? { from: n, to: n } : n, o = ue.atStart(i).from, a = ue.atEnd(i).to, l = $n(r, o, a), c = $n(s, o, a), u = ue.create(i, l, c);
    e.setSelection(u);
  }
  return !0;
}, A2 = (n) => ({ state: e, dispatch: t }) => {
  const i = nt(n, e.schema);
  return yw(i)(e, t);
};
function fh(n, e) {
  const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
  if (t) {
    const i = t.filter((r) => e == null ? void 0 : e.includes(r.type.name));
    n.tr.ensureMarks(i);
  }
}
var M2 = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: i, editor: r }) => {
  const { selection: s, doc: o } = e, { $from: a, $to: l } = s, c = r.extensionManager.attributes, u = Cs(c, a.node().type.name, a.node().attrs);
  if (s instanceof ae && s.node.isBlock)
    return !a.parentOffset || !Zn(o, a.pos) ? !1 : (i && (n && fh(t, r.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : Ag(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = Zn(e.doc, e.mapping.map(a.pos), 1, h);
  if (!h && !p && Zn(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), i) {
    if (p && (s instanceof ue && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, h), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const b = e.mapping.map(a.before()), m = e.doc.resolve(b);
      a.node(-1).canReplaceWith(m.index(), m.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    n && fh(t, r.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
}, O2 = (n, e = {}) => ({ tr: t, state: i, dispatch: r, editor: s }) => {
  var o;
  const a = nt(n, i.schema), { $from: l, $to: c } = i.selection, u = i.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = s.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (r) {
      let g = $.empty;
      const v = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let y = l.depth - v; y >= l.depth - 3; y -= 1)
        g = $.from(l.node(y).copy(g));
      const x = (
        // eslint-disable-next-line no-nested-ternary
        l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
      ), w = {
        ...Cs(f, l.node().type.name, l.node().attrs),
        ...e
      }, S = ((o = a.contentMatch.defaultType) == null ? void 0 : o.createAndFill(w)) || void 0;
      g = g.append($.from(a.createAndFill(null, S) || void 0));
      const k = l.before(l.depth - (v - 1));
      t.replace(k, l.after(-x), new Y(g, 4 - v, 0));
      let C = -1;
      t.doc.nodesBetween(k, t.doc.content.size, (y, A) => {
        if (C > -1)
          return !1;
        y.isTextblock && y.content.size === 0 && (C = A + 1);
      }), C > -1 && t.setSelection(ue.near(t.doc.resolve(C))), t.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...Cs(f, d.type.name, d.attrs),
    ...e
  }, b = {
    ...Cs(f, l.node().type.name, l.node().attrs),
    ...e
  };
  t.delete(l.pos, c.pos);
  const m = h ? [
    { type: a, attrs: p },
    { type: h, attrs: b }
  ] : [{ type: a, attrs: p }];
  if (!Zn(t.doc, l.pos, 2))
    return !1;
  if (r) {
    const { selection: g, storedMarks: v } = i, { splittableMarks: x } = s.extensionManager, w = v || g.$to.parentOffset && g.$from.marks();
    if (t.split(l.pos, 2, m).scrollIntoView(), !w || !r)
      return !0;
    const S = w.filter((k) => x.includes(k.type.name));
    t.ensureMarks(S);
  }
  return !0;
}, Gl = (n, e) => {
  const t = Zi((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const i = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (i === void 0)
    return !0;
  const r = n.doc.nodeAt(i);
  return t.node.type === (r == null ? void 0 : r.type) && Si(n.doc, t.pos) && n.join(t.pos), !0;
}, Jl = (n, e) => {
  const t = Zi((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const i = n.doc.resolve(t.start).after(t.depth);
  if (i === void 0)
    return !0;
  const r = n.doc.nodeAt(i);
  return t.node.type === (r == null ? void 0 : r.type) && Si(n.doc, i) && n.join(i), !0;
}, N2 = (n, e, t, i = {}) => ({ editor: r, tr: s, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = r.extensionManager, h = nt(n, o.schema), p = nt(e, o.schema), { selection: b, storedMarks: m } = o, { $from: g, $to: v } = b, x = g.blockRange(v), w = m || b.$to.parentOffset && b.$from.marks();
  if (!x)
    return !1;
  const S = Zi((k) => tu(k.type.name, d))(b);
  if (x.depth >= 1 && S && x.depth - S.depth <= 1) {
    if (S.node.type === h)
      return c.liftListItem(p);
    if (tu(S.node.type.name, d) && h.validContent(S.node.content) && a)
      return l().command(() => (s.setNodeMarkup(S.pos, h), !0)).command(() => Gl(s, h)).command(() => Jl(s, h)).run();
  }
  return !t || !w || !a ? l().command(() => u().wrapInList(h, i) ? !0 : c.clearNodes()).wrapInList(h, i).command(() => Gl(s, h)).command(() => Jl(s, h)).run() : l().command(() => {
    const k = u().wrapInList(h, i), C = w.filter((y) => f.includes(y.type.name));
    return s.ensureMarks(C), k ? !0 : c.clearNodes();
  }).wrapInList(h, i).command(() => Gl(s, h)).command(() => Jl(s, h)).run();
}, L2 = (n, e = {}, t = {}) => ({ state: i, commands: r }) => {
  const { extendEmptyMarkRange: s = !1 } = t, o = Fn(n, i.schema);
  return ba(i, o, e) ? r.unsetMark(o, { extendEmptyMarkRange: s }) : r.setMark(o, e);
}, R2 = (n, e, t = {}) => ({ state: i, commands: r }) => {
  const s = nt(n, i.schema), o = nt(e, i.schema), a = ti(i, s, t);
  let l;
  return i.selection.$anchor.sameParent(i.selection.$head) && (l = i.selection.$anchor.parent.attrs), a ? r.setNode(o, l) : r.setNode(s, { ...l, ...t });
}, I2 = (n, e = {}) => ({ state: t, commands: i }) => {
  const r = nt(n, t.schema);
  return ti(t, r, e) ? i.lift(r) : i.wrapIn(r, e);
}, P2 = () => ({ state: n, dispatch: e }) => {
  const t = n.plugins;
  for (let i = 0; i < t.length; i += 1) {
    const r = t[i];
    let s;
    if (r.spec.isInputRules && (s = r.getState(n))) {
      if (e) {
        const o = n.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, D2 = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, { empty: i, ranges: r } = t;
  return i || e && r.forEach((s) => {
    n.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, $2 = (n, e = {}) => ({ tr: t, state: i, dispatch: r }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: a } = t, l = Fn(n, i.schema), { $from: c, empty: u, ranges: d } = a;
  if (!r)
    return !0;
  if (u && o) {
    let { from: f, to: h } = a;
    const p = (s = c.marks().find((m) => m.type === l)) == null ? void 0 : s.attrs, b = pl(c, l, p);
    b && (f = b.from, h = b.to), t.removeMark(f, h, l);
  } else
    d.forEach((f) => {
      t.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return t.removeStoredMark(l), !0;
}, B2 = (n, e = {}) => ({ tr: t, state: i, dispatch: r }) => {
  let s = null, o = null;
  const a = oo(
    typeof n == "string" ? n : n.name,
    i.schema
  );
  return a ? (a === "node" && (s = nt(n, i.schema)), a === "mark" && (o = Fn(n, i.schema)), r && t.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    let d, f, h, p;
    t.selection.empty ? i.doc.nodesBetween(c, u, (b, m) => {
      s && s === b.type && (h = Math.max(m, c), p = Math.min(m + b.nodeSize, u), d = m, f = b);
    }) : i.doc.nodesBetween(c, u, (b, m) => {
      m < c && s && s === b.type && (h = Math.max(m, c), p = Math.min(m + b.nodeSize, u), d = m, f = b), m >= c && m <= u && (s && s === b.type && t.setNodeMarkup(m, void 0, {
        ...b.attrs,
        ...e
      }), o && b.marks.length && b.marks.forEach((g) => {
        if (o === g.type) {
          const v = Math.max(m, c), x = Math.min(m + b.nodeSize, u);
          t.addMark(
            v,
            x,
            o.create({
              ...g.attrs,
              ...e
            })
          );
        }
      }));
    }), f && (d !== void 0 && t.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), o && f.marks.length && f.marks.forEach((b) => {
      o === b.type && t.addMark(
        h,
        p,
        o.create({
          ...b.attrs,
          ...e
        })
      );
    }));
  }), !0) : !1;
}, z2 = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const r = nt(n, t.schema);
  return hw(r, e)(t, i);
}, H2 = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const r = nt(n, t.schema);
  return pw(r, e)(t, i);
}, Qg = ze.create({
  name: "commands",
  addCommands() {
    return {
      ...Zg
    };
  }
}), e_ = ze.create({
  name: "delete",
  onUpdate({ transaction: n, appendedTransactions: e }) {
    var t, i, r;
    const s = () => {
      var o, a, l, c;
      if ((c = (l = (a = (o = this.editor.options.coreExtensionOptions) == null ? void 0 : o.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : l.call(a, n)) != null ? c : n.getMeta("y-sync$"))
        return;
      const u = Zu(n.before, [n, ...e]);
      ad(u).forEach((h) => {
        u.mapping.mapResult(h.oldRange.from).deletedAfter && u.mapping.mapResult(h.oldRange.to).deletedBefore && u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (p, b) => {
          const m = b + p.nodeSize - 2, g = h.oldRange.from <= b && m <= h.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: p,
            from: b,
            to: m,
            newFrom: u.mapping.map(b),
            newTo: u.mapping.map(m),
            deletedRange: h.oldRange,
            newRange: h.newRange,
            partial: !g,
            editor: this.editor,
            transaction: n,
            combinedTransform: u
          });
        });
      });
      const f = u.mapping;
      u.steps.forEach((h, p) => {
        var b, m;
        if (h instanceof wn) {
          const g = f.slice(p).map(h.from, -1), v = f.slice(p).map(h.to), x = f.invert().map(g, -1), w = f.invert().map(v), S = (b = u.doc.nodeAt(g - 1)) == null ? void 0 : b.marks.some((C) => C.eq(h.mark)), k = (m = u.doc.nodeAt(v)) == null ? void 0 : m.marks.some((C) => C.eq(h.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: h.mark,
            from: h.from,
            to: h.to,
            deletedRange: {
              from: x,
              to: w
            },
            newRange: {
              from: g,
              to: v
            },
            partial: !!(k || S),
            editor: this.editor,
            transaction: n,
            combinedTransform: u
          });
        }
      });
    };
    (r = (i = (t = this.editor.options.coreExtensionOptions) == null ? void 0 : t.delete) == null ? void 0 : i.async) == null || r ? setTimeout(s, 0) : s();
  }
}), t_ = ze.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("tiptapDrop"),
        props: {
          handleDrop: (n, e, t, i) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: t,
              moved: i
            });
          }
        }
      })
    ];
  }
}), n_ = ze.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), i_ = new lt("focusEvents"), r_ = ze.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new Ge({
        key: i_,
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              n.isFocused = !0;
              const i = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            },
            blur: (e, t) => {
              n.isFocused = !1;
              const i = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            }
          }
        }
      })
    ];
  }
}), s_ = ze.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, b = p.parent.type.spec.isolating, m = d.pos - d.parentOffset, g = b && p.parent.childCount === 1 ? m === d.pos : pe.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !g || g && d.parent.type.name === "paragraph" ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), i = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: n,
      "Mod-Backspace": n,
      "Shift-Backspace": n,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, r = {
      ...i
    }, s = {
      ...i,
      "Ctrl-h": n,
      "Alt-Backspace": n,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Kr() || hd() ? s : r;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Ge({
        key: new lt("clearDocument"),
        appendTransaction: (n, e, t) => {
          if (n.some((b) => b.getMeta("composition")))
            return;
          const i = n.some((b) => b.docChanged) && !e.doc.eq(t.doc), r = n.some((b) => b.getMeta("preventClearDocument"));
          if (!i || r)
            return;
          const { empty: s, from: o, to: a } = e.selection, l = pe.atStart(e.doc).from, c = pe.atEnd(e.doc).to;
          if (s || !(o === l && a === c) || !ao(t.doc))
            return;
          const f = t.tr, h = io({
            state: t,
            transaction: f
          }), { commands: p } = new ro({
            editor: this.editor,
            state: h
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), o_ = ze.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("tiptapPaste"),
        props: {
          handlePaste: (n, e, t) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: t
            });
          }
        }
      })
    ];
  }
}), a_ = ze.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), l_ = class dr {
  constructor(e, t, i = !1, r = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = i, this.resolvedPos = e, this.editor = t, this.currentNode = r;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) != null ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let t = this.from, i = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      t = this.from + 1, i = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: t, to: i }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
    return new dr(t, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new dr(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new dr(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((t, i) => {
      const r = t.isBlock && !t.isTextblock, s = t.isAtom && !t.isText, o = this.pos + i + (s ? 0 : 1);
      if (o < 0 || o > this.resolvedPos.doc.nodeSize - 2)
        return;
      const a = this.resolvedPos.doc.resolve(o);
      if (!r && a.depth <= this.depth)
        return;
      const l = new dr(a, this.editor, r, r ? t : null);
      r && (l.actualDepth = this.depth + 1), e.push(new dr(a, this.editor, r, r ? t : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, t = {}) {
    let i = null, r = this.parent;
    for (; r && !i; ) {
      if (r.node.type.name === e)
        if (Object.keys(t).length > 0) {
          const s = r.node.attrs, o = Object.keys(t);
          for (let a = 0; a < o.length; a += 1) {
            const l = o[a];
            if (s[l] !== t[l])
              break;
          }
        } else
          i = r;
      r = r.parent;
    }
    return i;
  }
  querySelector(e, t = {}) {
    return this.querySelectorAll(e, t, !0)[0] || null;
  }
  querySelectorAll(e, t = {}, i = !1) {
    let r = [];
    if (!this.children || this.children.length === 0)
      return r;
    const s = Object.keys(t);
    return this.children.forEach((o) => {
      i && r.length > 0 || (o.node.type.name === e && s.every((l) => t[l] === o.node.attrs[l]) && r.push(o), !(i && r.length > 0) && (r = r.concat(o.querySelectorAll(e, t, i))));
    }), r;
  }
  setAttribute(e) {
    const { tr: t } = this.editor.state;
    t.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(t);
  }
}, F2 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function c_(n, e, t) {
  const i = document.querySelector(`style[data-tiptap-style${t ? `-${t}` : ""}]`);
  if (i !== null)
    return i;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute(`data-tiptap-style${t ? `-${t}` : ""}`, ""), r.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(r), r;
}
var u_ = class extends ww {
  constructor(e = {}) {
    super(), this.css = null, this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: s, moved: o }) => this.options.onDrop(r, s, o)), this.on("paste", ({ event: r, slice: s }) => this.options.onPaste(r, s)), this.on("delete", this.options.onDelete);
    const t = this.createDoc(), i = ud(t, this.options.autofocus);
    this.editorState = hr.create({
      doc: t,
      schema: this.schema,
      selection: i || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(e) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(e), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    var e;
    if (this.editorView) {
      const t = this.editorView.dom;
      t != null && t.editor && delete t.editor, this.editorView.destroy();
    }
    this.editorView = null, this.isInitialized = !1, (e = this.css) == null || e.remove(), this.css = null;
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = c_(F2, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (e) => {
          this.editorState = e;
        },
        dispatch: (e) => {
          this.editorState = this.state.apply(e);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (e, t) => {
          if (t === "state")
            return this.editorState;
          if (t in e)
            return Reflect.get(e, t);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${t}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const i = ed(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: i });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let i = t;
    if ([].concat(e).forEach((s) => {
      const o = typeof s == "string" ? `${s}$` : s.key;
      i = i.filter((a) => !a.key.startsWith(o));
    }), t.length === i.length)
      return;
    const r = this.state.reconfigure({
      plugins: i
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const r = [...this.options.enableCoreExtensions ? [
      n_,
      Yg.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : t.blockSeparator
      }),
      Qg,
      r_,
      s_,
      a_,
      t_,
      o_,
      e_
    ].filter((s) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter((s) => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
    this.extensionManager = new _l(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new ro({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let e;
    try {
      e = _a(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (t) {
      if (!(t instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(t.message))
        throw t;
      this.emit("contentError", {
        editor: this,
        error: t,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((i) => i.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = _a(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return e;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(e) {
    var t;
    this.editorView = new Ux(e, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(t = this.options.editorProps) == null ? void 0 : t.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass(), this.injectCSS();
    const r = this.view.dom;
    r.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((u) => {
        var d;
        return (d = this.capturedTransaction) == null ? void 0 : d.step(u);
      });
      return;
    }
    const { state: t, transactions: i } = this.state.applyTransaction(e), r = !this.state.selection.eq(t.selection), s = i.includes(e), o = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), !s)
      return;
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e,
      appendedTransactions: i.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const a = i.findLast((u) => u.getMeta("focus") || u.getMeta("blur")), l = a == null ? void 0 : a.getMeta("focus"), c = a == null ? void 0 : a.getMeta("blur");
    l && this.emit("focus", {
      editor: this,
      event: l.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: a
    }), c && this.emit("blur", {
      editor: this,
      event: c.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: a
    }), !(e.getMeta("preventUpdate") || !i.some((u) => u.docChanged) || o.doc.eq(t.doc)) && this.emit("update", {
      editor: this,
      transaction: e,
      appendedTransactions: i.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return od(this.state, e);
  }
  isActive(e, t) {
    const i = typeof e == "string" ? e : null, r = typeof e == "string" ? t : e;
    return Hg(this.state, i, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return so(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: i = {} } = e || {};
    return rd(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...fl(this.schema),
        ...i
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return ao(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e, t;
    return (t = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? t : !0;
  }
  $node(e, t) {
    var i;
    return ((i = this.$doc) == null ? void 0 : i.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var i;
    return ((i = this.$doc) == null ? void 0 : i.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new l_(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Vr(n) {
  return new Qi({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const r = Me(n.getAttributes, void 0, i);
      if (r === !1 || r === null)
        return null;
      const { tr: s } = e, o = i[i.length - 1], a = i[0];
      if (o) {
        const l = a.search(/\S/), c = t.from + a.indexOf(o), u = c + o.length;
        if (ml(t.from, t.to, e.doc).filter((h) => h.mark.type.excluded.find((b) => b === n.type && b !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        u < t.to && s.delete(u, t.to), c > t.from && s.delete(t.from + l, c);
        const f = t.from + l + o.length;
        s.addMark(t.from + l, f, n.type.create(r || {})), s.removeStoredMark(n.type);
      }
    }
  });
}
function pd(n) {
  return new Qi({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const r = Me(n.getAttributes, void 0, i) || {}, { tr: s } = e, o = t.from;
      let a = t.to;
      const l = n.type.create(r);
      if (i[1]) {
        const c = i[0].lastIndexOf(i[1]);
        let u = o + c;
        u > a ? u = a : a = u + i[1].length;
        const d = i[0][i[0].length - 1];
        s.insertText(d, o + i[0].length - 1), s.replaceWith(u, a, l);
      } else if (i[0]) {
        const c = n.type.isInline ? o : o - 1;
        s.insert(c, n.type.create(r)).delete(s.mapping.map(o), s.mapping.map(a));
      }
      s.scrollIntoView();
    }
  });
}
function d_(n) {
  return new Qi({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const r = e.doc.resolve(t.from), s = Me(n.getAttributes, void 0, i) || {};
      if (!r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), n.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, s);
    }
  });
}
function V2(n) {
  return new Qi({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      let r = n.replace, s = t.from;
      const o = t.to;
      if (i[1]) {
        const a = i[0].lastIndexOf(i[1]);
        r += i[0].slice(a + i[1].length), s += a;
        const l = s - o;
        l > 0 && (r = i[0].slice(a - l, a) + r, s = o);
      }
      e.tr.insertText(r, s, o);
    }
  });
}
function Gi(n) {
  return new Qi({
    find: n.find,
    handler: ({ state: e, range: t, match: i, chain: r }) => {
      const s = Me(n.getAttributes, void 0, i) || {}, o = e.tr.delete(t.from, t.to), l = o.doc.resolve(t.from).blockRange(), c = l && Iu(l, n.type, s);
      if (!c)
        return null;
      if (o.wrap(l, c), n.keepMarks && n.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: h } = n.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const b = p.filter((m) => h.includes(m.type.name));
          o.ensureMarks(b);
        }
      }
      if (n.keepAttributes) {
        const d = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList";
        r().updateAttributes(d, s).run();
      }
      const u = o.doc.resolve(t.from - 1).nodeBefore;
      u && u.type === n.type && Si(o.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(i, u)) && o.join(t.from - 1);
    }
  });
}
function j2(n) {
  return n.children;
}
var hh = (n, e) => {
  if (n === "slot")
    return 0;
  if (n instanceof Function)
    return n(e);
  const { children: t, ...i } = e ?? {};
  if (n === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [n, i, t];
};
function f_(n, e) {
  const { selection: t } = n, { $from: i } = t;
  if (t instanceof ae) {
    const s = i.index();
    return i.parent.canReplaceWith(s, s + 1, e);
  }
  let r = i.depth;
  for (; r >= 0; ) {
    const s = i.index(r);
    if (i.node(r).contentMatchAt(s).matchType(e))
      return !0;
    r -= 1;
  }
  return !1;
}
function W2(n) {
  return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function U2(n) {
  return typeof n == "string";
}
function md(n, e, t = {}) {
  const { state: i } = e, { doc: r, tr: s } = i, o = n;
  r.descendants((a, l) => {
    const c = s.mapping.map(l), u = s.mapping.map(l) + a.nodeSize;
    let d = null;
    if (a.marks.forEach((h) => {
      if (h !== o)
        return !1;
      d = h;
    }), !d)
      return;
    let f = !1;
    if (Object.keys(t).forEach((h) => {
      t[h] !== d.attrs[h] && (f = !0);
    }), f) {
      const h = n.type.create({
        ...n.attrs,
        ...t
      });
      s.removeMark(c, u, n.type), s.addMark(c, u, h);
    }
  }), s.docChanged && e.view.dispatch(s);
}
var K2 = class {
  constructor(n, e, t) {
    this.component = n, this.editor = e.editor, this.options = { ...t }, this.mark = e.mark, this.HTMLAttributes = e.HTMLAttributes;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  /**
   * Update the attributes of the mark in the document.
   * @param attrs The attributes to update.
   */
  updateAttributes(n, e) {
    md(e || this.mark, this.editor, n);
  }
  ignoreMutation(n) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: n }) : n.type === "selection" || this.dom.contains(n.target) && n.type === "childList" && (Kr() || bl()) && this.editor.isFocused && [...Array.from(n.addedNodes), ...Array.from(n.removedNodes)].every((t) => t.isContentEditable) ? !1 : this.contentDOM === n.target && n.type === "attributes" ? !0 : !this.contentDOM.contains(n.target);
  }
}, Ie = class h_ extends fd {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new h_(t);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
}, q2 = class {
  constructor(n, e, t) {
    this.isDragging = !1, this.component = n, this.editor = e.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...t
    }, this.extension = e.extension, this.node = e.node, this.decorations = e.decorations, this.innerDecorations = e.innerDecorations, this.view = e.view, this.HTMLAttributes = e.HTMLAttributes, this.getPos = e.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(n) {
    var e, t, i, r, s, o, a;
    const { view: l } = this.editor, c = n.target, u = c.nodeType === 3 ? (e = c.parentElement) == null ? void 0 : e.closest("[data-drag-handle]") : c.closest("[data-drag-handle]");
    if (!this.dom || (t = this.contentDOM) != null && t.contains(c) || !u)
      return;
    let d = 0, f = 0;
    if (this.dom !== u) {
      const g = this.dom.getBoundingClientRect(), v = u.getBoundingClientRect(), x = (r = n.offsetX) != null ? r : (i = n.nativeEvent) == null ? void 0 : i.offsetX, w = (o = n.offsetY) != null ? o : (s = n.nativeEvent) == null ? void 0 : s.offsetY;
      d = v.x - g.x + x, f = v.y - g.y + w;
    }
    const h = this.dom.cloneNode(!0);
    (a = n.dataTransfer) == null || a.setDragImage(h, d, f);
    const p = this.getPos();
    if (typeof p != "number")
      return;
    const b = ae.create(l.state.doc, p), m = l.state.tr.setSelection(b);
    l.dispatch(m);
  }
  stopEvent(n) {
    var e;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: n });
    const t = n.target;
    if (!(this.dom.contains(t) && !((e = this.contentDOM) != null && e.contains(t))))
      return !1;
    const r = n.type.startsWith("drag"), s = n.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(t.tagName) || t.isContentEditable) && !s && !r)
      return !0;
    const { isEditable: a } = this.editor, { isDragging: l } = this, c = !!this.node.type.spec.draggable, u = ae.isSelectable(this.node), d = n.type === "copy", f = n.type === "paste", h = n.type === "cut", p = n.type === "mousedown";
    if (!c && u && r && n.target === this.dom && n.preventDefault(), c && r && !l && n.target === this.dom)
      return n.preventDefault(), !1;
    if (c && a && !l && p) {
      const b = t.closest("[data-drag-handle]");
      b && (this.dom === b || this.dom.contains(b)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(l || s || d || f || h || p && u);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(n) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: n }) : this.node.isLeaf || this.node.isAtom ? !0 : n.type === "selection" || this.dom.contains(n.target) && n.type === "childList" && (Kr() || bl()) && this.editor.isFocused && [...Array.from(n.addedNodes), ...Array.from(n.removedNodes)].every((t) => t.isContentEditable) ? !1 : this.contentDOM === n.target && n.type === "attributes" ? !0 : !this.contentDOM.contains(n.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(n) {
    this.editor.commands.command(({ tr: e }) => {
      const t = this.getPos();
      return typeof t != "number" ? !1 : (e.setNodeMarkup(t, void 0, {
        ...this.node.attrs,
        ...n
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const n = this.getPos();
    if (typeof n != "number")
      return;
    const e = n + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: n, to: e });
  }
};
function Ji(n) {
  return new gl({
    find: n.find,
    handler: ({ state: e, range: t, match: i, pasteEvent: r }) => {
      const s = Me(n.getAttributes, void 0, i, r);
      if (s === !1 || s === null)
        return null;
      const { tr: o } = e, a = i[i.length - 1], l = i[0];
      let c = t.to;
      if (a) {
        const u = l.search(/\S/), d = t.from + l.indexOf(a), f = d + a.length;
        if (ml(t.from, t.to, e.doc).filter((p) => p.mark.type.excluded.find((m) => m === n.type && m !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        f < t.to && o.delete(f, t.to), d > t.from && o.delete(t.from + u, d), c = t.from + u + a.length, o.addMark(t.from + u, c, n.type.create(s || {})), o.removeStoredMark(n.type);
      }
    }
  });
}
function G2(n) {
  return new gl({
    find: n.find,
    handler({ match: e, chain: t, range: i, pasteEvent: r }) {
      const s = Me(n.getAttributes, void 0, e, r), o = Me(n.getContent, void 0, s);
      if (s === !1 || s === null)
        return null;
      const a = { type: n.type.name, attrs: s };
      o && (a.content = o), e.input && t().deleteRange(i).insertContentAt(i.from, a);
    }
  });
}
function J2(n) {
  return new gl({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      let r = n.replace, s = t.from;
      const o = t.to;
      if (i[1]) {
        const a = i[0].lastIndexOf(i[1]);
        r += i[0].slice(a + i[1].length), s += a;
        const l = s - o;
        l > 0 && (r = i[0].slice(a - l, a) + r, s = o);
      }
      e.tr.insertText(r, s, o);
    }
  });
}
var X2 = class {
  constructor(n) {
    this.transaction = n, this.currentStep = this.transaction.steps.length;
  }
  map(n) {
    let e = !1;
    return {
      position: this.transaction.steps.slice(this.currentStep).reduce((i, r) => {
        const s = r.getMap().mapResult(i);
        return s.deleted && (e = !0), s.pos;
      }, n),
      deleted: e
    };
  }
};
const Y2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CommandManager: ro,
  Editor: u_,
  Extension: ze,
  Fragment: j2,
  InputRule: Qi,
  Mark: Qt,
  MarkView: K2,
  Node: Ie,
  NodePos: l_,
  NodeView: q2,
  PasteRule: gl,
  Tracker: X2,
  callOrReturn: Me,
  canInsertNode: f_,
  combineTransactionSteps: Zu,
  createChainableState: io,
  createDocument: _a,
  createElement: hh,
  createNodeFromContent: Hr,
  createStyleTag: c_,
  defaultBlockAt: Ag,
  deleteProps: nu,
  elementFromString: pr,
  escapeForRegEx: W2,
  extensions: Jg,
  findChildren: kw,
  findChildrenInRange: Mg,
  findDuplicates: Lg,
  findParentNode: Zi,
  findParentNodeClosestToPos: Qu,
  flattenExtensions: ll,
  fromString: Ng,
  generateHTML: Sw,
  generateJSON: Rg,
  generateText: Cw,
  getAttributes: od,
  getAttributesFromExtensions: td,
  getChangedRanges: ad,
  getDebugJSON: Dg,
  getExtensionField: oe,
  getHTMLFromFragment: so,
  getMarkAttributes: sd,
  getMarkRange: pl,
  getMarkType: Fn,
  getMarksBetween: ml,
  getNodeAtPosition: Bg,
  getNodeAttributes: Ig,
  getNodeType: nt,
  getRenderedAttributes: Vs,
  getSchema: dl,
  getSchemaByResolvedExtensions: nd,
  getSchemaTypeByName: qo,
  getSchemaTypeNameByName: oo,
  getSplittedAttributes: Cs,
  getText: rd,
  getTextBetween: id,
  getTextContentFromNodes: zg,
  getTextSerializersFromSchema: fl,
  h: hh,
  injectExtensionAttributesToParseRule: Qc,
  inputRulesPlugin: Ug,
  isActive: Hg,
  isAndroid: bl,
  isAtEndOfNode: Fg,
  isAtStartOfNode: Vg,
  isEmptyObject: Og,
  isExtensionRulesEnabled: eu,
  isFunction: ed,
  isList: tu,
  isMacOS: hd,
  isMarkActive: ba,
  isNodeActive: ti,
  isNodeEmpty: ao,
  isNodeSelection: ld,
  isNumber: qg,
  isPlainObject: _s,
  isRegExp: hl,
  isString: U2,
  isTextSelection: cd,
  isiOS: Kr,
  markInputRule: Vr,
  markPasteRule: Ji,
  mergeAttributes: Te,
  mergeDeep: dd,
  minMax: $n,
  nodeInputRule: pd,
  nodePasteRule: G2,
  objectIncludes: js,
  pasteRulesPlugin: Gg,
  posToDOMRect: Ew,
  removeDuplicates: Pg,
  resolveExtensions: ul,
  resolveFocusPosition: ud,
  rewriteUnknownContent: Aw,
  selectionToInsertionEnd: Wg,
  sortExtensions: cl,
  splitExtensions: Fr,
  textInputRule: V2,
  textPasteRule: J2,
  textblockTypeInputRule: d_,
  updateMarkViewAttributes: md,
  wrappingInputRule: Gi
}, Symbol.toStringTag, { value: "Module" }));
var ph = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Z2(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Xl = { exports: {} }, is = {}, Co = { exports: {} }, Yl = {}, Zl = {}, mh;
function gd() {
  if (mh) return Zl;
  mh = 1;
  function n(i) {
    this.__parent = i, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
  }
  n.prototype.clone_empty = function() {
    var i = new n(this.__parent);
    return i.set_indent(this.__indent_count, this.__alignment_count), i;
  }, n.prototype.item = function(i) {
    return i < 0 ? this.__items[this.__items.length + i] : this.__items[i];
  }, n.prototype.has_match = function(i) {
    for (var r = this.__items.length - 1; r >= 0; r--)
      if (this.__items[r].match(i))
        return !0;
    return !1;
  }, n.prototype.set_indent = function(i, r) {
    this.is_empty() && (this.__indent_count = i || 0, this.__alignment_count = r || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
  }, n.prototype._set_wrap_point = function() {
    this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
  }, n.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  }, n.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var i = this.__parent.current_line;
      return i.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), i.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), i.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, i.__items[0] === " " && (i.__items.splice(0, 1), i.__character_count -= 1), !0;
    }
    return !1;
  }, n.prototype.is_empty = function() {
    return this.__items.length === 0;
  }, n.prototype.last = function() {
    return this.is_empty() ? null : this.__items[this.__items.length - 1];
  }, n.prototype.push = function(i) {
    this.__items.push(i);
    var r = i.lastIndexOf(`
`);
    r !== -1 ? this.__character_count = i.length - r : this.__character_count += i.length;
  }, n.prototype.pop = function() {
    var i = null;
    return this.is_empty() || (i = this.__items.pop(), this.__character_count -= i.length), i;
  }, n.prototype._remove_indent = function() {
    this.__indent_count > 0 && (this.__indent_count -= 1, this.__character_count -= this.__parent.indent_size);
  }, n.prototype._remove_wrap_indent = function() {
    this.__wrap_point_indent_count > 0 && (this.__wrap_point_indent_count -= 1);
  }, n.prototype.trim = function() {
    for (; this.last() === " "; )
      this.__items.pop(), this.__character_count -= 1;
  }, n.prototype.toString = function() {
    var i = "";
    return this.is_empty() ? this.__parent.indent_empty_lines && (i = this.__parent.get_indent_string(this.__indent_count)) : (i = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), i += this.__items.join("")), i;
  };
  function e(i, r) {
    this.__cache = [""], this.__indent_size = i.indent_size, this.__indent_string = i.indent_char, i.indent_with_tabs || (this.__indent_string = new Array(i.indent_size + 1).join(i.indent_char)), r = r || "", i.indent_level > 0 && (r = new Array(i.indent_level + 1).join(this.__indent_string)), this.__base_string = r, this.__base_string_length = r.length;
  }
  e.prototype.get_indent_size = function(i, r) {
    var s = this.__base_string_length;
    return r = r || 0, i < 0 && (s = 0), s += i * this.__indent_size, s += r, s;
  }, e.prototype.get_indent_string = function(i, r) {
    var s = this.__base_string;
    return r = r || 0, i < 0 && (i = 0, s = ""), r += i * this.__indent_size, this.__ensure_cache(r), s += this.__cache[r], s;
  }, e.prototype.__ensure_cache = function(i) {
    for (; i >= this.__cache.length; )
      this.__add_column();
  }, e.prototype.__add_column = function() {
    var i = this.__cache.length, r = 0, s = "";
    this.__indent_size && i >= this.__indent_size && (r = Math.floor(i / this.__indent_size), i -= r * this.__indent_size, s = new Array(r + 1).join(this.__indent_string)), i && (s += new Array(i + 1).join(" ")), this.__cache.push(s);
  };
  function t(i, r) {
    this.__indent_cache = new e(i, r), this.raw = !1, this._end_with_newline = i.end_with_newline, this.indent_size = i.indent_size, this.wrap_line_length = i.wrap_line_length, this.indent_empty_lines = i.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new n(this), this.space_before_token = !1, this.non_breaking_space = !1, this.previous_token_wrapped = !1, this.__add_outputline();
  }
  return t.prototype.__add_outputline = function() {
    this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
  }, t.prototype.get_line_number = function() {
    return this.__lines.length;
  }, t.prototype.get_indent_string = function(i, r) {
    return this.__indent_cache.get_indent_string(i, r);
  }, t.prototype.get_indent_size = function(i, r) {
    return this.__indent_cache.get_indent_size(i, r);
  }, t.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  }, t.prototype.add_new_line = function(i) {
    return this.is_empty() || !i && this.just_added_newline() ? !1 : (this.raw || this.__add_outputline(), !0);
  }, t.prototype.get_code = function(i) {
    this.trim(!0);
    var r = this.current_line.pop();
    r && (r[r.length - 1] === `
` && (r = r.replace(/\n+$/g, "")), this.current_line.push(r)), this._end_with_newline && this.__add_outputline();
    var s = this.__lines.join(`
`);
    return i !== `
` && (s = s.replace(/[\n]/g, i)), s;
  }, t.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  }, t.prototype.set_indent = function(i, r) {
    return i = i || 0, r = r || 0, this.next_line.set_indent(i, r), this.__lines.length > 1 ? (this.current_line.set_indent(i, r), !0) : (this.current_line.set_indent(), !1);
  }, t.prototype.add_raw_token = function(i) {
    for (var r = 0; r < i.newlines; r++)
      this.__add_outputline();
    this.current_line.set_indent(-1), this.current_line.push(i.whitespace_before), this.current_line.push(i.text), this.space_before_token = !1, this.non_breaking_space = !1, this.previous_token_wrapped = !1;
  }, t.prototype.add_token = function(i) {
    this.__add_space_before_token(), this.current_line.push(i), this.space_before_token = !1, this.non_breaking_space = !1, this.previous_token_wrapped = this.current_line._allow_wrap();
  }, t.prototype.__add_space_before_token = function() {
    this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
  }, t.prototype.remove_indent = function(i) {
    for (var r = this.__lines.length; i < r; )
      this.__lines[i]._remove_indent(), i++;
    this.current_line._remove_wrap_indent();
  }, t.prototype.trim = function(i) {
    for (i = i === void 0 ? !1 : i, this.current_line.trim(); i && this.__lines.length > 1 && this.current_line.is_empty(); )
      this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  }, t.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  }, t.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  }, t.prototype.ensure_empty_line_above = function(i, r) {
    for (var s = this.__lines.length - 2; s >= 0; ) {
      var o = this.__lines[s];
      if (o.is_empty())
        break;
      if (o.item(0).indexOf(i) !== 0 && o.item(-1) !== r) {
        this.__lines.splice(s + 1, 0, new n(this)), this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      s--;
    }
  }, Zl.Output = t, Zl;
}
var Ql = {}, gh;
function p_() {
  if (gh) return Ql;
  gh = 1;
  function n(e, t, i, r) {
    this.type = e, this.text = t, this.comments_before = null, this.newlines = i || 0, this.whitespace_before = r || "", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this.directives = null;
  }
  return Ql.Token = n, Ql;
}
var ec = {}, _h;
function m_() {
  return _h || (_h = 1, function(n) {
    var e = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a", t = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a", i = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc", r = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f", s = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}", o = "(?:" + s + "|[" + e + i + "])", a = "(?:" + s + "|[" + t + i + r + "])*";
    n.identifier = new RegExp(o + a, "g"), n.identifierStart = new RegExp(o), n.identifierMatch = new RegExp("(?:" + s + "|[" + t + i + r + "])+"), n.newline = /[\n\r\u2028\u2029]/, n.lineBreak = new RegExp(`\r
|` + n.newline.source), n.allLineBreaks = new RegExp(n.lineBreak.source, "g");
  }(ec)), ec;
}
var tc = {}, rs = {}, bh;
function _d() {
  if (bh) return rs;
  bh = 1;
  function n(i, r) {
    this.raw_options = e(i, r), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", !0), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	"), this.indent_with_tabs && (this.indent_char = "	", this.indent_size === 1 && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "angular", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  }
  n.prototype._get_array = function(i, r) {
    var s = this.raw_options[i], o = r || [];
    return typeof s == "object" ? s !== null && typeof s.concat == "function" && (o = s.concat()) : typeof s == "string" && (o = s.split(/[^a-zA-Z0-9_\/\-]+/)), o;
  }, n.prototype._get_boolean = function(i, r) {
    var s = this.raw_options[i], o = s === void 0 ? !!r : !!s;
    return o;
  }, n.prototype._get_characters = function(i, r) {
    var s = this.raw_options[i], o = r || "";
    return typeof s == "string" && (o = s.replace(/\\r/, "\r").replace(/\\n/, `
`).replace(/\\t/, "	")), o;
  }, n.prototype._get_number = function(i, r) {
    var s = this.raw_options[i];
    r = parseInt(r, 10), isNaN(r) && (r = 0);
    var o = parseInt(s, 10);
    return isNaN(o) && (o = r), o;
  }, n.prototype._get_selection = function(i, r, s) {
    var o = this._get_selection_list(i, r, s);
    if (o.length !== 1)
      throw new Error(
        "Invalid Option Value: The option '" + i + `' can only be one of the following values:
` + r + `
You passed in: '` + this.raw_options[i] + "'"
      );
    return o[0];
  }, n.prototype._get_selection_list = function(i, r, s) {
    if (!r || r.length === 0)
      throw new Error("Selection list cannot be empty.");
    if (s = s || [r[0]], !this._is_valid_selection(s, r))
      throw new Error("Invalid Default Value!");
    var o = this._get_array(i, s);
    if (!this._is_valid_selection(o, r))
      throw new Error(
        "Invalid Option Value: The option '" + i + `' can contain only the following values:
` + r + `
You passed in: '` + this.raw_options[i] + "'"
      );
    return o;
  }, n.prototype._is_valid_selection = function(i, r) {
    return i.length && r.length && !i.some(function(s) {
      return r.indexOf(s) === -1;
    });
  };
  function e(i, r) {
    var s = {};
    i = t(i);
    var o;
    for (o in i)
      o !== r && (s[o] = i[o]);
    if (r && i[r])
      for (o in i[r])
        s[o] = i[r][o];
    return s;
  }
  function t(i) {
    var r = {}, s;
    for (s in i) {
      var o = s.replace(/-/g, "_");
      r[o] = i[s];
    }
    return r;
  }
  return rs.Options = n, rs.normalizeOpts = t, rs.mergeOpts = e, rs;
}
var vh;
function g_() {
  if (vh) return tc;
  vh = 1;
  var n = _d().Options, e = ["before-newline", "after-newline", "preserve-newline"];
  function t(i) {
    n.call(this, i, "js");
    var r = this.raw_options.brace_style || null;
    r === "expand-strict" ? this.raw_options.brace_style = "expand" : r === "collapse-preserve-inline" ? this.raw_options.brace_style = "collapse,preserve-inline" : this.raw_options.braces_on_own_line !== void 0 && (this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse");
    var s = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = !1, this.brace_style = "collapse";
    for (var o = 0; o < s.length; o++)
      s[o] === "preserve-inline" ? this.brace_preserve_inline = !0 : this.brace_style = s[o];
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods"), this.break_chained_methods = this._get_boolean("break_chained_methods"), this.space_in_paren = this._get_boolean("space_in_paren"), this.space_in_empty_paren = this._get_boolean("space_in_empty_paren"), this.jslint_happy = this._get_boolean("jslint_happy"), this.space_after_anon_function = this._get_boolean("space_after_anon_function"), this.space_after_named_function = this._get_boolean("space_after_named_function"), this.keep_array_indentation = this._get_boolean("keep_array_indentation"), this.space_before_conditional = this._get_boolean("space_before_conditional", !0), this.unescape_strings = this._get_boolean("unescape_strings"), this.e4x = this._get_boolean("e4x"), this.comma_first = this._get_boolean("comma_first"), this.operator_position = this._get_selection("operator_position", e), this.test_output_raw = this._get_boolean("test_output_raw"), this.jslint_happy && (this.space_after_anon_function = !0);
  }
  return t.prototype = new n(), tc.Options = t, tc;
}
var lr = {}, nc = {}, yh;
function bd() {
  if (yh) return nc;
  yh = 1;
  var n = RegExp.prototype.hasOwnProperty("sticky");
  function e(t) {
    this.__input = t || "", this.__input_length = this.__input.length, this.__position = 0;
  }
  return e.prototype.restart = function() {
    this.__position = 0;
  }, e.prototype.back = function() {
    this.__position > 0 && (this.__position -= 1);
  }, e.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  }, e.prototype.next = function() {
    var t = null;
    return this.hasNext() && (t = this.__input.charAt(this.__position), this.__position += 1), t;
  }, e.prototype.peek = function(t) {
    var i = null;
    return t = t || 0, t += this.__position, t >= 0 && t < this.__input_length && (i = this.__input.charAt(t)), i;
  }, e.prototype.__match = function(t, i) {
    t.lastIndex = i;
    var r = t.exec(this.__input);
    return r && !(n && t.sticky) && r.index !== i && (r = null), r;
  }, e.prototype.test = function(t, i) {
    return i = i || 0, i += this.__position, i >= 0 && i < this.__input_length ? !!this.__match(t, i) : !1;
  }, e.prototype.testChar = function(t, i) {
    var r = this.peek(i);
    return t.lastIndex = 0, r !== null && t.test(r);
  }, e.prototype.match = function(t) {
    var i = this.__match(t, this.__position);
    return i ? this.__position += i[0].length : i = null, i;
  }, e.prototype.read = function(t, i, r) {
    var s = "", o;
    return t && (o = this.match(t), o && (s += o[0])), i && (o || !t) && (s += this.readUntil(i, r)), s;
  }, e.prototype.readUntil = function(t, i) {
    var r = "", s = this.__position;
    t.lastIndex = this.__position;
    var o = t.exec(this.__input);
    return o ? (s = o.index, i && (s += o[0].length)) : s = this.__input_length, r = this.__input.substring(this.__position, s), this.__position = s, r;
  }, e.prototype.readUntilAfter = function(t) {
    return this.readUntil(t, !0);
  }, e.prototype.get_regexp = function(t, i) {
    var r = null, s = "g";
    return i && n && (s = "y"), typeof t == "string" && t !== "" ? r = new RegExp(t, s) : t && (r = new RegExp(t.source, s)), r;
  }, e.prototype.get_literal_regexp = function(t) {
    return RegExp(t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  }, e.prototype.peekUntilAfter = function(t) {
    var i = this.__position, r = this.readUntilAfter(t);
    return this.__position = i, r;
  }, e.prototype.lookBack = function(t) {
    var i = this.__position - 1;
    return i >= t.length && this.__input.substring(i - t.length, i).toLowerCase() === t;
  }, nc.InputScanner = e, nc;
}
var To = {}, ic = {}, xh;
function Q2() {
  if (xh) return ic;
  xh = 1;
  function n(e) {
    this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = e;
  }
  return n.prototype.restart = function() {
    this.__position = 0;
  }, n.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  }, n.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  }, n.prototype.next = function() {
    var e = null;
    return this.hasNext() && (e = this.__tokens[this.__position], this.__position += 1), e;
  }, n.prototype.peek = function(e) {
    var t = null;
    return e = e || 0, e += this.__position, e >= 0 && e < this.__tokens_length && (t = this.__tokens[e]), t;
  }, n.prototype.add = function(e) {
    this.__parent_token && (e.parent = this.__parent_token), this.__tokens.push(e), this.__tokens_length += 1;
  }, ic.TokenStream = n, ic;
}
var rc = {}, sc = {}, wh;
function vl() {
  if (wh) return sc;
  wh = 1;
  function n(e, t) {
    this._input = e, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this._until_after = !1, t && (this._starting_pattern = this._input.get_regexp(t._starting_pattern, !0), this._match_pattern = this._input.get_regexp(t._match_pattern, !0), this._until_pattern = this._input.get_regexp(t._until_pattern), this._until_after = t._until_after);
  }
  return n.prototype.read = function() {
    var e = this._input.read(this._starting_pattern);
    return (!this._starting_pattern || e) && (e += this._input.read(this._match_pattern, this._until_pattern, this._until_after)), e;
  }, n.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  }, n.prototype.until_after = function(e) {
    var t = this._create();
    return t._until_after = !0, t._until_pattern = this._input.get_regexp(e), t._update(), t;
  }, n.prototype.until = function(e) {
    var t = this._create();
    return t._until_after = !1, t._until_pattern = this._input.get_regexp(e), t._update(), t;
  }, n.prototype.starting_with = function(e) {
    var t = this._create();
    return t._starting_pattern = this._input.get_regexp(e, !0), t._update(), t;
  }, n.prototype.matching = function(e) {
    var t = this._create();
    return t._match_pattern = this._input.get_regexp(e, !0), t._update(), t;
  }, n.prototype._create = function() {
    return new n(this._input, this);
  }, n.prototype._update = function() {
  }, sc.Pattern = n, sc;
}
var kh;
function ek() {
  if (kh) return rc;
  kh = 1;
  var n = vl().Pattern;
  function e(t, i) {
    n.call(this, t, i), i ? this._line_regexp = this._input.get_regexp(i._line_regexp) : this.__set_whitespace_patterns("", ""), this.newline_count = 0, this.whitespace_before_token = "";
  }
  return e.prototype = new n(), e.prototype.__set_whitespace_patterns = function(t, i) {
    t += "\\t ", i += "\\n\\r", this._match_pattern = this._input.get_regexp(
      "[" + t + i + "]+",
      !0
    ), this._newline_regexp = this._input.get_regexp(
      "\\r\\n|[" + i + "]"
    );
  }, e.prototype.read = function() {
    this.newline_count = 0, this.whitespace_before_token = "";
    var t = this._input.read(this._match_pattern);
    if (t === " ")
      this.whitespace_before_token = " ";
    else if (t) {
      var i = this.__split(this._newline_regexp, t);
      this.newline_count = i.length - 1, this.whitespace_before_token = i[this.newline_count];
    }
    return t;
  }, e.prototype.matching = function(t, i) {
    var r = this._create();
    return r.__set_whitespace_patterns(t, i), r._update(), r;
  }, e.prototype._create = function() {
    return new e(this._input, this);
  }, e.prototype.__split = function(t, i) {
    t.lastIndex = 0;
    for (var r = 0, s = [], o = t.exec(i); o; )
      s.push(i.substring(r, o.index)), r = o.index + o[0].length, o = t.exec(i);
    return r < i.length ? s.push(i.substring(r, i.length)) : s.push(""), s;
  }, rc.WhitespacePattern = e, rc;
}
var Sh;
function va() {
  if (Sh) return To;
  Sh = 1;
  var n = bd().InputScanner, e = p_().Token, t = Q2().TokenStream, i = ek().WhitespacePattern, r = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  }, s = function(o, a) {
    this._input = new n(o), this._options = a || {}, this.__tokens = null, this._patterns = {}, this._patterns.whitespace = new i(this._input);
  };
  return s.prototype.tokenize = function() {
    this._input.restart(), this.__tokens = new t(), this._reset();
    for (var o, a = new e(r.START, ""), l = null, c = [], u = new t(); a.type !== r.EOF; ) {
      for (o = this._get_next_token(a, l); this._is_comment(o); )
        u.add(o), o = this._get_next_token(a, l);
      u.isEmpty() || (o.comments_before = u, u = new t()), o.parent = l, this._is_opening(o) ? (c.push(l), l = o) : l && this._is_closing(o, l) && (o.opened = l, l.closed = o, l = c.pop(), o.parent = l), o.previous = a, a.next = o, this.__tokens.add(o), a = o;
    }
    return this.__tokens;
  }, s.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  }, s.prototype._reset = function() {
  }, s.prototype._get_next_token = function(o, a) {
    this._readWhitespace();
    var l = this._input.read(/.+/g);
    return l ? this._create_token(r.RAW, l) : this._create_token(r.EOF, "");
  }, s.prototype._is_comment = function(o) {
    return !1;
  }, s.prototype._is_opening = function(o) {
    return !1;
  }, s.prototype._is_closing = function(o, a) {
    return !1;
  }, s.prototype._create_token = function(o, a) {
    var l = new e(
      o,
      a,
      this._patterns.whitespace.newline_count,
      this._patterns.whitespace.whitespace_before_token
    );
    return l;
  }, s.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  }, To.Tokenizer = s, To.TOKEN = r, To;
}
var oc = {}, Ch;
function vd() {
  if (Ch) return oc;
  Ch = 1;
  function n(e, t) {
    e = typeof e == "string" ? e : e.source, t = typeof t == "string" ? t : t.source, this.__directives_block_pattern = new RegExp(e + / beautify( \w+[:]\w+)+ /.source + t, "g"), this.__directive_pattern = / (\w+)[:](\w+)/g, this.__directives_end_ignore_pattern = new RegExp(e + /\sbeautify\signore:end\s/.source + t, "g");
  }
  return n.prototype.get_directives = function(e) {
    if (!e.match(this.__directives_block_pattern))
      return null;
    var t = {};
    this.__directive_pattern.lastIndex = 0;
    for (var i = this.__directive_pattern.exec(e); i; )
      t[i[1]] = i[2], i = this.__directive_pattern.exec(e);
    return t;
  }, n.prototype.readIgnored = function(e) {
    return e.readUntilAfter(this.__directives_end_ignore_pattern);
  }, oc.Directives = n, oc;
}
var ac = {}, Th;
function __() {
  if (Th) return ac;
  Th = 1;
  var n = vl().Pattern, e = {
    django: !1,
    erb: !1,
    handlebars: !1,
    php: !1,
    smarty: !1,
    angular: !1
  };
  function t(i, r) {
    n.call(this, i, r), this.__template_pattern = null, this._disabled = Object.assign({}, e), this._excluded = Object.assign({}, e), r && (this.__template_pattern = this._input.get_regexp(r.__template_pattern), this._excluded = Object.assign(this._excluded, r._excluded), this._disabled = Object.assign(this._disabled, r._disabled));
    var s = new n(i);
    this.__patterns = {
      handlebars_comment: s.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: s.starting_with(/{{{/).until_after(/}}}/),
      handlebars: s.starting_with(/{{/).until_after(/}}/),
      php: s.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: s.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      // django coflicts with handlebars a bit.
      django: s.starting_with(/{%/).until_after(/%}/),
      django_value: s.starting_with(/{{/).until_after(/}}/),
      django_comment: s.starting_with(/{#/).until_after(/#}/),
      smarty: s.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: s.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: s.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  }
  return t.prototype = new n(), t.prototype._create = function() {
    return new t(this._input, this);
  }, t.prototype._update = function() {
    this.__set_templated_pattern();
  }, t.prototype.disable = function(i) {
    var r = this._create();
    return r._disabled[i] = !0, r._update(), r;
  }, t.prototype.read_options = function(i) {
    var r = this._create();
    for (var s in e)
      r._disabled[s] = i.templating.indexOf(s) === -1;
    return r._update(), r;
  }, t.prototype.exclude = function(i) {
    var r = this._create();
    return r._excluded[i] = !0, r._update(), r;
  }, t.prototype.read = function() {
    var i = "";
    this._match_pattern ? i = this._input.read(this._starting_pattern) : i = this._input.read(this._starting_pattern, this.__template_pattern);
    for (var r = this._read_template(); r; )
      this._match_pattern ? r += this._input.read(this._match_pattern) : r += this._input.readUntil(this.__template_pattern), i += r, r = this._read_template();
    return this._until_after && (i += this._input.readUntilAfter(this._until_pattern)), i;
  }, t.prototype.__set_templated_pattern = function() {
    var i = [];
    this._disabled.php || i.push(this.__patterns.php._starting_pattern.source), this._disabled.handlebars || i.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.angular || i.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.erb || i.push(this.__patterns.erb._starting_pattern.source), this._disabled.django || (i.push(this.__patterns.django._starting_pattern.source), i.push(this.__patterns.django_value._starting_pattern.source), i.push(this.__patterns.django_comment._starting_pattern.source)), this._disabled.smarty || i.push(this.__patterns.smarty._starting_pattern.source), this._until_pattern && i.push(this._until_pattern.source), this.__template_pattern = this._input.get_regexp("(?:" + i.join("|") + ")");
  }, t.prototype._read_template = function() {
    var i = "", r = this._input.peek();
    if (r === "<") {
      var s = this._input.peek(1);
      !this._disabled.php && !this._excluded.php && s === "?" && (i = i || this.__patterns.php.read()), !this._disabled.erb && !this._excluded.erb && s === "%" && (i = i || this.__patterns.erb.read());
    } else r === "{" && (!this._disabled.handlebars && !this._excluded.handlebars && (i = i || this.__patterns.handlebars_comment.read(), i = i || this.__patterns.handlebars_unescaped.read(), i = i || this.__patterns.handlebars.read()), this._disabled.django || (!this._excluded.django && !this._excluded.handlebars && (i = i || this.__patterns.django_value.read()), this._excluded.django || (i = i || this.__patterns.django_comment.read(), i = i || this.__patterns.django.read())), this._disabled.smarty || this._disabled.django && this._disabled.handlebars && (i = i || this.__patterns.smarty_comment.read(), i = i || this.__patterns.smarty_literal.read(), i = i || this.__patterns.smarty.read()));
    return i;
  }, ac.TemplatablePattern = t, ac;
}
var Eh;
function Eo() {
  if (Eh) return lr;
  Eh = 1;
  var n = bd().InputScanner, e = va().Tokenizer, t = va().TOKEN, i = vd().Directives, r = m_(), s = vl().Pattern, o = __().TemplatablePattern;
  function a(k, C) {
    return C.indexOf(k) !== -1;
  }
  var l = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: t.START,
    RAW: t.RAW,
    EOF: t.EOF
  }, c = new i(/\/\*/, /\*\//), u = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/, d = /[0-9]/, f = /[^\d\.]/, h = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" "), p = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  p = p.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"), p = "\\?\\.(?!\\d) " + p, p = p.replace(/ /g, "|");
  var b = new RegExp(p), m = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(","), g = m.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]), v = new RegExp("^(?:" + g.join("|") + ")$"), x, w = function(k, C) {
    e.call(this, k, C), this._patterns.whitespace = this._patterns.whitespace.matching(
      /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
      /\u2028\u2029/.source
    );
    var y = new s(this._input), A = new o(this._input).read_options(this._options);
    this.__patterns = {
      template: A,
      identifier: A.starting_with(r.identifier).matching(r.identifierMatch),
      number: y.matching(u),
      punct: y.matching(b),
      // comment ends just before nearest linefeed or end of file
      comment: y.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      //  /* ... */ comment ends with nearest */ or end of file
      block_comment: y.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: y.matching(/<!--/),
      html_comment_end: y.matching(/-->/),
      include: y.starting_with(/#include/).until_after(r.lineBreak),
      shebang: y.starting_with(/#!/).until_after(r.lineBreak),
      xml: y.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: A.until(/['\\\n\r\u2028\u2029]/),
      double_quote: A.until(/["\\\n\r\u2028\u2029]/),
      template_text: A.until(/[`\\$]/),
      template_expression: A.until(/[`}\\]/)
    };
  };
  w.prototype = new e(), w.prototype._is_comment = function(k) {
    return k.type === l.COMMENT || k.type === l.BLOCK_COMMENT || k.type === l.UNKNOWN;
  }, w.prototype._is_opening = function(k) {
    return k.type === l.START_BLOCK || k.type === l.START_EXPR;
  }, w.prototype._is_closing = function(k, C) {
    return (k.type === l.END_BLOCK || k.type === l.END_EXPR) && C && (k.text === "]" && C.text === "[" || k.text === ")" && C.text === "(" || k.text === "}" && C.text === "{");
  }, w.prototype._reset = function() {
    x = !1;
  }, w.prototype._get_next_token = function(k, C) {
    var y = null;
    this._readWhitespace();
    var A = this._input.peek();
    return A === null ? this._create_token(l.EOF, "") : (y = y || this._read_non_javascript(A), y = y || this._read_string(A), y = y || this._read_pair(A, this._input.peek(1)), y = y || this._read_word(k), y = y || this._read_singles(A), y = y || this._read_comment(A), y = y || this._read_regexp(A, k), y = y || this._read_xml(A, k), y = y || this._read_punctuation(), y = y || this._create_token(l.UNKNOWN, this._input.next()), y);
  }, w.prototype._read_word = function(k) {
    var C;
    if (C = this.__patterns.identifier.read(), C !== "")
      return C = C.replace(r.allLineBreaks, `
`), !(k.type === l.DOT || k.type === l.RESERVED && (k.text === "set" || k.text === "get")) && v.test(C) ? (C === "in" || C === "of") && (k.type === l.WORD || k.type === l.STRING) ? this._create_token(l.OPERATOR, C) : this._create_token(l.RESERVED, C) : this._create_token(l.WORD, C);
    if (C = this.__patterns.number.read(), C !== "")
      return this._create_token(l.WORD, C);
  }, w.prototype._read_singles = function(k) {
    var C = null;
    return k === "(" || k === "[" ? C = this._create_token(l.START_EXPR, k) : k === ")" || k === "]" ? C = this._create_token(l.END_EXPR, k) : k === "{" ? C = this._create_token(l.START_BLOCK, k) : k === "}" ? C = this._create_token(l.END_BLOCK, k) : k === ";" ? C = this._create_token(l.SEMICOLON, k) : k === "." && f.test(this._input.peek(1)) ? C = this._create_token(l.DOT, k) : k === "," && (C = this._create_token(l.COMMA, k)), C && this._input.next(), C;
  }, w.prototype._read_pair = function(k, C) {
    var y = null;
    return k === "#" && C === "{" && (y = this._create_token(l.START_BLOCK, k + C)), y && (this._input.next(), this._input.next()), y;
  }, w.prototype._read_punctuation = function() {
    var k = this.__patterns.punct.read();
    if (k !== "")
      return k === "=" ? this._create_token(l.EQUALS, k) : k === "?." ? this._create_token(l.DOT, k) : this._create_token(l.OPERATOR, k);
  }, w.prototype._read_non_javascript = function(k) {
    var C = "";
    if (k === "#") {
      if (this._is_first_token() && (C = this.__patterns.shebang.read(), C))
        return this._create_token(l.UNKNOWN, C.trim() + `
`);
      if (C = this.__patterns.include.read(), C)
        return this._create_token(l.UNKNOWN, C.trim() + `
`);
      k = this._input.next();
      var y = "#";
      if (this._input.hasNext() && this._input.testChar(d)) {
        do
          k = this._input.next(), y += k;
        while (this._input.hasNext() && k !== "#" && k !== "=");
        return k === "#" || (this._input.peek() === "[" && this._input.peek(1) === "]" ? (y += "[]", this._input.next(), this._input.next()) : this._input.peek() === "{" && this._input.peek(1) === "}" && (y += "{}", this._input.next(), this._input.next())), this._create_token(l.WORD, y);
      }
      this._input.back();
    } else if (k === "<" && this._is_first_token()) {
      if (C = this.__patterns.html_comment_start.read(), C) {
        for (; this._input.hasNext() && !this._input.testChar(r.newline); )
          C += this._input.next();
        return x = !0, this._create_token(l.COMMENT, C);
      }
    } else if (x && k === "-" && (C = this.__patterns.html_comment_end.read(), C))
      return x = !1, this._create_token(l.COMMENT, C);
    return null;
  }, w.prototype._read_comment = function(k) {
    var C = null;
    if (k === "/") {
      var y = "";
      if (this._input.peek(1) === "*") {
        y = this.__patterns.block_comment.read();
        var A = c.get_directives(y);
        A && A.ignore === "start" && (y += c.readIgnored(this._input)), y = y.replace(r.allLineBreaks, `
`), C = this._create_token(l.BLOCK_COMMENT, y), C.directives = A;
      } else this._input.peek(1) === "/" && (y = this.__patterns.comment.read(), C = this._create_token(l.COMMENT, y));
    }
    return C;
  }, w.prototype._read_string = function(k) {
    if (k === "`" || k === "'" || k === '"') {
      var C = this._input.next();
      return this.has_char_escapes = !1, k === "`" ? C += this._read_string_recursive("`", !0, "${") : C += this._read_string_recursive(k), this.has_char_escapes && this._options.unescape_strings && (C = S(C)), this._input.peek() === k && (C += this._input.next()), C = C.replace(r.allLineBreaks, `
`), this._create_token(l.STRING, C);
    }
    return null;
  }, w.prototype._allow_regexp_or_xml = function(k) {
    return k.type === l.RESERVED && a(k.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || k.type === l.END_EXPR && k.text === ")" && k.opened.previous.type === l.RESERVED && a(k.opened.previous.text, ["if", "while", "for"]) || a(k.type, [
      l.COMMENT,
      l.START_EXPR,
      l.START_BLOCK,
      l.START,
      l.END_BLOCK,
      l.OPERATOR,
      l.EQUALS,
      l.EOF,
      l.SEMICOLON,
      l.COMMA
    ]);
  }, w.prototype._read_regexp = function(k, C) {
    if (k === "/" && this._allow_regexp_or_xml(C)) {
      for (var y = this._input.next(), A = !1, _ = !1; this._input.hasNext() && (A || _ || this._input.peek() !== k) && !this._input.testChar(r.newline); )
        y += this._input.peek(), A ? A = !1 : (A = this._input.peek() === "\\", this._input.peek() === "[" ? _ = !0 : this._input.peek() === "]" && (_ = !1)), this._input.next();
      return this._input.peek() === k && (y += this._input.next(), y += this._input.read(r.identifier)), this._create_token(l.STRING, y);
    }
    return null;
  }, w.prototype._read_xml = function(k, C) {
    if (this._options.e4x && k === "<" && this._allow_regexp_or_xml(C)) {
      var y = "", A = this.__patterns.xml.read_match();
      if (A) {
        for (var _ = A[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}"), T = _.indexOf("{") === 0, M = 0; A; ) {
          var z = !!A[1], P = A[2], V = !!A[A.length - 1] || P.slice(0, 8) === "![CDATA[";
          if (!V && (P === _ || T && P.replace(/^{\s+/, "{").replace(/\s+}$/, "}")) && (z ? --M : ++M), y += A[0], M <= 0)
            break;
          A = this.__patterns.xml.read_match();
        }
        return A || (y += this._input.match(/[\s\S]*/g)[0]), y = y.replace(r.allLineBreaks, `
`), this._create_token(l.STRING, y);
      }
    }
    return null;
  };
  function S(k) {
    for (var C = "", y = 0, A = new n(k), _ = null; A.hasNext(); )
      if (_ = A.match(/([\s]|[^\\]|\\\\)+/g), _ && (C += _[0]), A.peek() === "\\") {
        if (A.next(), A.peek() === "x")
          _ = A.match(/x([0-9A-Fa-f]{2})/g);
        else if (A.peek() === "u")
          _ = A.match(/u([0-9A-Fa-f]{4})/g), _ || (_ = A.match(/u\{([0-9A-Fa-f]+)\}/g));
        else {
          C += "\\", A.hasNext() && (C += A.next());
          continue;
        }
        if (!_ || (y = parseInt(_[1], 16), y > 126 && y <= 255 && _[0].indexOf("x") === 0))
          return k;
        y >= 0 && y < 32 || y > 1114111 ? C += "\\" + _[0] : y === 34 || y === 39 || y === 92 ? C += "\\" + String.fromCharCode(y) : C += String.fromCharCode(y);
      }
    return C;
  }
  return w.prototype._read_string_recursive = function(k, C, y) {
    var A, _;
    k === "'" ? _ = this.__patterns.single_quote : k === '"' ? _ = this.__patterns.double_quote : k === "`" ? _ = this.__patterns.template_text : k === "}" && (_ = this.__patterns.template_expression);
    for (var T = _.read(), M = ""; this._input.hasNext(); ) {
      if (M = this._input.next(), M === k || !C && r.newline.test(M)) {
        this._input.back();
        break;
      } else M === "\\" && this._input.hasNext() ? (A = this._input.peek(), A === "x" || A === "u" ? this.has_char_escapes = !0 : A === "\r" && this._input.peek(1) === `
` && this._input.next(), M += this._input.next()) : y && (y === "${" && M === "$" && this._input.peek() === "{" && (M += this._input.next()), y === M && (k === "`" ? M += this._read_string_recursive("}", C, "`") : M += this._read_string_recursive("`", C, "${"), this._input.hasNext() && (M += this._input.next())));
      M += _.read(), T += M;
    }
    return T;
  }, lr.Tokenizer = w, lr.TOKEN = l, lr.positionable_operators = h.slice(), lr.line_starters = m.slice(), lr;
}
var Ah;
function tk() {
  if (Ah) return Yl;
  Ah = 1;
  var n = gd().Output, e = p_().Token, t = m_(), i = g_().Options, r = Eo().Tokenizer, s = Eo().line_starters, o = Eo().positionable_operators, a = Eo().TOKEN;
  function l(_, T) {
    return T.indexOf(_) !== -1;
  }
  function c(_) {
    return _.replace(/^\s+/g, "");
  }
  function u(_) {
    for (var T = {}, M = 0; M < _.length; M++)
      T[_[M].replace(/-/g, "_")] = _[M];
    return T;
  }
  function d(_, T) {
    return _ && _.type === a.RESERVED && _.text === T;
  }
  function f(_, T) {
    return _ && _.type === a.RESERVED && l(_.text, T);
  }
  var h = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"], p = ["before-newline", "after-newline", "preserve-newline"], b = u(p), m = [b.before_newline, b.preserve_newline], g = {
    BlockStatement: "BlockStatement",
    // 'BLOCK'
    Statement: "Statement",
    // 'STATEMENT'
    ObjectLiteral: "ObjectLiteral",
    // 'OBJECT',
    ArrayLiteral: "ArrayLiteral",
    //'[EXPRESSION]',
    ForInitializer: "ForInitializer",
    //'(FOR-EXPRESSION)',
    Conditional: "Conditional",
    //'(COND-EXPRESSION)',
    Expression: "Expression"
    //'(EXPRESSION)'
  };
  function v(_, T) {
    T.multiline_frame || T.mode === g.ForInitializer || T.mode === g.Conditional || _.remove_indent(T.start_line_index);
  }
  function x(_) {
    _ = _.replace(t.allLineBreaks, `
`);
    for (var T = [], M = _.indexOf(`
`); M !== -1; )
      T.push(_.substring(0, M)), _ = _.substring(M + 1), M = _.indexOf(`
`);
    return _.length && T.push(_), T;
  }
  function w(_) {
    return _ === g.ArrayLiteral;
  }
  function S(_) {
    return l(_, [g.Expression, g.ForInitializer, g.Conditional]);
  }
  function k(_, T) {
    for (var M = 0; M < _.length; M++) {
      var z = _[M].trim();
      if (z.charAt(0) !== T)
        return !1;
    }
    return !0;
  }
  function C(_, T) {
    for (var M = 0, z = _.length, P; M < z; M++)
      if (P = _[M], P && P.indexOf(T) !== 0)
        return !1;
    return !0;
  }
  function y(_, T) {
    T = T || {}, this._source_text = _ || "", this._output = null, this._tokens = null, this._last_last_text = null, this._flags = null, this._previous_flags = null, this._flag_store = null, this._options = new i(T);
  }
  y.prototype.create_flags = function(_, T) {
    var M = 0;
    _ && (M = _.indentation_level, !this._output.just_added_newline() && _.line_indent_level > M && (M = _.line_indent_level));
    var z = {
      mode: T,
      parent: _,
      last_token: _ ? _.last_token : new e(a.START_BLOCK, ""),
      // last token text
      last_word: _ ? _.last_word : "",
      // last TOKEN.WORD passed
      declaration_statement: !1,
      declaration_assignment: !1,
      multiline_frame: !1,
      inline_frame: !1,
      if_block: !1,
      else_block: !1,
      class_start_block: !1,
      // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
      do_block: !1,
      do_while: !1,
      import_block: !1,
      in_case_statement: !1,
      // switch(..){ INSIDE HERE }
      in_case: !1,
      // we're on the exact line with "case 0:"
      case_body: !1,
      // the indented case-action block
      case_block: !1,
      // the indented case-action block is wrapped with {}
      indentation_level: M,
      alignment: 0,
      line_indent_level: _ ? _.line_indent_level : M,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return z;
  }, y.prototype._reset = function(_) {
    var T = _.match(/^[\t ]*/)[0];
    this._last_last_text = "", this._output = new n(this._options, T), this._output.raw = this._options.test_output_raw, this._flag_store = [], this.set_mode(g.BlockStatement);
    var M = new r(_, this._options);
    return this._tokens = M.tokenize(), _;
  }, y.prototype.beautify = function() {
    if (this._options.disabled)
      return this._source_text;
    var _, T = this._reset(this._source_text), M = this._options.eol;
    this._options.eol === "auto" && (M = `
`, T && t.lineBreak.test(T || "") && (M = T.match(t.lineBreak)[0]));
    for (var z = this._tokens.next(); z; )
      this.handle_token(z), this._last_last_text = this._flags.last_token.text, this._flags.last_token = z, z = this._tokens.next();
    return _ = this._output.get_code(M), _;
  }, y.prototype.handle_token = function(_, T) {
    _.type === a.START_EXPR ? this.handle_start_expr(_) : _.type === a.END_EXPR ? this.handle_end_expr(_) : _.type === a.START_BLOCK ? this.handle_start_block(_) : _.type === a.END_BLOCK ? this.handle_end_block(_) : _.type === a.WORD ? this.handle_word(_) : _.type === a.RESERVED ? this.handle_word(_) : _.type === a.SEMICOLON ? this.handle_semicolon(_) : _.type === a.STRING ? this.handle_string(_) : _.type === a.EQUALS ? this.handle_equals(_) : _.type === a.OPERATOR ? this.handle_operator(_) : _.type === a.COMMA ? this.handle_comma(_) : _.type === a.BLOCK_COMMENT ? this.handle_block_comment(_, T) : _.type === a.COMMENT ? this.handle_comment(_, T) : _.type === a.DOT ? this.handle_dot(_) : _.type === a.EOF ? this.handle_eof(_) : _.type === a.UNKNOWN ? this.handle_unknown(_, T) : this.handle_unknown(_, T);
  }, y.prototype.handle_whitespace_and_comments = function(_, T) {
    var M = _.newlines, z = this._options.keep_array_indentation && w(this._flags.mode);
    if (_.comments_before)
      for (var P = _.comments_before.next(); P; )
        this.handle_whitespace_and_comments(P, T), this.handle_token(P, T), P = _.comments_before.next();
    if (z)
      for (var V = 0; V < M; V += 1)
        this.print_newline(V > 0, T);
    else if (this._options.max_preserve_newlines && M > this._options.max_preserve_newlines && (M = this._options.max_preserve_newlines), this._options.preserve_newlines && M > 1) {
      this.print_newline(!1, T);
      for (var U = 1; U < M; U += 1)
        this.print_newline(!0, T);
    }
  };
  var A = ["async", "break", "continue", "return", "throw", "yield"];
  return y.prototype.allow_wrap_or_preserved_newline = function(_, T) {
    if (T = T === void 0 ? !1 : T, !this._output.just_added_newline()) {
      var M = this._options.preserve_newlines && _.newlines || T, z = l(this._flags.last_token.text, o) || l(_.text, o);
      if (z) {
        var P = l(this._flags.last_token.text, o) && l(this._options.operator_position, m) || l(_.text, o);
        M = M && P;
      }
      if (M)
        this.print_newline(!1, !0);
      else if (this._options.wrap_line_length) {
        if (f(this._flags.last_token, A))
          return;
        this._output.set_wrap_point();
      }
    }
  }, y.prototype.print_newline = function(_, T) {
    if (!T && this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== a.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++"))
      for (var M = this._tokens.peek(); this._flags.mode === g.Statement && !(this._flags.if_block && d(M, "else")) && !this._flags.do_block; )
        this.restore_mode();
    this._output.add_new_line(_) && (this._flags.multiline_frame = !0);
  }, y.prototype.print_token_line_indentation = function(_) {
    this._output.just_added_newline() && (this._options.keep_array_indentation && _.newlines && (_.text === "[" || w(this._flags.mode)) ? (this._output.current_line.set_indent(-1), this._output.current_line.push(_.whitespace_before), this._output.space_before_token = !1) : this._output.set_indent(this._flags.indentation_level, this._flags.alignment) && (this._flags.line_indent_level = this._flags.indentation_level));
  }, y.prototype.print_token = function(_) {
    if (this._output.raw) {
      this._output.add_raw_token(_);
      return;
    }
    if (this._options.comma_first && _.previous && _.previous.type === a.COMMA && this._output.just_added_newline() && this._output.previous_line.last() === ",") {
      var T = this._output.previous_line.pop();
      this._output.previous_line.is_empty() && (this._output.previous_line.push(T), this._output.trim(!0), this._output.current_line.pop(), this._output.trim()), this.print_token_line_indentation(_), this._output.add_token(","), this._output.space_before_token = !0;
    }
    this.print_token_line_indentation(_), this._output.non_breaking_space = !0, this._output.add_token(_.text), this._output.previous_token_wrapped && (this._flags.multiline_frame = !0);
  }, y.prototype.indent = function() {
    this._flags.indentation_level += 1, this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }, y.prototype.deindent = function() {
    this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level) && (this._flags.indentation_level -= 1, this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
  }, y.prototype.set_mode = function(_) {
    this._flags ? (this._flag_store.push(this._flags), this._previous_flags = this._flags) : this._previous_flags = this.create_flags(null, _), this._flags = this.create_flags(this._previous_flags, _), this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }, y.prototype.restore_mode = function() {
    this._flag_store.length > 0 && (this._previous_flags = this._flags, this._flags = this._flag_store.pop(), this._previous_flags.mode === g.Statement && v(this._output, this._previous_flags), this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
  }, y.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === g.ObjectLiteral && this._flags.mode === g.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || f(this._flags.last_token, ["get", "set"]));
  }, y.prototype.start_of_statement = function(_) {
    var T = !1;
    return T = T || f(this._flags.last_token, ["var", "let", "const"]) && _.type === a.WORD, T = T || d(this._flags.last_token, "do"), T = T || !(this._flags.parent.mode === g.ObjectLiteral && this._flags.mode === g.Statement) && f(this._flags.last_token, A) && !_.newlines, T = T || d(this._flags.last_token, "else") && !(d(_, "if") && !_.comments_before), T = T || this._flags.last_token.type === a.END_EXPR && (this._previous_flags.mode === g.ForInitializer || this._previous_flags.mode === g.Conditional), T = T || this._flags.last_token.type === a.WORD && this._flags.mode === g.BlockStatement && !this._flags.in_case && !(_.text === "--" || _.text === "++") && this._last_last_text !== "function" && _.type !== a.WORD && _.type !== a.RESERVED, T = T || this._flags.mode === g.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || f(this._flags.last_token, ["get", "set"])), T ? (this.set_mode(g.Statement), this.indent(), this.handle_whitespace_and_comments(_, !0), this.start_of_object_property() || this.allow_wrap_or_preserved_newline(
      _,
      f(_, ["do", "for", "if", "while"])
    ), !0) : !1;
  }, y.prototype.handle_start_expr = function(_) {
    this.start_of_statement(_) || this.handle_whitespace_and_comments(_);
    var T = g.Expression;
    if (_.text === "[") {
      if (this._flags.last_token.type === a.WORD || this._flags.last_token.text === ")") {
        f(this._flags.last_token, s) && (this._output.space_before_token = !0), this.print_token(_), this.set_mode(T), this.indent(), this._options.space_in_paren && (this._output.space_before_token = !0);
        return;
      }
      T = g.ArrayLiteral, w(this._flags.mode) && (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) && (this._options.keep_array_indentation || this.print_newline()), l(this._flags.last_token.type, [a.START_EXPR, a.END_EXPR, a.WORD, a.OPERATOR, a.DOT]) || (this._output.space_before_token = !0);
    } else {
      if (this._flags.last_token.type === a.RESERVED)
        this._flags.last_token.text === "for" ? (this._output.space_before_token = this._options.space_before_conditional, T = g.ForInitializer) : l(this._flags.last_token.text, ["if", "while", "switch"]) ? (this._output.space_before_token = this._options.space_before_conditional, T = g.Conditional) : l(this._flags.last_word, ["await", "async"]) ? this._output.space_before_token = !0 : this._flags.last_token.text === "import" && _.whitespace_before === "" ? this._output.space_before_token = !1 : (l(this._flags.last_token.text, s) || this._flags.last_token.text === "catch") && (this._output.space_before_token = !0);
      else if (this._flags.last_token.type === a.EQUALS || this._flags.last_token.type === a.OPERATOR)
        this.start_of_object_property() || this.allow_wrap_or_preserved_newline(_);
      else if (this._flags.last_token.type === a.WORD) {
        this._output.space_before_token = !1;
        var M = this._tokens.peek(-3);
        if (this._options.space_after_named_function && M) {
          var z = this._tokens.peek(-4);
          f(M, ["async", "function"]) || M.text === "*" && f(z, ["async", "function"]) ? this._output.space_before_token = !0 : this._flags.mode === g.ObjectLiteral ? (M.text === "{" || M.text === "," || M.text === "*" && (z.text === "{" || z.text === ",")) && (this._output.space_before_token = !0) : this._flags.parent && this._flags.parent.class_start_block && (this._output.space_before_token = !0);
        }
      } else
        this.allow_wrap_or_preserved_newline(_);
      (this._flags.last_token.type === a.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === g.ObjectLiteral && l(this._last_last_text, ["{", ","]))) && (this._output.space_before_token = this._options.space_after_anon_function);
    }
    this._flags.last_token.text === ";" || this._flags.last_token.type === a.START_BLOCK ? this.print_newline() : (this._flags.last_token.type === a.END_EXPR || this._flags.last_token.type === a.START_EXPR || this._flags.last_token.type === a.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === a.COMMA) && this.allow_wrap_or_preserved_newline(_, _.newlines), this.print_token(_), this.set_mode(T), this._options.space_in_paren && (this._output.space_before_token = !0), this.indent();
  }, y.prototype.handle_end_expr = function(_) {
    for (; this._flags.mode === g.Statement; )
      this.restore_mode();
    this.handle_whitespace_and_comments(_), this._flags.multiline_frame && this.allow_wrap_or_preserved_newline(
      _,
      _.text === "]" && w(this._flags.mode) && !this._options.keep_array_indentation
    ), this._options.space_in_paren && (this._flags.last_token.type === a.START_EXPR && !this._options.space_in_empty_paren ? (this._output.trim(), this._output.space_before_token = !1) : this._output.space_before_token = !0), this.deindent(), this.print_token(_), this.restore_mode(), v(this._output, this._previous_flags), this._flags.do_while && this._previous_flags.mode === g.Conditional && (this._previous_flags.mode = g.Expression, this._flags.do_block = !1, this._flags.do_while = !1);
  }, y.prototype.handle_start_block = function(_) {
    this.handle_whitespace_and_comments(_);
    var T = this._tokens.peek(), M = this._tokens.peek(1);
    this._flags.last_word === "switch" && this._flags.last_token.type === a.END_EXPR ? (this.set_mode(g.BlockStatement), this._flags.in_case_statement = !0) : this._flags.case_body ? this.set_mode(g.BlockStatement) : M && (l(M.text, [":", ","]) && l(T.type, [a.STRING, a.WORD, a.RESERVED]) || l(T.text, ["get", "set", "..."]) && l(M.type, [a.WORD, a.RESERVED])) ? l(this._last_last_text, ["class", "interface"]) && !l(M.text, [":", ","]) ? this.set_mode(g.BlockStatement) : this.set_mode(g.ObjectLiteral) : this._flags.last_token.type === a.OPERATOR && this._flags.last_token.text === "=>" ? this.set_mode(g.BlockStatement) : l(this._flags.last_token.type, [a.EQUALS, a.START_EXPR, a.COMMA, a.OPERATOR]) || f(this._flags.last_token, ["return", "throw", "import", "default"]) ? this.set_mode(g.ObjectLiteral) : this.set_mode(g.BlockStatement), this._flags.last_token && f(this._flags.last_token.previous, ["class", "extends"]) && (this._flags.class_start_block = !0);
    var z = !T.comments_before && T.text === "}", P = z && this._flags.last_word === "function" && this._flags.last_token.type === a.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var V = 0, U = null;
      this._flags.inline_frame = !0;
      do
        if (V += 1, U = this._tokens.peek(V - 1), U.newlines) {
          this._flags.inline_frame = !1;
          break;
        }
      while (U.type !== a.EOF && !(U.type === a.END_BLOCK && U.opened === _));
    }
    (this._options.brace_style === "expand" || this._options.brace_style === "none" && _.newlines) && !this._flags.inline_frame ? this._flags.last_token.type !== a.OPERATOR && (P || this._flags.last_token.type === a.EQUALS || f(this._flags.last_token, h) && this._flags.last_token.text !== "else") ? this._output.space_before_token = !0 : this.print_newline(!1, !0) : (w(this._previous_flags.mode) && (this._flags.last_token.type === a.START_EXPR || this._flags.last_token.type === a.COMMA) && ((this._flags.last_token.type === a.COMMA || this._options.space_in_paren) && (this._output.space_before_token = !0), (this._flags.last_token.type === a.COMMA || this._flags.last_token.type === a.START_EXPR && this._flags.inline_frame) && (this.allow_wrap_or_preserved_newline(_), this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame, this._flags.multiline_frame = !1)), this._flags.last_token.type !== a.OPERATOR && this._flags.last_token.type !== a.START_EXPR && (l(this._flags.last_token.type, [a.START_BLOCK, a.SEMICOLON]) && !this._flags.inline_frame ? this.print_newline() : this._output.space_before_token = !0)), this.print_token(_), this.indent(), !z && !(this._options.brace_preserve_inline && this._flags.inline_frame) && this.print_newline();
  }, y.prototype.handle_end_block = function(_) {
    for (this.handle_whitespace_and_comments(_); this._flags.mode === g.Statement; )
      this.restore_mode();
    var T = this._flags.last_token.type === a.START_BLOCK;
    this._flags.inline_frame && !T ? this._output.space_before_token = !0 : this._options.brace_style === "expand" ? T || this.print_newline() : T || (w(this._flags.mode) && this._options.keep_array_indentation ? (this._options.keep_array_indentation = !1, this.print_newline(), this._options.keep_array_indentation = !0) : this.print_newline()), this.restore_mode(), this.print_token(_);
  }, y.prototype.handle_word = function(_) {
    if (_.type === a.RESERVED) {
      if (l(_.text, ["set", "get"]) && this._flags.mode !== g.ObjectLiteral)
        _.type = a.WORD;
      else if (_.text === "import" && l(this._tokens.peek().text, ["(", "."]))
        _.type = a.WORD;
      else if (l(_.text, ["as", "from"]) && !this._flags.import_block)
        _.type = a.WORD;
      else if (this._flags.mode === g.ObjectLiteral) {
        var T = this._tokens.peek();
        T.text === ":" && (_.type = a.WORD);
      }
    }
    if (this.start_of_statement(_) ? f(this._flags.last_token, ["var", "let", "const"]) && _.type === a.WORD && (this._flags.declaration_statement = !0) : _.newlines && !S(this._flags.mode) && (this._flags.last_token.type !== a.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++") && this._flags.last_token.type !== a.EQUALS && (this._options.preserve_newlines || !f(this._flags.last_token, ["var", "let", "const", "set", "get"])) ? (this.handle_whitespace_and_comments(_), this.print_newline()) : this.handle_whitespace_and_comments(_), this._flags.do_block && !this._flags.do_while)
      if (d(_, "while")) {
        this._output.space_before_token = !0, this.print_token(_), this._output.space_before_token = !0, this._flags.do_while = !0;
        return;
      } else
        this.print_newline(), this._flags.do_block = !1;
    if (this._flags.if_block)
      if (!this._flags.else_block && d(_, "else"))
        this._flags.else_block = !0;
      else {
        for (; this._flags.mode === g.Statement; )
          this.restore_mode();
        this._flags.if_block = !1, this._flags.else_block = !1;
      }
    if (this._flags.in_case_statement && f(_, ["case", "default"])) {
      this.print_newline(), !this._flags.case_block && (this._flags.case_body || this._options.jslint_happy) && this.deindent(), this._flags.case_body = !1, this.print_token(_), this._flags.in_case = !0;
      return;
    }
    if ((this._flags.last_token.type === a.COMMA || this._flags.last_token.type === a.START_EXPR || this._flags.last_token.type === a.EQUALS || this._flags.last_token.type === a.OPERATOR) && !this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators
    (l(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === g.ObjectLiteral) && this.allow_wrap_or_preserved_newline(_), d(_, "function")) {
      (l(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(l(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === a.OPERATOR)) && !this._output.just_added_blankline() && !_.comments_before && (this.print_newline(), this.print_newline(!0)), this._flags.last_token.type === a.RESERVED || this._flags.last_token.type === a.WORD ? f(this._flags.last_token, ["get", "set", "new", "export"]) || f(this._flags.last_token, A) ? this._output.space_before_token = !0 : d(this._flags.last_token, "default") && this._last_last_text === "export" ? this._output.space_before_token = !0 : this._flags.last_token.text === "declare" ? this._output.space_before_token = !0 : this.print_newline() : this._flags.last_token.type === a.OPERATOR || this._flags.last_token.text === "=" ? this._output.space_before_token = !0 : !this._flags.multiline_frame && (S(this._flags.mode) || w(this._flags.mode)) || this.print_newline(), this.print_token(_), this._flags.last_word = _.text;
      return;
    }
    var M = "NONE";
    if (this._flags.last_token.type === a.END_BLOCK ? this._previous_flags.inline_frame ? M = "SPACE" : f(_, ["else", "catch", "finally", "from"]) ? this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && _.newlines ? M = "NEWLINE" : (M = "SPACE", this._output.space_before_token = !0) : M = "NEWLINE" : this._flags.last_token.type === a.SEMICOLON && this._flags.mode === g.BlockStatement ? M = "NEWLINE" : this._flags.last_token.type === a.SEMICOLON && S(this._flags.mode) ? M = "SPACE" : this._flags.last_token.type === a.STRING ? M = "NEWLINE" : this._flags.last_token.type === a.RESERVED || this._flags.last_token.type === a.WORD || this._flags.last_token.text === "*" && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === g.ObjectLiteral && l(this._last_last_text, ["{", ","])) ? M = "SPACE" : this._flags.last_token.type === a.START_BLOCK ? this._flags.inline_frame ? M = "SPACE" : M = "NEWLINE" : this._flags.last_token.type === a.END_EXPR && (this._output.space_before_token = !0, M = "NEWLINE"), f(_, s) && this._flags.last_token.text !== ")" && (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export" ? M = "SPACE" : M = "NEWLINE"), f(_, ["else", "catch", "finally"]))
      if ((!(this._flags.last_token.type === a.END_BLOCK && this._previous_flags.mode === g.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && _.newlines) && !this._flags.inline_frame)
        this.print_newline();
      else {
        this._output.trim(!0);
        var z = this._output.current_line;
        z.last() !== "}" && this.print_newline(), this._output.space_before_token = !0;
      }
    else M === "NEWLINE" ? f(this._flags.last_token, h) ? this._output.space_before_token = !0 : this._flags.last_token.text === "declare" && f(_, ["var", "let", "const"]) ? this._output.space_before_token = !0 : this._flags.last_token.type !== a.END_EXPR ? (this._flags.last_token.type !== a.START_EXPR || !f(_, ["var", "let", "const"])) && this._flags.last_token.text !== ":" && (d(_, "if") && d(_.previous, "else") ? this._output.space_before_token = !0 : this.print_newline()) : f(_, s) && this._flags.last_token.text !== ")" && this.print_newline() : this._flags.multiline_frame && w(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}" ? this.print_newline() : M === "SPACE" && (this._output.space_before_token = !0);
    _.previous && (_.previous.type === a.WORD || _.previous.type === a.RESERVED) && (this._output.space_before_token = !0), this.print_token(_), this._flags.last_word = _.text, _.type === a.RESERVED && (_.text === "do" ? this._flags.do_block = !0 : _.text === "if" ? this._flags.if_block = !0 : _.text === "import" ? this._flags.import_block = !0 : this._flags.import_block && d(_, "from") && (this._flags.import_block = !1));
  }, y.prototype.handle_semicolon = function(_) {
    this.start_of_statement(_) ? this._output.space_before_token = !1 : this.handle_whitespace_and_comments(_);
    for (var T = this._tokens.peek(); this._flags.mode === g.Statement && !(this._flags.if_block && d(T, "else")) && !this._flags.do_block; )
      this.restore_mode();
    this._flags.import_block && (this._flags.import_block = !1), this.print_token(_);
  }, y.prototype.handle_string = function(_) {
    _.text.startsWith("`") && _.newlines === 0 && _.whitespace_before === "" && (_.previous.text === ")" || this._flags.last_token.type === a.WORD) || (this.start_of_statement(_) ? this._output.space_before_token = !0 : (this.handle_whitespace_and_comments(_), this._flags.last_token.type === a.RESERVED || this._flags.last_token.type === a.WORD || this._flags.inline_frame ? this._output.space_before_token = !0 : this._flags.last_token.type === a.COMMA || this._flags.last_token.type === a.START_EXPR || this._flags.last_token.type === a.EQUALS || this._flags.last_token.type === a.OPERATOR ? this.start_of_object_property() || this.allow_wrap_or_preserved_newline(_) : _.text.startsWith("`") && this._flags.last_token.type === a.END_EXPR && (_.previous.text === "]" || _.previous.text === ")") && _.newlines === 0 ? this._output.space_before_token = !0 : this.print_newline())), this.print_token(_);
  }, y.prototype.handle_equals = function(_) {
    this.start_of_statement(_) || this.handle_whitespace_and_comments(_), this._flags.declaration_statement && (this._flags.declaration_assignment = !0), this._output.space_before_token = !0, this.print_token(_), this._output.space_before_token = !0;
  }, y.prototype.handle_comma = function(_) {
    this.handle_whitespace_and_comments(_, !0), this.print_token(_), this._output.space_before_token = !0, this._flags.declaration_statement ? (S(this._flags.parent.mode) && (this._flags.declaration_assignment = !1), this._flags.declaration_assignment ? (this._flags.declaration_assignment = !1, this.print_newline(!1, !0)) : this._options.comma_first && this.allow_wrap_or_preserved_newline(_)) : this._flags.mode === g.ObjectLiteral || this._flags.mode === g.Statement && this._flags.parent.mode === g.ObjectLiteral ? (this._flags.mode === g.Statement && this.restore_mode(), this._flags.inline_frame || this.print_newline()) : this._options.comma_first && this.allow_wrap_or_preserved_newline(_);
  }, y.prototype.handle_operator = function(_) {
    var T = _.text === "*" && (f(this._flags.last_token, ["function", "yield"]) || l(this._flags.last_token.type, [a.START_BLOCK, a.COMMA, a.END_BLOCK, a.SEMICOLON])), M = l(_.text, ["-", "+"]) && (l(this._flags.last_token.type, [a.START_BLOCK, a.START_EXPR, a.EQUALS, a.OPERATOR]) || l(this._flags.last_token.text, s) || this._flags.last_token.text === ",");
    if (!this.start_of_statement(_)) {
      var z = !T;
      this.handle_whitespace_and_comments(_, z);
    }
    if (_.text === "*" && this._flags.last_token.type === a.DOT) {
      this.print_token(_);
      return;
    }
    if (_.text === "::") {
      this.print_token(_);
      return;
    }
    if (l(_.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(_);
      return;
    }
    if (this._flags.last_token.type === a.OPERATOR && l(this._options.operator_position, m) && this.allow_wrap_or_preserved_newline(_), _.text === ":" && this._flags.in_case) {
      this.print_token(_), this._flags.in_case = !1, this._flags.case_body = !0, this._tokens.peek().type !== a.START_BLOCK ? (this.indent(), this.print_newline(), this._flags.case_block = !1) : (this._flags.case_block = !0, this._output.space_before_token = !0);
      return;
    }
    var P = !0, V = !0, U = !1;
    if (_.text === ":" ? this._flags.ternary_depth === 0 ? P = !1 : (this._flags.ternary_depth -= 1, U = !0) : _.text === "?" && (this._flags.ternary_depth += 1), !M && !T && this._options.preserve_newlines && l(_.text, o)) {
      var J = _.text === ":", re = J && U, te = J && !U;
      switch (this._options.operator_position) {
        case b.before_newline:
          this._output.space_before_token = !te, this.print_token(_), (!J || re) && this.allow_wrap_or_preserved_newline(_), this._output.space_before_token = !0;
          return;
        case b.after_newline:
          this._output.space_before_token = !0, !J || re ? this._tokens.peek().newlines ? this.print_newline(!1, !0) : this.allow_wrap_or_preserved_newline(_) : this._output.space_before_token = !1, this.print_token(_), this._output.space_before_token = !0;
          return;
        case b.preserve_newline:
          te || this.allow_wrap_or_preserved_newline(_), P = !(this._output.just_added_newline() || te), this._output.space_before_token = P, this.print_token(_), this._output.space_before_token = !0;
          return;
      }
    }
    if (T) {
      this.allow_wrap_or_preserved_newline(_), P = !1;
      var ge = this._tokens.peek();
      V = ge && l(ge.type, [a.WORD, a.RESERVED]);
    } else if (_.text === "...")
      this.allow_wrap_or_preserved_newline(_), P = this._flags.last_token.type === a.START_BLOCK, V = !1;
    else if (l(_.text, ["--", "++", "!", "~"]) || M) {
      if ((this._flags.last_token.type === a.COMMA || this._flags.last_token.type === a.START_EXPR) && this.allow_wrap_or_preserved_newline(_), P = !1, V = !1, _.newlines && (_.text === "--" || _.text === "++" || _.text === "~")) {
        var se = f(this._flags.last_token, h) && _.newlines;
        se && (this._previous_flags.if_block || this._previous_flags.else_block) && this.restore_mode(), this.print_newline(se, !0);
      }
      this._flags.last_token.text === ";" && S(this._flags.mode) && (P = !0), this._flags.last_token.type === a.RESERVED ? P = !0 : this._flags.last_token.type === a.END_EXPR ? P = !(this._flags.last_token.text === "]" && (_.text === "--" || _.text === "++")) : this._flags.last_token.type === a.OPERATOR && (P = l(_.text, ["--", "-", "++", "+"]) && l(this._flags.last_token.text, ["--", "-", "++", "+"]), l(_.text, ["+", "-"]) && l(this._flags.last_token.text, ["--", "++"]) && (V = !0)), (this._flags.mode === g.BlockStatement && !this._flags.inline_frame || this._flags.mode === g.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";") && this.print_newline();
    }
    this._output.space_before_token = this._output.space_before_token || P, this.print_token(_), this._output.space_before_token = V;
  }, y.prototype.handle_block_comment = function(_, T) {
    if (this._output.raw) {
      this._output.add_raw_token(_), _.directives && _.directives.preserve === "end" && (this._output.raw = this._options.test_output_raw);
      return;
    }
    if (_.directives) {
      this.print_newline(!1, T), this.print_token(_), _.directives.preserve === "start" && (this._output.raw = !0), this.print_newline(!1, !0);
      return;
    }
    if (!t.newline.test(_.text) && !_.newlines) {
      this._output.space_before_token = !0, this.print_token(_), this._output.space_before_token = !0;
      return;
    } else
      this.print_block_commment(_, T);
  }, y.prototype.print_block_commment = function(_, T) {
    var M = x(_.text), z, P = !1, V = !1, U = _.whitespace_before, J = U.length;
    if (this.print_newline(!1, T), this.print_token_line_indentation(_), this._output.add_token(M[0]), this.print_newline(!1, T), M.length > 1) {
      for (M = M.slice(1), P = k(M, "*"), V = C(M, U), P && (this._flags.alignment = 1), z = 0; z < M.length; z++)
        P ? (this.print_token_line_indentation(_), this._output.add_token(c(M[z]))) : V && M[z] ? (this.print_token_line_indentation(_), this._output.add_token(M[z].substring(J))) : (this._output.current_line.set_indent(-1), this._output.add_token(M[z])), this.print_newline(!1, T);
      this._flags.alignment = 0;
    }
  }, y.prototype.handle_comment = function(_, T) {
    _.newlines ? this.print_newline(!1, T) : this._output.trim(!0), this._output.space_before_token = !0, this.print_token(_), this.print_newline(!1, T);
  }, y.prototype.handle_dot = function(_) {
    this.start_of_statement(_) || this.handle_whitespace_and_comments(_, !0), this._flags.last_token.text.match("^[0-9]+$") && (this._output.space_before_token = !0), f(this._flags.last_token, h) ? this._output.space_before_token = !1 : this.allow_wrap_or_preserved_newline(
      _,
      this._flags.last_token.text === ")" && this._options.break_chained_methods
    ), this._options.unindent_chained_methods && this._output.just_added_newline() && this.deindent(), this.print_token(_);
  }, y.prototype.handle_unknown = function(_, T) {
    this.print_token(_), _.text[_.text.length - 1] === `
` && this.print_newline(!1, T);
  }, y.prototype.handle_eof = function(_) {
    for (; this._flags.mode === g.Statement; )
      this.restore_mode();
    this.handle_whitespace_and_comments(_);
  }, Yl.Beautifier = y, Yl;
}
var Mh;
function nk() {
  if (Mh) return Co.exports;
  Mh = 1;
  var n = tk().Beautifier, e = g_().Options;
  function t(i, r) {
    var s = new n(i, r);
    return s.beautify();
  }
  return Co.exports = t, Co.exports.defaultOptions = function() {
    return new e();
  }, Co.exports;
}
var Ao = { exports: {} }, lc = {}, cc = {}, Oh;
function b_() {
  if (Oh) return cc;
  Oh = 1;
  var n = _d().Options;
  function e(t) {
    n.call(this, t, "css"), this.selector_separator_newline = this._get_boolean("selector_separator_newline", !0), this.newline_between_rules = this._get_boolean("newline_between_rules", !0);
    var i = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || i;
    var r = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var s = 0; s < r.length; s++)
      r[s] !== "expand" ? this.brace_style = "collapse" : this.brace_style = r[s];
  }
  return e.prototype = new n(), cc.Options = e, cc;
}
var Nh;
function ik() {
  if (Nh) return lc;
  Nh = 1;
  var n = b_().Options, e = gd().Output, t = bd().InputScanner, i = vd().Directives, r = new i(/\/\*/, /\*\//), s = /\r\n|[\r\n]/, o = /\r\n|[\r\n]/g, a = /\s/, l = /(?:\s|\n)+/g, c = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g, u = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  function d(f, h) {
    this._source_text = f || "", this._options = new n(h), this._ch = null, this._input = null, this.NESTED_AT_RULE = {
      page: !0,
      "font-face": !0,
      keyframes: !0,
      // also in CONDITIONAL_GROUP_RULE below
      media: !0,
      supports: !0,
      document: !0
    }, this.CONDITIONAL_GROUP_RULE = {
      media: !0,
      supports: !0,
      document: !0
    }, this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  }
  return d.prototype.eatString = function(f) {
    var h = "";
    for (this._ch = this._input.next(); this._ch; ) {
      if (h += this._ch, this._ch === "\\")
        h += this._input.next();
      else if (f.indexOf(this._ch) !== -1 || this._ch === `
`)
        break;
      this._ch = this._input.next();
    }
    return h;
  }, d.prototype.eatWhitespace = function(f) {
    for (var h = a.test(this._input.peek()), p = 0; a.test(this._input.peek()); )
      this._ch = this._input.next(), f && this._ch === `
` && (p === 0 || p < this._options.max_preserve_newlines) && (p++, this._output.add_new_line(!0));
    return h;
  }, d.prototype.foundNestedPseudoClass = function() {
    for (var f = 0, h = 1, p = this._input.peek(h); p; ) {
      if (p === "{")
        return !0;
      if (p === "(")
        f += 1;
      else if (p === ")") {
        if (f === 0)
          return !1;
        f -= 1;
      } else if (p === ";" || p === "}")
        return !1;
      h++, p = this._input.peek(h);
    }
    return !1;
  }, d.prototype.print_string = function(f) {
    this._output.set_indent(this._indentLevel), this._output.non_breaking_space = !0, this._output.add_token(f);
  }, d.prototype.preserveSingleSpace = function(f) {
    f && (this._output.space_before_token = !0);
  }, d.prototype.indent = function() {
    this._indentLevel++;
  }, d.prototype.outdent = function() {
    this._indentLevel > 0 && this._indentLevel--;
  }, d.prototype.beautify = function() {
    if (this._options.disabled)
      return this._source_text;
    var f = this._source_text, h = this._options.eol;
    h === "auto" && (h = `
`, f && s.test(f || "") && (h = f.match(s)[0])), f = f.replace(o, `
`);
    var p = f.match(/^[\t ]*/)[0];
    this._output = new e(this._options, p), this._input = new t(f), this._indentLevel = 0, this._nestedLevel = 0, this._ch = null;
    for (var b = 0, m = !1, g = !1, v = !1, x = !1, w = !1, S = this._ch, k = !1, C, y, A; C = this._input.read(l), y = C !== "", A = S, this._ch = this._input.next(), this._ch === "\\" && this._input.hasNext() && (this._ch += this._input.next()), S = this._ch, this._ch; )
      if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line(), this._input.back();
        var _ = this._input.read(c), T = r.get_directives(_);
        T && T.ignore === "start" && (_ += r.readIgnored(this._input)), this.print_string(_), this.eatWhitespace(!0), this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/")
        this._output.space_before_token = !0, this._input.back(), this.print_string(this._input.read(u)), this.eatWhitespace(!0);
      else if (this._ch === "$") {
        this.preserveSingleSpace(y), this.print_string(this._ch);
        var M = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        M.match(/[ :]$/) && (M = this.eatString(": ").replace(/\s+$/, ""), this.print_string(M), this._output.space_before_token = !0), b === 0 && M.indexOf(":") !== -1 && (g = !0, this.indent());
      } else if (this._ch === "@")
        if (this.preserveSingleSpace(y), this._input.peek() === "{")
          this.print_string(this._ch + this.eatString("}"));
        else {
          this.print_string(this._ch);
          var z = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          z.match(/[ :]$/) && (z = this.eatString(": ").replace(/\s+$/, ""), this.print_string(z), this._output.space_before_token = !0), b === 0 && z.indexOf(":") !== -1 ? (g = !0, this.indent()) : z in this.NESTED_AT_RULE ? (this._nestedLevel += 1, z in this.CONDITIONAL_GROUP_RULE && (v = !0)) : b === 0 && !g && (x = !0);
        }
      else if (this._ch === "#" && this._input.peek() === "{")
        this.preserveSingleSpace(y), this.print_string(this._ch + this.eatString("}"));
      else if (this._ch === "{")
        g && (g = !1, this.outdent()), x = !1, v ? (v = !1, m = this._indentLevel >= this._nestedLevel) : m = this._indentLevel >= this._nestedLevel - 1, this._options.newline_between_rules && m && this._output.previous_line && this._output.previous_line.item(-1) !== "{" && this._output.ensure_empty_line_above("/", ","), this._output.space_before_token = !0, this._options.brace_style === "expand" ? (this._output.add_new_line(), this.print_string(this._ch), this.indent(), this._output.set_indent(this._indentLevel)) : (A === "(" ? this._output.space_before_token = !1 : A !== "," && this.indent(), this.print_string(this._ch)), this.eatWhitespace(!0), this._output.add_new_line();
      else if (this._ch === "}")
        this.outdent(), this._output.add_new_line(), A === "{" && this._output.trim(!0), g && (this.outdent(), g = !1), this.print_string(this._ch), m = !1, this._nestedLevel && this._nestedLevel--, this.eatWhitespace(!0), this._output.add_new_line(), this._options.newline_between_rules && !this._output.just_added_blankline() && this._input.peek() !== "}" && this._output.add_new_line(!0), this._input.peek() === ")" && (this._output.trim(!0), this._options.brace_style === "expand" && this._output.add_new_line(!0));
      else if (this._ch === ":") {
        for (var P = 0; P < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; P++)
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[P])) {
            k = !0;
            break;
          }
        (m || v) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !x && b === 0 ? (this.print_string(":"), g || (g = !0, this._output.space_before_token = !0, this.eatWhitespace(!0), this.indent())) : (this._input.lookBack(" ") && (this._output.space_before_token = !0), this._input.peek() === ":" ? (this._ch = this._input.next(), this.print_string("::")) : this.print_string(":"));
      } else if (this._ch === '"' || this._ch === "'") {
        var V = A === '"' || A === "'";
        this.preserveSingleSpace(V || y), this.print_string(this._ch + this.eatString(this._ch)), this.eatWhitespace(!0);
      } else if (this._ch === ";")
        k = !1, b === 0 ? (g && (this.outdent(), g = !1), x = !1, this.print_string(this._ch), this.eatWhitespace(!0), this._input.peek() !== "/" && this._output.add_new_line()) : (this.print_string(this._ch), this.eatWhitespace(!0), this._output.space_before_token = !0);
      else if (this._ch === "(")
        if (this._input.lookBack("url"))
          this.print_string(this._ch), this.eatWhitespace(), b++, this.indent(), this._ch = this._input.next(), this._ch === ")" || this._ch === '"' || this._ch === "'" ? this._input.back() : this._ch && (this.print_string(this._ch + this.eatString(")")), b && (b--, this.outdent()));
        else {
          var U = !1;
          this._input.lookBack("with") && (U = !0), this.preserveSingleSpace(y || U), this.print_string(this._ch), g && A === "$" && this._options.selector_separator_newline ? (this._output.add_new_line(), w = !0) : (this.eatWhitespace(), b++, this.indent());
        }
      else if (this._ch === ")")
        b && (b--, this.outdent()), w && this._input.peek() === ";" && this._options.selector_separator_newline && (w = !1, this.outdent(), this._output.add_new_line()), this.print_string(this._ch);
      else if (this._ch === ",")
        this.print_string(this._ch), this.eatWhitespace(!0), this._options.selector_separator_newline && (!g || w) && b === 0 && !x ? this._output.add_new_line() : this._output.space_before_token = !0;
      else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !g && b === 0)
        this._options.space_around_combinator ? (this._output.space_before_token = !0, this.print_string(this._ch), this._output.space_before_token = !0) : (this.print_string(this._ch), this.eatWhitespace(), this._ch && a.test(this._ch) && (this._ch = ""));
      else if (this._ch === "]")
        this.print_string(this._ch);
      else if (this._ch === "[")
        this.preserveSingleSpace(y), this.print_string(this._ch);
      else if (this._ch === "=")
        this.eatWhitespace(), this.print_string("="), a.test(this._ch) && (this._ch = "");
      else if (this._ch === "!" && !this._input.lookBack("\\"))
        this._output.space_before_token = !0, this.print_string(this._ch);
      else {
        var J = A === '"' || A === "'";
        this.preserveSingleSpace(J || y), this.print_string(this._ch), !this._output.just_added_newline() && this._input.peek() === `
` && k && this._output.add_new_line();
      }
    var re = this._output.get_code(h);
    return re;
  }, lc.Beautifier = d, lc;
}
var Lh;
function rk() {
  if (Lh) return Ao.exports;
  Lh = 1;
  var n = ik().Beautifier, e = b_().Options;
  function t(i, r) {
    var s = new n(i, r);
    return s.beautify();
  }
  return Ao.exports = t, Ao.exports.defaultOptions = function() {
    return new e();
  }, Ao.exports;
}
var Mo = { exports: {} }, uc = {}, dc = {}, Rh;
function v_() {
  if (Rh) return dc;
  Rh = 1;
  var n = _d().Options;
  function e(t) {
    n.call(this, t, "html"), this.templating.length === 1 && this.templating[0] === "auto" && (this.templating = ["django", "erb", "handlebars", "php"]), this.indent_inner_html = this._get_boolean("indent_inner_html"), this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", !0), this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", !0), this.indent_handlebars = this._get_boolean("indent_handlebars", !0), this.wrap_attributes = this._get_selection(
      "wrap_attributes",
      ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]
    ), this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2), this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size), this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]), this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      /* 'script', */
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      // obsolete inline tags
      "acronym",
      "big",
      "strike",
      "tt"
    ]), this.inline_custom_elements = this._get_boolean("inline_custom_elements", !0), this.void_elements = this._get_array("void_elements", [
      // HTLM void elements - aka self-closing tags - aka singletons
      // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      // NOTE: Optional tags are too complex for a simple list
      // they are hard coded in _do_optional_end_element
      // Doctype and xml elements
      "!doctype",
      "?xml",
      // obsolete tags
      // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
      // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
      "basefont",
      "isindex"
    ]), this.unformatted = this._get_array("unformatted", []), this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]), this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter"), this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  }
  return e.prototype = new n(), dc.Options = e, dc;
}
var Oo = {}, Ih;
function Ph() {
  if (Ih) return Oo;
  Ih = 1;
  var n = va().Tokenizer, e = va().TOKEN, t = vd().Directives, i = __().TemplatablePattern, r = vl().Pattern, s = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    CONTROL_FLOW_OPEN: "TK_CONTROL_FLOW_OPEN",
    CONTROL_FLOW_CLOSE: "TK_CONTROL_FLOW_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: e.START,
    RAW: e.RAW,
    EOF: e.EOF
  }, o = new t(/<\!--/, /-->/), a = function(l, c) {
    n.call(this, l, c), this._current_tag_name = "";
    var u = new i(this._input).read_options(this._options), d = new r(this._input);
    if (this.__patterns = {
      word: u.until(/[\n\r\t <]/),
      word_control_flow_close_excluded: u.until(/[\n\r\t <}]/),
      single_quote: u.until_after(/'/),
      double_quote: u.until_after(/"/),
      attribute: u.until(/[\n\r\t =>]|\/>/),
      element_name: u.until(/[\n\r\t >\/]/),
      angular_control_flow_start: d.matching(/\@[a-zA-Z]+[^({]*[({]/),
      handlebars_comment: d.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: d.starting_with(/{{/).until_after(/}}/),
      handlebars_open: d.until(/[\n\r\t }]/),
      handlebars_raw_close: d.until(/}}/),
      comment: d.starting_with(/<!--/).until_after(/-->/),
      cdata: d.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      // https://en.wikipedia.org/wiki/Conditional_comment
      conditional_comment: d.starting_with(/<!\[/).until_after(/]>/),
      processing: d.starting_with(/<\?/).until_after(/\?>/)
    }, this._options.indent_handlebars && (this.__patterns.word = this.__patterns.word.exclude("handlebars"), this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude("handlebars")), this._unformatted_content_delimiter = null, this._options.unformatted_content_delimiter) {
      var f = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = d.matching(f).until_after(f);
    }
  };
  return a.prototype = new n(), a.prototype._is_comment = function(l) {
    return !1;
  }, a.prototype._is_opening = function(l) {
    return l.type === s.TAG_OPEN || l.type === s.CONTROL_FLOW_OPEN;
  }, a.prototype._is_closing = function(l, c) {
    return l.type === s.TAG_CLOSE && c && ((l.text === ">" || l.text === "/>") && c.text[0] === "<" || l.text === "}}" && c.text[0] === "{" && c.text[1] === "{") || l.type === s.CONTROL_FLOW_CLOSE && l.text === "}" && c.text.endsWith("{");
  }, a.prototype._reset = function() {
    this._current_tag_name = "";
  }, a.prototype._get_next_token = function(l, c) {
    var u = null;
    this._readWhitespace();
    var d = this._input.peek();
    return d === null ? this._create_token(s.EOF, "") : (u = u || this._read_open_handlebars(d, c), u = u || this._read_attribute(d, l, c), u = u || this._read_close(d, c), u = u || this._read_script_and_style(d, l), u = u || this._read_control_flows(d, c), u = u || this._read_raw_content(d, l, c), u = u || this._read_content_word(d, c), u = u || this._read_comment_or_cdata(d), u = u || this._read_processing(d), u = u || this._read_open(d, c), u = u || this._create_token(s.UNKNOWN, this._input.next()), u);
  }, a.prototype._read_comment_or_cdata = function(l) {
    var c = null, u = null, d = null;
    if (l === "<") {
      var f = this._input.peek(1);
      f === "!" && (u = this.__patterns.comment.read(), u ? (d = o.get_directives(u), d && d.ignore === "start" && (u += o.readIgnored(this._input))) : u = this.__patterns.cdata.read()), u && (c = this._create_token(s.COMMENT, u), c.directives = d);
    }
    return c;
  }, a.prototype._read_processing = function(l) {
    var c = null, u = null, d = null;
    if (l === "<") {
      var f = this._input.peek(1);
      (f === "!" || f === "?") && (u = this.__patterns.conditional_comment.read(), u = u || this.__patterns.processing.read()), u && (c = this._create_token(s.COMMENT, u), c.directives = d);
    }
    return c;
  }, a.prototype._read_open = function(l, c) {
    var u = null, d = null;
    return (!c || c.type === s.CONTROL_FLOW_OPEN) && l === "<" && (u = this._input.next(), this._input.peek() === "/" && (u += this._input.next()), u += this.__patterns.element_name.read(), d = this._create_token(s.TAG_OPEN, u)), d;
  }, a.prototype._read_open_handlebars = function(l, c) {
    var u = null, d = null;
    return (!c || c.type === s.CONTROL_FLOW_OPEN) && (this._options.templating.includes("angular") || this._options.indent_handlebars) && l === "{" && this._input.peek(1) === "{" && (this._options.indent_handlebars && this._input.peek(2) === "!" ? (u = this.__patterns.handlebars_comment.read(), u = u || this.__patterns.handlebars.read(), d = this._create_token(s.COMMENT, u)) : (u = this.__patterns.handlebars_open.read(), d = this._create_token(s.TAG_OPEN, u))), d;
  }, a.prototype._read_control_flows = function(l, c) {
    var u = "", d = null;
    if (!this._options.templating.includes("angular"))
      return d;
    if (l === "@") {
      if (u = this.__patterns.angular_control_flow_start.read(), u === "")
        return d;
      for (var f = u.endsWith("(") ? 1 : 0, h = 0; !(u.endsWith("{") && f === h); ) {
        var p = this._input.next();
        if (p === null)
          break;
        p === "(" ? f++ : p === ")" && h++, u += p;
      }
      d = this._create_token(s.CONTROL_FLOW_OPEN, u);
    } else l === "}" && c && c.type === s.CONTROL_FLOW_OPEN && (u = this._input.next(), d = this._create_token(s.CONTROL_FLOW_CLOSE, u));
    return d;
  }, a.prototype._read_close = function(l, c) {
    var u = null, d = null;
    return c && c.type === s.TAG_OPEN && (c.text[0] === "<" && (l === ">" || l === "/" && this._input.peek(1) === ">") ? (u = this._input.next(), l === "/" && (u += this._input.next()), d = this._create_token(s.TAG_CLOSE, u)) : c.text[0] === "{" && l === "}" && this._input.peek(1) === "}" && (this._input.next(), this._input.next(), d = this._create_token(s.TAG_CLOSE, "}}"))), d;
  }, a.prototype._read_attribute = function(l, c, u) {
    var d = null, f = "";
    if (u && u.text[0] === "<")
      if (l === "=")
        d = this._create_token(s.EQUALS, this._input.next());
      else if (l === '"' || l === "'") {
        var h = this._input.next();
        l === '"' ? h += this.__patterns.double_quote.read() : h += this.__patterns.single_quote.read(), d = this._create_token(s.VALUE, h);
      } else
        f = this.__patterns.attribute.read(), f && (c.type === s.EQUALS ? d = this._create_token(s.VALUE, f) : d = this._create_token(s.ATTRIBUTE, f));
    return d;
  }, a.prototype._is_content_unformatted = function(l) {
    return this._options.void_elements.indexOf(l) === -1 && (this._options.content_unformatted.indexOf(l) !== -1 || this._options.unformatted.indexOf(l) !== -1);
  }, a.prototype._read_raw_content = function(l, c, u) {
    var d = "";
    if (u && u.text[0] === "{")
      d = this.__patterns.handlebars_raw_close.read();
    else if (c.type === s.TAG_CLOSE && c.opened.text[0] === "<" && c.text[0] !== "/") {
      var f = c.opened.text.substr(1).toLowerCase();
      this._is_content_unformatted(f) && (d = this._input.readUntil(new RegExp("</" + f + "[\\n\\r\\t ]*?>", "ig")));
    }
    return d ? this._create_token(s.TEXT, d) : null;
  }, a.prototype._read_script_and_style = function(l, c) {
    if (c.type === s.TAG_CLOSE && c.opened.text[0] === "<" && c.text[0] !== "/") {
      var u = c.opened.text.substr(1).toLowerCase();
      if (u === "script" || u === "style") {
        var d = this._read_comment_or_cdata(l);
        if (d)
          return d.type = s.TEXT, d;
        var f = this._input.readUntil(new RegExp("</" + u + "[\\n\\r\\t ]*?>", "ig"));
        if (f)
          return this._create_token(s.TEXT, f);
      }
    }
    return null;
  }, a.prototype._read_content_word = function(l, c) {
    var u = "";
    return this._options.unformatted_content_delimiter && l === this._options.unformatted_content_delimiter[0] && (u = this.__patterns.unformatted_content_delimiter.read()), u || (u = c && c.type === s.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read()), u ? this._create_token(s.TEXT, u) : null;
  }, Oo.Tokenizer = a, Oo.TOKEN = s, Oo;
}
var Dh;
function sk() {
  if (Dh) return uc;
  Dh = 1;
  var n = v_().Options, e = gd().Output, t = Ph().Tokenizer, i = Ph().TOKEN, r = /\r\n|[\r\n]/, s = /\r\n|[\r\n]/g, o = function(m, g) {
    this.indent_level = 0, this.alignment_size = 0, this.max_preserve_newlines = m.max_preserve_newlines, this.preserve_newlines = m.preserve_newlines, this._output = new e(m, g);
  };
  o.prototype.current_line_has_match = function(m) {
    return this._output.current_line.has_match(m);
  }, o.prototype.set_space_before_token = function(m, g) {
    this._output.space_before_token = m, this._output.non_breaking_space = g;
  }, o.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size), this._output.set_wrap_point();
  }, o.prototype.add_raw_token = function(m) {
    this._output.add_raw_token(m);
  }, o.prototype.print_preserved_newlines = function(m) {
    var g = 0;
    m.type !== i.TEXT && m.previous.type !== i.TEXT && (g = m.newlines ? 1 : 0), this.preserve_newlines && (g = m.newlines < this.max_preserve_newlines + 1 ? m.newlines : this.max_preserve_newlines + 1);
    for (var v = 0; v < g; v++)
      this.print_newline(v > 0);
    return g !== 0;
  }, o.prototype.traverse_whitespace = function(m) {
    return m.whitespace_before || m.newlines ? (this.print_preserved_newlines(m) || (this._output.space_before_token = !0), !0) : !1;
  }, o.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  }, o.prototype.print_newline = function(m) {
    this._output.add_new_line(m);
  }, o.prototype.print_token = function(m) {
    m.text && (this._output.set_indent(this.indent_level, this.alignment_size), this._output.add_token(m.text));
  }, o.prototype.indent = function() {
    this.indent_level++;
  }, o.prototype.deindent = function() {
    this.indent_level > 0 && (this.indent_level--, this._output.set_indent(this.indent_level, this.alignment_size));
  }, o.prototype.get_full_indent = function(m) {
    return m = this.indent_level + (m || 0), m < 1 ? "" : this._output.get_indent_string(m);
  };
  var a = function(m) {
    for (var g = null, v = m.next; v.type !== i.EOF && m.closed !== v; ) {
      if (v.type === i.ATTRIBUTE && v.text === "type") {
        v.next && v.next.type === i.EQUALS && v.next.next && v.next.next.type === i.VALUE && (g = v.next.next.text);
        break;
      }
      v = v.next;
    }
    return g;
  }, l = function(m, g) {
    var v = null, x = null;
    return g.closed ? (m === "script" ? v = "text/javascript" : m === "style" && (v = "text/css"), v = a(g) || v, v.search("text/css") > -1 ? x = "css" : v.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1 ? x = "javascript" : v.search(/(text|application|dojo)\/(x-)?(html)/) > -1 ? x = "html" : v.search(/test\/null/) > -1 && (x = "null"), x) : null;
  };
  function c(m, g) {
    return g.indexOf(m) !== -1;
  }
  function u(m, g, v) {
    this.parent = m || null, this.tag = g ? g.tag_name : "", this.indent_level = v || 0, this.parser_token = g || null;
  }
  function d(m) {
    this._printer = m, this._current_frame = null;
  }
  d.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  }, d.prototype.record_tag = function(m) {
    var g = new u(this._current_frame, m, this._printer.indent_level);
    this._current_frame = g;
  }, d.prototype._try_pop_frame = function(m) {
    var g = null;
    return m && (g = m.parser_token, this._printer.indent_level = m.indent_level, this._current_frame = m.parent), g;
  }, d.prototype._get_frame = function(m, g) {
    for (var v = this._current_frame; v && m.indexOf(v.tag) === -1; ) {
      if (g && g.indexOf(v.tag) !== -1) {
        v = null;
        break;
      }
      v = v.parent;
    }
    return v;
  }, d.prototype.try_pop = function(m, g) {
    var v = this._get_frame([m], g);
    return this._try_pop_frame(v);
  }, d.prototype.indent_to_tag = function(m) {
    var g = this._get_frame(m);
    g && (this._printer.indent_level = g.indent_level);
  };
  function f(m, g, v, x) {
    this._source_text = m || "", g = g || {}, this._js_beautify = v, this._css_beautify = x, this._tag_stack = null;
    var w = new n(g, "html");
    this._options = w, this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 5) === "force", this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline", this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned", this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple", this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 8) === "preserve", this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  }
  f.prototype.beautify = function() {
    if (this._options.disabled)
      return this._source_text;
    var m = this._source_text, g = this._options.eol;
    this._options.eol === "auto" && (g = `
`, m && r.test(m) && (g = m.match(r)[0])), m = m.replace(s, `
`);
    var v = m.match(/^[\t ]*/)[0], x = {
      text: "",
      type: ""
    }, w = new h(this._options), S = new o(this._options, v), k = new t(m, this._options).tokenize();
    this._tag_stack = new d(S);
    for (var C = null, y = k.next(); y.type !== i.EOF; )
      y.type === i.TAG_OPEN || y.type === i.COMMENT ? (C = this._handle_tag_open(S, y, w, x, k), w = C) : y.type === i.ATTRIBUTE || y.type === i.EQUALS || y.type === i.VALUE || y.type === i.TEXT && !w.tag_complete ? C = this._handle_inside_tag(S, y, w, x) : y.type === i.TAG_CLOSE ? C = this._handle_tag_close(S, y, w) : y.type === i.TEXT ? C = this._handle_text(S, y, w) : y.type === i.CONTROL_FLOW_OPEN ? C = this._handle_control_flow_open(S, y) : y.type === i.CONTROL_FLOW_CLOSE ? C = this._handle_control_flow_close(S, y) : S.add_raw_token(y), x = C, y = k.next();
    var A = S._output.get_code(g);
    return A;
  }, f.prototype._handle_control_flow_open = function(m, g) {
    var v = {
      text: g.text,
      type: g.type
    };
    return m.set_space_before_token(g.newlines || g.whitespace_before !== "", !0), g.newlines ? m.print_preserved_newlines(g) : m.set_space_before_token(g.newlines || g.whitespace_before !== "", !0), m.print_token(g), m.indent(), v;
  }, f.prototype._handle_control_flow_close = function(m, g) {
    var v = {
      text: g.text,
      type: g.type
    };
    return m.deindent(), g.newlines ? m.print_preserved_newlines(g) : m.set_space_before_token(g.newlines || g.whitespace_before !== "", !0), m.print_token(g), v;
  }, f.prototype._handle_tag_close = function(m, g, v) {
    var x = {
      text: g.text,
      type: g.type
    };
    return m.alignment_size = 0, v.tag_complete = !0, m.set_space_before_token(g.newlines || g.whitespace_before !== "", !0), v.is_unformatted ? m.add_raw_token(g) : (v.tag_start_char === "<" && (m.set_space_before_token(g.text[0] === "/", !0), this._is_wrap_attributes_force_expand_multiline && v.has_wrapped_attrs && m.print_newline(!1)), m.print_token(g)), v.indent_content && !(v.is_unformatted || v.is_content_unformatted) && (m.indent(), v.indent_content = !1), !v.is_inline_element && !(v.is_unformatted || v.is_content_unformatted) && m.set_wrap_point(), x;
  }, f.prototype._handle_inside_tag = function(m, g, v, x) {
    var w = v.has_wrapped_attrs, S = {
      text: g.text,
      type: g.type
    };
    return m.set_space_before_token(g.newlines || g.whitespace_before !== "", !0), v.is_unformatted ? m.add_raw_token(g) : v.tag_start_char === "{" && g.type === i.TEXT ? m.print_preserved_newlines(g) ? (g.newlines = 0, m.add_raw_token(g)) : m.print_token(g) : (g.type === i.ATTRIBUTE ? m.set_space_before_token(!0) : (g.type === i.EQUALS || g.type === i.VALUE && g.previous.type === i.EQUALS) && m.set_space_before_token(!1), g.type === i.ATTRIBUTE && v.tag_start_char === "<" && ((this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) && (m.traverse_whitespace(g), w = w || g.newlines !== 0), this._is_wrap_attributes_force && v.attr_count >= this._options.wrap_attributes_min_attrs && (x.type !== i.TAG_OPEN || // ie. second attribute and beyond
    this._is_wrap_attributes_force_expand_multiline) && (m.print_newline(!1), w = !0)), m.print_token(g), w = w || m.previous_token_wrapped(), v.has_wrapped_attrs = w), S;
  }, f.prototype._handle_text = function(m, g, v) {
    var x = {
      text: g.text,
      type: "TK_CONTENT"
    };
    return v.custom_beautifier_name ? this._print_custom_beatifier_text(m, g, v) : v.is_unformatted || v.is_content_unformatted ? m.add_raw_token(g) : (m.traverse_whitespace(g), m.print_token(g)), x;
  }, f.prototype._print_custom_beatifier_text = function(m, g, v) {
    var x = this;
    if (g.text !== "") {
      var w = g.text, S, k = 1, C = "", y = "";
      v.custom_beautifier_name === "javascript" && typeof this._js_beautify == "function" ? S = this._js_beautify : v.custom_beautifier_name === "css" && typeof this._css_beautify == "function" ? S = this._css_beautify : v.custom_beautifier_name === "html" && (S = function(P, V) {
        var U = new f(P, V, x._js_beautify, x._css_beautify);
        return U.beautify();
      }), this._options.indent_scripts === "keep" ? k = 0 : this._options.indent_scripts === "separate" && (k = -m.indent_level);
      var A = m.get_full_indent(k);
      if (w = w.replace(/\n[ \t]*$/, ""), v.custom_beautifier_name !== "html" && w[0] === "<" && w.match(/^(<!--|<!\[CDATA\[)/)) {
        var _ = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(w);
        if (!_) {
          m.add_raw_token(g);
          return;
        }
        C = A + _[1] + `
`, w = _[4], _[5] && (y = A + _[5]), w = w.replace(/\n[ \t]*$/, ""), (_[2] || _[3].indexOf(`
`) !== -1) && (_ = _[3].match(/[ \t]+$/), _ && (g.whitespace_before = _[0]));
      }
      if (w)
        if (S) {
          var T = function() {
            this.eol = `
`;
          };
          T.prototype = this._options.raw_options;
          var M = new T();
          w = S(A + w, M);
        } else {
          var z = g.whitespace_before;
          z && (w = w.replace(new RegExp(`
(` + z + ")?", "g"), `
`)), w = A + w.replace(/\n/g, `
` + A);
        }
      C && (w ? w = C + w + `
` + y : w = C + y), m.print_newline(!1), w && (g.text = w, g.whitespace_before = "", g.newlines = 0, m.add_raw_token(g), m.print_newline(!0));
    }
  }, f.prototype._handle_tag_open = function(m, g, v, x, w) {
    var S = this._get_tag_open_token(g);
    if ((v.is_unformatted || v.is_content_unformatted) && !v.is_empty_element && g.type === i.TAG_OPEN && !S.is_start_tag ? (m.add_raw_token(g), S.start_tag_token = this._tag_stack.try_pop(S.tag_name)) : (m.traverse_whitespace(g), this._set_tag_position(m, g, S, v, x), S.is_inline_element || m.set_wrap_point(), m.print_token(g)), S.is_start_tag && this._is_wrap_attributes_force) {
      var k = 0, C;
      do
        C = w.peek(k), C.type === i.ATTRIBUTE && (S.attr_count += 1), k += 1;
      while (C.type !== i.EOF && C.type !== i.TAG_CLOSE);
    }
    return (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) && (S.alignment_size = g.text.length + 1), !S.tag_complete && !S.is_unformatted && (m.alignment_size = S.alignment_size), S;
  };
  var h = function(m, g, v) {
    if (this.parent = g || null, this.text = "", this.type = "TK_TAG_OPEN", this.tag_name = "", this.is_inline_element = !1, this.is_unformatted = !1, this.is_content_unformatted = !1, this.is_empty_element = !1, this.is_start_tag = !1, this.is_end_tag = !1, this.indent_content = !1, this.multiline_content = !1, this.custom_beautifier_name = null, this.start_tag_token = null, this.attr_count = 0, this.has_wrapped_attrs = !1, this.alignment_size = 0, this.tag_complete = !1, this.tag_start_char = "", this.tag_check = "", !v)
      this.tag_complete = !0;
    else {
      var x;
      this.tag_start_char = v.text[0], this.text = v.text, this.tag_start_char === "<" ? (x = v.text.match(/^<([^\s>]*)/), this.tag_check = x ? x[1] : "") : (x = v.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/), this.tag_check = x ? x[1] : "", (v.text.startsWith("{{#>") || v.text.startsWith("{{~#>")) && this.tag_check[0] === ">" && (this.tag_check === ">" && v.next !== null ? this.tag_check = v.next.text.split(" ")[0] : this.tag_check = v.text.split(">")[1])), this.tag_check = this.tag_check.toLowerCase(), v.type === i.COMMENT && (this.tag_complete = !0), this.is_start_tag = this.tag_check.charAt(0) !== "/", this.tag_name = this.is_start_tag ? this.tag_check : this.tag_check.substr(1), this.is_end_tag = !this.is_start_tag || v.closed && v.closed.text === "/>";
      var w = 2;
      this.tag_start_char === "{" && this.text.length >= 3 && this.text.charAt(2) === "~" && (w = 3), this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (!m.indent_handlebars || this.text.length < 3 || /[^#\^]/.test(this.text.charAt(w)));
    }
  };
  f.prototype._get_tag_open_token = function(m) {
    var g = new h(this._options, this._tag_stack.get_parser_token(), m);
    return g.alignment_size = this._options.wrap_attributes_indent_size, g.is_end_tag = g.is_end_tag || c(g.tag_check, this._options.void_elements), g.is_empty_element = g.tag_complete || g.is_start_tag && g.is_end_tag, g.is_unformatted = !g.tag_complete && c(g.tag_check, this._options.unformatted), g.is_content_unformatted = !g.is_empty_element && c(g.tag_check, this._options.content_unformatted), g.is_inline_element = c(g.tag_name, this._options.inline) || this._options.inline_custom_elements && g.tag_name.includes("-") || g.tag_start_char === "{", g;
  }, f.prototype._set_tag_position = function(m, g, v, x, w) {
    if (v.is_empty_element || (v.is_end_tag ? v.start_tag_token = this._tag_stack.try_pop(v.tag_name) : (this._do_optional_end_element(v) && (v.is_inline_element || m.print_newline(!1)), this._tag_stack.record_tag(v), (v.tag_name === "script" || v.tag_name === "style") && !(v.is_unformatted || v.is_content_unformatted) && (v.custom_beautifier_name = l(v.tag_check, g)))), c(v.tag_check, this._options.extra_liners) && (m.print_newline(!1), m._output.just_added_blankline() || m.print_newline(!0)), v.is_empty_element) {
      if (v.tag_start_char === "{" && v.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]), v.indent_content = !0;
        var S = m.current_line_has_match(/{{#if/);
        S || m.print_newline(!1);
      }
      v.tag_name === "!--" && w.type === i.TAG_CLOSE && x.is_end_tag && v.text.indexOf(`
`) === -1 || (v.is_inline_element || v.is_unformatted || m.print_newline(!1), this._calcluate_parent_multiline(m, v));
    } else if (v.is_end_tag) {
      var k = !1;
      k = v.start_tag_token && v.start_tag_token.multiline_content, k = k || !v.is_inline_element && !(x.is_inline_element || x.is_unformatted) && !(w.type === i.TAG_CLOSE && v.start_tag_token === x) && w.type !== "TK_CONTENT", (v.is_content_unformatted || v.is_unformatted) && (k = !1), k && m.print_newline(!1);
    } else
      v.indent_content = !v.custom_beautifier_name, v.tag_start_char === "<" && (v.tag_name === "html" ? v.indent_content = this._options.indent_inner_html : v.tag_name === "head" ? v.indent_content = this._options.indent_head_inner_html : v.tag_name === "body" && (v.indent_content = this._options.indent_body_inner_html)), !(v.is_inline_element || v.is_unformatted) && (w.type !== "TK_CONTENT" || v.is_content_unformatted) && m.print_newline(!1), this._calcluate_parent_multiline(m, v);
  }, f.prototype._calcluate_parent_multiline = function(m, g) {
    g.parent && m._output.just_added_newline() && !((g.is_inline_element || g.is_unformatted) && g.parent.is_inline_element) && (g.parent.multiline_content = !0);
  };
  var p = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"], b = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  return f.prototype._do_optional_end_element = function(m) {
    var g = null;
    if (!(m.is_empty_element || !m.is_start_tag || !m.parent)) {
      if (m.tag_name === "body")
        g = g || this._tag_stack.try_pop("head");
      else if (m.tag_name === "li")
        g = g || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
      else if (m.tag_name === "dd" || m.tag_name === "dt")
        g = g || this._tag_stack.try_pop("dt", ["dl"]), g = g || this._tag_stack.try_pop("dd", ["dl"]);
      else if (m.parent.tag_name === "p" && p.indexOf(m.tag_name) !== -1) {
        var v = m.parent.parent;
        (!v || b.indexOf(v.tag_name) === -1) && (g = g || this._tag_stack.try_pop("p"));
      } else m.tag_name === "rp" || m.tag_name === "rt" ? (g = g || this._tag_stack.try_pop("rt", ["ruby", "rtc"]), g = g || this._tag_stack.try_pop("rp", ["ruby", "rtc"])) : m.tag_name === "optgroup" ? g = g || this._tag_stack.try_pop("optgroup", ["select"]) : m.tag_name === "option" ? g = g || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]) : m.tag_name === "colgroup" ? g = g || this._tag_stack.try_pop("caption", ["table"]) : m.tag_name === "thead" ? (g = g || this._tag_stack.try_pop("caption", ["table"]), g = g || this._tag_stack.try_pop("colgroup", ["table"])) : m.tag_name === "tbody" || m.tag_name === "tfoot" ? (g = g || this._tag_stack.try_pop("caption", ["table"]), g = g || this._tag_stack.try_pop("colgroup", ["table"]), g = g || this._tag_stack.try_pop("thead", ["table"]), g = g || this._tag_stack.try_pop("tbody", ["table"])) : m.tag_name === "tr" ? (g = g || this._tag_stack.try_pop("caption", ["table"]), g = g || this._tag_stack.try_pop("colgroup", ["table"]), g = g || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"])) : (m.tag_name === "th" || m.tag_name === "td") && (g = g || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]), g = g || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]));
      return m.parent = this._tag_stack.get_parser_token(), g;
    }
  }, uc.Beautifier = f, uc;
}
var $h;
function ok() {
  if ($h) return Mo.exports;
  $h = 1;
  var n = sk().Beautifier, e = v_().Options;
  function t(i, r, s, o) {
    var a = new n(i, r, s, o);
    return a.beautify();
  }
  return Mo.exports = t, Mo.exports.defaultOptions = function() {
    return new e();
  }, Mo.exports;
}
var Bh;
function ak() {
  if (Bh) return is;
  Bh = 1;
  var n = nk(), e = rk(), t = ok();
  function i(r, s, o, a) {
    return o = o || n, a = a || e, t(r, s, o, a);
  }
  return i.defaultOptions = t.defaultOptions, is.js = n, is.css = e, is.html = i, is;
}
var zh;
function lk() {
  return zh || (zh = 1, function(n) {
    function e(t, i, r) {
      var s = function(o, a) {
        return t.js_beautify(o, a);
      };
      return s.js = t.js_beautify, s.css = i.css_beautify, s.html = r.html_beautify, s.js_beautify = t.js_beautify, s.css_beautify = i.css_beautify, s.html_beautify = r.html_beautify, s;
    }
    (function(t) {
      var i = ak();
      i.js_beautify = i.js, i.css_beautify = i.css, i.html_beautify = i.html, t.exports = e(i, i, i);
    })(n);
  }(Xl)), Xl.exports;
}
var y_ = lk(), ck = Ie.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), uk = Ie.create({
  name: "text",
  group: "inline"
}), dk = Qt.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(n) {
          return n !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["sub", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: n }) => n.setMark(this.name),
      toggleSubscript: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetSubscript: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), fk = Qt.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(n) {
          return n !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["sup", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: n }) => n.setMark(this.name),
      toggleSuperscript: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), hk = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, pk = Ie.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["img", Te(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setImage: (n) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: n
      })
    };
  },
  addInputRules() {
    return [
      pd({
        find: hk,
        type: this.type,
        getAttributes: (n) => {
          const [, , e, t, i] = n;
          return { src: t, alt: e, title: i };
        }
      })
    ];
  }
}), mk = Ie.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["br", Te(this.options.HTMLAttributes, n)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: n, chain: e, state: t, editor: i }) => n.first([
        () => n.exitCode(),
        () => n.command(() => {
          const { selection: r, storedMarks: s } = t;
          if (r.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: a } = i.extensionManager, l = s || r.$to.parentOffset && r.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && o) {
              const d = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), gk = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, _k = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, bk = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, vk = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, yk = Qt.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (n) => n.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (n) => n.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["em", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: n }) => n.setMark(this.name),
      toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Vr({
        find: gk,
        type: this.type
      }),
      Vr({
        find: bk,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ji({
        find: _k,
        type: this.type
      }),
      Ji({
        find: vk,
        type: this.type
      })
    ];
  }
}), xk = Qt.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["u", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: n }) => n.setMark(this.name),
      toggleUnderline: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetUnderline: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), ya = (n, e) => {
  if (n === "slot")
    return 0;
  if (n instanceof Function)
    return n(e);
  const { children: t, ...i } = e ?? {};
  if (n === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [n, i, t];
}, wk = /^\s*>\s$/, kk = Ie.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return /* @__PURE__ */ ya("blockquote", { ...Te(this.options.HTMLAttributes, n), children: /* @__PURE__ */ ya("slot", {}) });
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: n }) => n.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Gi({
        find: wk,
        type: this.type
      })
    ];
  }
}), Sk = Object.defineProperty, Ck = (n, e) => {
  for (var t in e)
    Sk(n, t, { get: e[t], enumerable: !0 });
}, Tk = "listItem", Hh = "textStyle", Fh = /^\s*([-+*])\s$/, x_ = Ie.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Tk, this.editor.getAttributes(Hh)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let n = Gi({
      find: Fh,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = Gi({
      find: Fh,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Hh),
      editor: this.editor
    })), [n];
  }
}), w_ = Ie.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Te(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Ek = {};
Ck(Ek, {
  findListItemPos: () => lo,
  getNextListDepth: () => yd,
  handleBackspace: () => iu,
  handleDelete: () => ru,
  hasListBefore: () => k_,
  hasListItemAfter: () => Ak,
  hasListItemBefore: () => S_,
  listItemHasSubList: () => C_,
  nextListIsDeeper: () => T_,
  nextListIsHigher: () => E_
});
var lo = (n, e) => {
  const { $from: t } = e.selection, i = nt(n, e.schema);
  let r = null, s = t.depth, o = t.pos, a = null;
  for (; s > 0 && a === null; )
    r = t.node(s), r.type === i ? a = s : (s -= 1, o -= 1);
  return a === null ? null : { $pos: e.doc.resolve(o), depth: a };
}, yd = (n, e) => {
  const t = lo(n, e);
  if (!t)
    return !1;
  const [, i] = Bg(e, n, t.$pos.pos + 4);
  return i;
}, k_ = (n, e, t) => {
  const { $anchor: i } = n.selection, r = Math.max(0, i.pos - 2), s = n.doc.resolve(r).node();
  return !(!s || !t.includes(s.type.name));
}, S_ = (n, e) => {
  var t;
  const { $anchor: i } = e.selection, r = e.doc.resolve(i.pos - 2);
  return !(r.index() === 0 || ((t = r.nodeBefore) == null ? void 0 : t.type.name) !== n);
}, C_ = (n, e, t) => {
  if (!t)
    return !1;
  const i = nt(n, e.schema);
  let r = !1;
  return t.descendants((s) => {
    s.type === i && (r = !0);
  }), r;
}, iu = (n, e, t) => {
  if (n.commands.undoInputRule())
    return !0;
  if (n.state.selection.from !== n.state.selection.to)
    return !1;
  if (!ti(n.state, e) && k_(n.state, e, t)) {
    const { $anchor: a } = n.state.selection, l = n.state.doc.resolve(a.before() - 1), c = [];
    l.node().descendants((f, h) => {
      f.type.name === e && c.push({ node: f, pos: h });
    });
    const u = c.at(-1);
    if (!u)
      return !1;
    const d = n.state.doc.resolve(l.start() + u.pos + 1);
    return n.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, d.end()).joinForward().run();
  }
  if (!ti(n.state, e) || !Vg(n.state))
    return !1;
  const i = lo(e, n.state);
  if (!i)
    return !1;
  const s = n.state.doc.resolve(i.$pos.pos - 2).node(i.depth), o = C_(e, n.state, s);
  return S_(e, n.state) && !o ? n.commands.joinItemBackward() : n.chain().liftListItem(e).run();
}, T_ = (n, e) => {
  const t = yd(n, e), i = lo(n, e);
  return !i || !t ? !1 : t > i.depth;
}, E_ = (n, e) => {
  const t = yd(n, e), i = lo(n, e);
  return !i || !t ? !1 : t < i.depth;
}, ru = (n, e) => {
  if (!ti(n.state, e) || !Fg(n.state, e))
    return !1;
  const { selection: t } = n.state, { $from: i, $to: r } = t;
  return !t.empty && i.sameParent(r) ? !1 : T_(e, n.state) ? n.chain().focus(n.state.selection.from + 4).lift(e).joinBackward().run() : E_(e, n.state) ? n.chain().joinForward().joinBackward().run() : n.commands.joinItemForward();
}, Ak = (n, e) => {
  var t;
  const { $anchor: i } = e.selection, r = e.doc.resolve(i.pos - i.parentOffset - 2);
  return !(r.index() === r.parent.childCount - 1 || ((t = r.nodeAfter) == null ? void 0 : t.type.name) !== n);
}, Mk = ze.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: n }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: t }) => {
          n.state.schema.nodes[t] !== void 0 && ru(n, t) && (e = !0);
        }), e;
      },
      "Mod-Delete": ({ editor: n }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: t }) => {
          n.state.schema.nodes[t] !== void 0 && ru(n, t) && (e = !0);
        }), e;
      },
      Backspace: ({ editor: n }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: t, wrapperNames: i }) => {
          n.state.schema.nodes[t] !== void 0 && iu(n, t, i) && (e = !0);
        }), e;
      },
      "Mod-Backspace": ({ editor: n }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: t, wrapperNames: i }) => {
          n.state.schema.nodes[t] !== void 0 && iu(n, t, i) && (e = !0);
        }), e;
      }
    };
  }
}), Ok = "listItem", Vh = "textStyle", jh = /^(\d+)\.\s$/, A_ = Ie.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (n) => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (n) => n.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { start: e, ...t } = n;
    return e === 1 ? ["ol", Te(this.options.HTMLAttributes, t), 0] : ["ol", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ok, this.editor.getAttributes(Vh)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let n = Gi({
      find: jh,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = Gi({
      find: jh,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Vh) }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
      editor: this.editor
    })), [n];
  }
}), Nk = /^\s*(\[([( |x])?\])\s$/, Lk = Ie.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (n) => {
          const e = n.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (n) => ({
          "data-checked": n.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [
      "li",
      Te(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: n.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const n = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...n,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : n;
  },
  addNodeView() {
    return ({ node: n, HTMLAttributes: e, getPos: t, editor: i }) => {
      const r = document.createElement("li"), s = document.createElement("label"), o = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div"), c = (u) => {
        var d, f;
        a.ariaLabel = ((f = (d = this.options.a11y) == null ? void 0 : d.checkboxLabel) == null ? void 0 : f.call(d, u, a.checked)) || `Task item checkbox for ${u.textContent || "empty task item"}`;
      };
      return c(n), s.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (u) => u.preventDefault()), a.addEventListener("change", (u) => {
        if (!i.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: d } = u.target;
        i.isEditable && typeof t == "function" && i.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: f }) => {
          const h = t();
          if (typeof h != "number")
            return !1;
          const p = f.doc.nodeAt(h);
          return f.setNodeMarkup(h, void 0, {
            ...p == null ? void 0 : p.attrs,
            checked: d
          }), !0;
        }).run(), !i.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(n, d) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([u, d]) => {
        r.setAttribute(u, d);
      }), r.dataset.checked = n.attrs.checked, a.checked = n.attrs.checked, s.append(a, o), r.append(s, l), Object.entries(e).forEach(([u, d]) => {
        r.setAttribute(u, d);
      }), {
        dom: r,
        contentDOM: l,
        update: (u) => u.type !== this.type ? !1 : (r.dataset.checked = u.attrs.checked, a.checked = u.attrs.checked, c(u), !0)
      };
    };
  },
  addInputRules() {
    return [
      Gi({
        find: Nk,
        type: this.type,
        getAttributes: (n) => ({
          checked: n[n.length - 1] === "x"
        })
      })
    ];
  }
}), Rk = Ie.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", Te(this.options.HTMLAttributes, n, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: n }) => n.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
ze.create({
  name: "listKit",
  addExtensions() {
    const n = [];
    return this.options.bulletList !== !1 && n.push(x_.configure(this.options.bulletList)), this.options.listItem !== !1 && n.push(w_.configure(this.options.listItem)), this.options.listKeymap !== !1 && n.push(Mk.configure(this.options.listKeymap)), this.options.orderedList !== !1 && n.push(A_.configure(this.options.orderedList)), this.options.taskItem !== !1 && n.push(Lk.configure(this.options.taskItem)), this.options.taskList !== !1 && n.push(Rk.configure(this.options.taskList)), n;
  }
});
var Ik = Ie.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((n) => ({
      tag: `h${n}`,
      attrs: { level: n }
    }));
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, Te(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1,
      toggleHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (n, e) => ({
        ...n,
        [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((n) => d_({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n}})\\s$`),
      type: this.type,
      getAttributes: {
        level: n
      }
    }));
  }
}), Pk = Ie.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["hr", Te(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: n, state: e }) => {
        if (!f_(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: t } = e, { $to: i } = t, r = n();
        return ld(t) ? r.insertContentAt(i.pos, {
          type: this.name
        }) : r.insertContent({ type: this.name }), r.command(({ tr: s, dispatch: o }) => {
          var a;
          if (o) {
            const { $to: l } = s.selection, c = l.end();
            if (l.nodeAfter)
              l.nodeAfter.isTextblock ? s.setSelection(ue.create(s.doc, l.pos + 1)) : l.nodeAfter.isBlock ? s.setSelection(ae.create(s.doc, l.pos)) : s.setSelection(ue.create(s.doc, l.pos));
            else {
              const u = (a = l.parent.type.contentMatch.defaultType) == null ? void 0 : a.create();
              u && (s.insert(c, u), s.setSelection(ue.create(s.doc, c + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      pd({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), Dk = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, $k = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Bk = Qt.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["s", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: n }) => n.setMark(this.name),
      toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Vr({
        find: Dk,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ji({
        find: $k,
        type: this.type
      })
    ];
  }
});
function zk(n = {}) {
  return new Ge({
    view(e) {
      return new Hk(e, n);
    }
  });
}
class Hk {
  constructor(e, t) {
    var i;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (i = t.width) !== null && i !== void 0 ? i : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let s = (o) => {
        this[r](o);
      };
      return e.dom.addEventListener(r, s), { name: r, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, i;
    if (t) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = a ? u.bottom : u.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), i = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!i) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      i = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let r = this.editorView.dom.offsetParent;
    this.element || (this.element = r.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let s, o;
    if (!r || r == document.body && getComputedStyle(r).position == "static")
      s = -pageXOffset, o = -pageYOffset;
    else {
      let a = r.getBoundingClientRect();
      s = a.left - r.scrollLeft, o = a.top - r.scrollTop;
    }
    this.element.style.left = i.left - s + "px", this.element.style.top = i.top - o + "px", this.element.style.width = i.right - i.left + "px", this.element.style.height = i.bottom - i.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), i = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), r = i && i.type.spec.disableDropCursor, s = typeof r == "function" ? r(this.editorView, t, e) : r;
    if (t && !s) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = Em(this.editorView.state.doc, o, this.editorView.dragging.slice);
        a != null && (o = a);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
class Ye extends pe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let i = e.resolve(t.map(this.head));
    return Ye.valid(i) ? new Ye(i) : pe.near(i);
  }
  content() {
    return Y.empty;
  }
  eq(e) {
    return e instanceof Ye && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Ye(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new xd(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !Fk(e) || !Vk(e))
      return !1;
    let i = t.type.spec.allowGapCursor;
    if (i != null)
      return i;
    let r = t.contentMatchAt(e.index()).defaultType;
    return r && r.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, i = !1) {
    e: for (; ; ) {
      if (!i && Ye.valid(e))
        return e;
      let r = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let a = e.node(o);
        if (t > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
          s = a.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        r += t;
        let l = e.doc.resolve(r);
        if (Ye.valid(l))
          return l;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !ae.isSelectable(s)) {
            e = e.doc.resolve(r + s.nodeSize * t), i = !1;
            continue e;
          }
          break;
        }
        s = o, r += t;
        let a = e.doc.resolve(r);
        if (Ye.valid(a))
          return a;
      }
      return null;
    }
  }
}
Ye.prototype.visible = !1;
Ye.findFrom = Ye.findGapCursorFrom;
pe.jsonID("gapcursor", Ye);
class xd {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new xd(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return Ye.valid(t) ? new Ye(t) : pe.near(t);
  }
}
function Fk(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), i = n.node(e);
    if (t == 0) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(t - 1); ; r = r.lastChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Vk(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), i = n.node(e);
    if (t == i.childCount) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(t); ; r = r.firstChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function jk() {
  return new Ge({
    props: {
      decorations: qk,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && Ye.valid(t) ? new Ye(t) : null;
      },
      handleClick: Uk,
      handleKeyDown: Wk,
      handleDOMEvents: { beforeinput: Kk }
    }
  });
}
const Wk = Ku({
  ArrowLeft: No("horiz", -1),
  ArrowRight: No("horiz", 1),
  ArrowUp: No("vert", -1),
  ArrowDown: No("vert", 1)
});
function No(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(i, r, s) {
    let o = i.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof ue) {
      if (!s.endOfTextblock(t) || a.depth == 0)
        return !1;
      l = !1, a = i.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = Ye.findGapCursorFrom(a, e, l);
    return c ? (r && r(i.tr.setSelection(new Ye(c))), !0) : !1;
  };
}
function Uk(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let i = n.state.doc.resolve(e);
  if (!Ye.valid(i))
    return !1;
  let r = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return r && r.inside > -1 && ae.isSelectable(n.state.doc.nodeAt(r.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new Ye(i))), !0);
}
function Kk(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof Ye))
    return !1;
  let { $from: t } = n.state.selection, i = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!i)
    return !1;
  let r = $.empty;
  for (let o = i.length - 1; o >= 0; o--)
    r = $.from(i[o].createAndFill(null, r));
  let s = n.state.tr.replace(t.pos, t.pos, new Y(r, 0, 0));
  return s.setSelection(ue.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function qk(n) {
  if (!(n.selection instanceof Ye))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", je.create(n.doc, [gt.widget(n.selection.head, e, { key: "gapcursor" })]);
}
var xa = 200, bt = function() {
};
bt.prototype.append = function(e) {
  return e.length ? (e = bt.from(e), !this.length && e || e.length < xa && this.leafAppend(e) || this.length < xa && e.leafPrepend(this) || this.appendInner(e)) : this;
};
bt.prototype.prepend = function(e) {
  return e.length ? bt.from(e).append(this) : this;
};
bt.prototype.appendInner = function(e) {
  return new Gk(this, e);
};
bt.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? bt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
bt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
bt.prototype.forEach = function(e, t, i) {
  t === void 0 && (t = 0), i === void 0 && (i = this.length), t <= i ? this.forEachInner(e, t, i, 0) : this.forEachInvertedInner(e, t, i, 0);
};
bt.prototype.map = function(e, t, i) {
  t === void 0 && (t = 0), i === void 0 && (i = this.length);
  var r = [];
  return this.forEach(function(s, o) {
    return r.push(e(s, o));
  }, t, i), r;
};
bt.from = function(e) {
  return e instanceof bt ? e : e && e.length ? new M_(e) : bt.empty;
};
var M_ = /* @__PURE__ */ function(n) {
  function e(i) {
    n.call(this), this.values = i;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(r, s) {
    return r == 0 && s == this.length ? this : new e(this.values.slice(r, s));
  }, e.prototype.getInner = function(r) {
    return this.values[r];
  }, e.prototype.forEachInner = function(r, s, o, a) {
    for (var l = s; l < o; l++)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(r, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(r) {
    if (this.length + r.length <= xa)
      return new e(this.values.concat(r.flatten()));
  }, e.prototype.leafPrepend = function(r) {
    if (this.length + r.length <= xa)
      return new e(r.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(bt);
bt.empty = new M_([]);
var Gk = /* @__PURE__ */ function(n) {
  function e(t, i) {
    n.call(this), this.left = t, this.right = i, this.length = t.length + i.length, this.depth = Math.max(t.depth, i.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  }, e.prototype.forEachInner = function(i, r, s, o) {
    var a = this.left.length;
    if (r < a && this.left.forEachInner(i, r, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(i, Math.max(r - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(i, r, s, o) {
    var a = this.left.length;
    if (r > a && this.right.forEachInvertedInner(i, r - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(i, Math.min(r, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(i, r) {
    if (i == 0 && r == this.length)
      return this;
    var s = this.left.length;
    return r <= s ? this.left.slice(i, r) : i >= s ? this.right.slice(i - s, r - s) : this.left.slice(i, s).append(this.right.slice(0, r - s));
  }, e.prototype.leafAppend = function(i) {
    var r = this.right.leafAppend(i);
    if (r)
      return new e(this.left, r);
  }, e.prototype.leafPrepend = function(i) {
    var r = this.left.leafPrepend(i);
    if (r)
      return new e(r, this.right);
  }, e.prototype.appendInner = function(i) {
    return this.left.depth >= Math.max(this.right.depth, i.depth) + 1 ? new e(this.left, new e(this.right, i)) : new e(this, i);
  }, e;
}(bt);
const Jk = 500;
class xn {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let i = this.items.length;
    for (; ; i--)
      if (this.items.get(i - 1).selection) {
        --i;
        break;
      }
    let r, s;
    t && (r = this.remapping(i, this.items.length), s = r.maps.length);
    let o = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        r || (r = this.remapping(i, f + 1), s = r.maps.length), s--, u.push(d);
        return;
      }
      if (r) {
        u.push(new Ln(d.map));
        let h = d.step.map(r.slice(s)), p;
        h && o.maybeStep(h).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Ln(p, void 0, void 0, c.length + u.length))), s--, p && r.appendMap(p, s);
      } else
        o.maybeStep(d.step);
      if (d.selection)
        return a = r ? d.selection.map(r.slice(s)) : d.selection, l = new xn(this.items.slice(0, i).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, i, r) {
    let s = [], o = this.eventCount, a = this.items, l = !r && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new Ln(e.mapping.maps[u], d, t), h;
      (h = l && l.merge(f)) && (f = h, u ? s.pop() : a = a.slice(0, a.length - 1)), s.push(f), t && (o++, t = void 0), r || (l = f);
    }
    let c = o - i.depth;
    return c > Yk && (a = Xk(a, c), o -= c), new xn(a.append(s), o);
  }
  remapping(e, t) {
    let i = new vr();
    return this.items.forEach((r, s) => {
      let o = r.mirrorOffset != null && s - r.mirrorOffset >= e ? i.maps.length - r.mirrorOffset : void 0;
      i.appendMap(r.map, o);
    }, e, t), i;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new xn(this.items.append(e.map((t) => new Ln(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let i = [], r = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, r);
    let l = t;
    this.items.forEach((f) => {
      let h = s.getMirror(--l);
      if (h == null)
        return;
      o = Math.min(o, h);
      let p = s.maps[h];
      if (f.step) {
        let b = e.steps[h].invert(e.docs[h]), m = f.selection && f.selection.map(s.slice(l + 1, h));
        m && a++, i.push(new Ln(p, b, m));
      } else
        i.push(new Ln(p));
    }, r);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new Ln(s.maps[f]));
    let u = this.items.slice(0, r).append(c).append(i), d = new xn(u, a);
    return d.emptyItemCount() > Jk && (d = d.compress(this.items.length - i.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), i = t.maps.length, r = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        r.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(t.slice(i)), c = l && l.getMap();
        if (i--, c && t.appendMap(c, i), l) {
          let u = o.selection && o.selection.map(t.slice(i));
          u && s++;
          let d = new Ln(c.invert(), l, u), f, h = r.length - 1;
          (f = r.length && r[h].merge(d)) ? r[h] = f : r.push(d);
        }
      } else o.map && i--;
    }, this.items.length, 0), new xn(bt.from(r.reverse()), s);
  }
}
xn.empty = new xn(bt.empty, 0);
function Xk(n, e) {
  let t;
  return n.forEach((i, r) => {
    if (i.selection && e-- == 0)
      return t = r, !1;
  }), n.slice(t);
}
class Ln {
  constructor(e, t, i, r) {
    this.map = e, this.step = t, this.selection = i, this.mirrorOffset = r;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Ln(t.getMap().invert(), t, this.selection);
    }
  }
}
class li {
  constructor(e, t, i, r, s) {
    this.done = e, this.undone = t, this.prevRanges = i, this.prevTime = r, this.prevComposition = s;
  }
}
const Yk = 20;
function Zk(n, e, t, i) {
  let r = t.getMeta(ei), s;
  if (r)
    return r.historyState;
  t.getMeta(tS) && (n = new li(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(ei))
    return o.getMeta(ei).redo ? new li(n.done.addTransform(t, void 0, i, Go(e)), n.undone, Wh(t.mapping.maps), n.prevTime, n.prevComposition) : new li(n.done, n.undone.addTransform(t, void 0, i, Go(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = t.getMeta("composition"), l = n.prevTime == 0 || !o && n.prevComposition != a && (n.prevTime < (t.time || 0) - i.newGroupDelay || !Qk(t, n.prevRanges)), c = o ? fc(n.prevRanges, t.mapping) : Wh(t.mapping.maps);
    return new li(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, i, Go(e)), xn.empty, c, t.time, a ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new li(n.done.rebased(t, s), n.undone.rebased(t, s), fc(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new li(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), fc(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function Qk(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((i, r) => {
    for (let s = 0; s < e.length; s += 2)
      i <= e[s + 1] && r >= e[s] && (t = !0);
  }), t;
}
function Wh(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((i, r, s, o) => e.push(s, o));
  return e;
}
function fc(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let i = 0; i < n.length; i += 2) {
    let r = e.map(n[i], 1), s = e.map(n[i + 1], -1);
    r <= s && t.push(r, s);
  }
  return t;
}
function eS(n, e, t) {
  let i = Go(e), r = ei.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, i);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), a = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), r, i), l = new li(t ? a : s.remaining, t ? s.remaining : a, null, 0, -1);
  return s.transform.setSelection(o).setMeta(ei, { redo: t, historyState: l });
}
let hc = !1, Uh = null;
function Go(n) {
  let e = n.plugins;
  if (Uh != e) {
    hc = !1, Uh = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        hc = !0;
        break;
      }
  }
  return hc;
}
const ei = new lt("history"), tS = new lt("closeHistory");
function nS(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Ge({
    key: ei,
    state: {
      init() {
        return new li(xn.empty, xn.empty, null, 0, -1);
      },
      apply(e, t, i) {
        return Zk(t, i, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let i = t.inputType, r = i == "historyUndo" ? N_ : i == "historyRedo" ? L_ : null;
          return r ? (t.preventDefault(), r(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function O_(n, e) {
  return (t, i) => {
    let r = ei.getState(t);
    if (!r || (n ? r.undone : r.done).eventCount == 0)
      return !1;
    if (i) {
      let s = eS(r, t, n);
      s && i(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const N_ = O_(!1, !0), L_ = O_(!0, !0);
function iS(n) {
  let e = ei.getState(n);
  return e ? e.done.eventCount : 0;
}
function rS(n) {
  let e = ei.getState(n);
  return e ? e.undone.eventCount : 0;
}
ze.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (n) => n.length,
      wordCounter: (n) => n.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (n) => {
      const e = (n == null ? void 0 : n.node) || this.editor.state.doc;
      if (((n == null ? void 0 : n.mode) || this.options.mode) === "textSize") {
        const i = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(i);
      }
      return e.nodeSize;
    }, this.storage.words = (n) => {
      const e = (n == null ? void 0 : n.node) || this.editor.state.doc, t = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(t);
    };
  },
  addProseMirrorPlugins() {
    let n = !1;
    return [
      new Ge({
        key: new lt("characterCount"),
        appendTransaction: (e, t, i) => {
          if (n)
            return;
          const r = this.options.limit;
          if (r == null || r === 0) {
            n = !0;
            return;
          }
          const s = this.storage.characters({ node: i.doc });
          if (s > r) {
            const o = s - r, a = 0, l = o;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${r} characters. Content was automatically trimmed.`
            );
            const c = i.tr.deleteRange(a, l);
            return n = !0, c;
          }
          n = !0;
        },
        filterTransaction: (e, t) => {
          const i = this.options.limit;
          if (!e.docChanged || i === 0 || i === null || i === void 0)
            return !0;
          const r = this.storage.characters({ node: t.doc }), s = this.storage.characters({ node: e.doc });
          if (s <= i || r > i && s > i && s <= r)
            return !0;
          if (r > i && s > i && s > r || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = s - i, c = a - l, u = a;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > i);
        }
      })
    ];
  }
});
var sS = ze.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [zk(this.options)];
  }
});
ze.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("focus"),
        props: {
          decorations: ({ doc: n, selection: e }) => {
            const { isEditable: t, isFocused: i } = this.editor, { anchor: r } = e, s = [];
            if (!t || !i)
              return je.create(n, []);
            let o = 0;
            this.options.mode === "deepest" && n.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              o += 1;
            });
            let a = 0;
            return n.descendants((l, c) => {
              if (l.isText || !(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && o - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              s.push(
                gt.node(c, c + l.nodeSize, {
                  class: this.options.className
                })
              );
            }), je.create(n, s);
          }
        }
      })
    ];
  }
});
var oS = ze.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [jk()];
  },
  extendNodeSchema(n) {
    var e;
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      allowGapCursor: (e = Me(oe(n, "allowGapCursor", t))) != null ? e : null
    };
  }
});
ze.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ge({
        key: new lt("placeholder"),
        props: {
          decorations: ({ doc: n, selection: e }) => {
            const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, r = [];
            if (!t)
              return null;
            const s = this.editor.isEmpty;
            return n.descendants((o, a) => {
              const l = i >= a && i <= a + o.nodeSize, c = !o.isLeaf && ao(o);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                s && u.push(this.options.emptyEditorClass);
                const d = gt.node(a, a + o.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: o,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                r.push(d);
              }
              return this.options.includeChildren;
            }), je.create(n, r);
          }
        }
      })
    ];
  }
});
ze.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: n, options: e } = this;
    return [
      new Ge({
        key: new lt("selection"),
        props: {
          decorations(t) {
            return t.selection.empty || n.isFocused || !n.isEditable || ld(t.selection) || n.view.dragging ? null : je.create(t.doc, [
              gt.inline(t.selection.from, t.selection.to, {
                class: e.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function Kh({ types: n, node: e }) {
  return e && Array.isArray(n) && n.includes(e.type) || (e == null ? void 0 : e.type) === n;
}
ze.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    const n = new lt(this.name), e = Object.entries(this.editor.schema.nodes).map(([, t]) => t).filter((t) => (this.options.notAfter || []).concat(this.options.node).includes(t.name));
    return [
      new Ge({
        key: n,
        appendTransaction: (t, i, r) => {
          const { doc: s, tr: o, schema: a } = r, l = n.getState(r), c = s.content.size, u = a.nodes[this.options.node];
          if (l)
            return o.insert(c, u.create());
        },
        state: {
          init: (t, i) => {
            const r = i.tr.doc.lastChild;
            return !Kh({ node: r, types: e });
          },
          apply: (t, i) => {
            if (!t.docChanged)
              return i;
            const r = t.doc.lastChild;
            return !Kh({ node: r, types: e });
          }
        }
      })
    ];
  }
});
var aS = ze.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: n, dispatch: e }) => N_(n, e),
      redo: () => ({ state: n, dispatch: e }) => L_(n, e)
    };
  },
  addProseMirrorPlugins() {
    return [nS(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), lS = ze.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (n) => {
              const e = n.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (n) => n.textAlign ? { style: `text-align: ${n.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (n) => ({ commands: e }) => this.options.alignments.includes(n) ? this.options.types.map((t) => e.updateAttributes(t, { textAlign: n })).every((t) => t) : !1,
      unsetTextAlign: () => ({ commands: n }) => this.options.types.map((e) => n.resetAttributes(e, "textAlign")).every((e) => e),
      toggleTextAlign: (n) => ({ editor: e, commands: t }) => this.options.alignments.includes(n) ? e.isActive({ textAlign: n }) ? t.unsetTextAlign() : t.setTextAlign(n) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), cS = (n) => {
  if (!n.children.length)
    return;
  const e = n.querySelectorAll("span");
  e && e.forEach((t) => {
    var i, r;
    const s = t.getAttribute("style"), o = (r = (i = t.parentElement) == null ? void 0 : i.closest("span")) == null ? void 0 : r.getAttribute("style");
    t.setAttribute("style", `${o};${s}`);
  });
}, uS = Qt.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !0
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: !1,
        getAttrs: (n) => n.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && cS(n), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (n) => ({ commands: e }) => e.toggleMark(this.name, n),
      removeEmptyTextStyle: () => ({ tr: n }) => {
        const { selection: e } = n;
        return n.doc.nodesBetween(e.from, e.to, (t, i) => {
          if (t.isTextblock)
            return !0;
          t.marks.filter((r) => r.type === this.type).some((r) => Object.values(r.attrs).some((s) => !!s)) || n.removeMark(i, i + t.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), dS = (n) => {
  if (!n.children.length)
    return;
  const e = n.querySelectorAll("span");
  e && e.forEach((t) => {
    var i, r;
    const s = t.getAttribute("style"), o = (r = (i = t.parentElement) == null ? void 0 : i.closest("span")) == null ? void 0 : r.getAttribute("style");
    t.setAttribute("style", `${o};${s}`);
  });
};
Qt.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !0
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: !1,
        getAttrs: (n) => n.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && dS(n), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (n) => ({ commands: e }) => e.toggleMark(this.name, n),
      removeEmptyTextStyle: () => ({ tr: n }) => {
        const { selection: e } = n;
        return n.doc.nodesBetween(e.from, e.to, (t, i) => {
          if (t.isTextblock)
            return !0;
          t.marks.filter((r) => r.type === this.type).some((r) => Object.values(r.attrs).some((s) => !!s)) || n.removeMark(i, i + t.nodeSize, this.type);
        }), !0;
      }
    };
  }
});
var fS = ze.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (n) => {
              var e;
              return (e = n.style.color) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (n) => n.color ? {
              style: `color: ${n.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (n) => ({ chain: e }) => e().setMark("textStyle", { color: n }).run(),
      unsetColor: () => ({ chain: n }) => n().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), hS = (n) => {
  if (!n.children.length)
    return;
  const e = n.querySelectorAll("span");
  e && e.forEach((t) => {
    var i, r;
    const s = t.getAttribute("style"), o = (r = (i = t.parentElement) == null ? void 0 : i.closest("span")) == null ? void 0 : r.getAttribute("style");
    t.setAttribute("style", `${o};${s}`);
  });
};
Qt.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !0
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: !1,
        getAttrs: (n) => n.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && hS(n), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (n) => ({ commands: e }) => e.toggleMark(this.name, n),
      removeEmptyTextStyle: () => ({ tr: n }) => {
        const { selection: e } = n;
        return n.doc.nodesBetween(e.from, e.to, (t, i) => {
          if (t.isTextblock)
            return !0;
          t.marks.filter((r) => r.type === this.type).some((r) => Object.values(r.attrs).some((s) => !!s)) || n.removeMark(i, i + t.nodeSize, this.type);
        }), !0;
      }
    };
  }
});
var pS = ze.create({
  name: "backgroundColor",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            default: null,
            parseHTML: (n) => {
              var e;
              return (e = n.style.backgroundColor) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (n) => n.backgroundColor ? {
              style: `background-color: ${n.backgroundColor}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBackgroundColor: (n) => ({ chain: e }) => e().setMark("textStyle", { backgroundColor: n }).run(),
      unsetBackgroundColor: () => ({ chain: n }) => n().setMark("textStyle", { backgroundColor: null }).removeEmptyTextStyle().run()
    };
  }
});
const mS = Ie.create({
  name: "iframe",
  group: "inline",
  content: "text*",
  inline: !0,
  atom: !0,
  parseHTML() {
    return [
      {
        tag: "iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["iframe", n];
  }
});
var su, ou;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  su = (e) => n.get(e), ou = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  su = (i) => {
    for (let r = 0; r < n.length; r += 2)
      if (n[r] == i) return n[r + 1];
  }, ou = (i, r) => (t == 10 && (t = 0), n[t++] = i, n[t++] = r);
}
var Ze = class {
  constructor(n, e, t, i) {
    this.width = n, this.height = e, this.map = t, this.problems = i;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const i = e % this.width, r = e / this.width | 0;
      let s = i + 1, o = r + 1;
      for (let a = 1; s < this.width && this.map[e + a] == t; a++)
        s++;
      for (let a = 1; o < this.height && this.map[e + this.width * a] == t; a++)
        o++;
      return { left: i, top: r, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: i, right: r, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? i == 0 : r == this.width) ? null : this.map[s * this.width + (t < 0 ? i - 1 : r)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[i + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: i,
      top: r,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(r, l),
      right: Math.max(i, a),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let i = n.top; i < n.bottom; i++)
      for (let r = n.left; r < n.right; r++) {
        const s = i * this.width + r, o = this.map[s];
        t[o] || (t[o] = !0, !(r == n.left && r && this.map[s - 1] == o || i == n.top && i && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let i = 0, r = 0; ; i++) {
      const s = r + t.child(i).nodeSize;
      if (i == n) {
        let o = e + n * this.width;
        const a = (n + 1) * this.width;
        for (; o < a && this.map[o] < r; ) o++;
        return o == a ? s - 1 : this.map[o];
      }
      r = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return su(n) || ou(n, gS(n));
  }
};
function gS(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = _S(n), t = n.childCount, i = [];
  let r = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) i[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const d = n.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; r < i.length && i[r] != 0; ) r++;
      if (p == d.childCount) break;
      const b = d.child(p), { colspan: m, rowspan: g, colwidth: v } = b.attrs;
      for (let x = 0; x < g; x++) {
        if (x + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: g - x
          });
          break;
        }
        const w = r + x * e;
        for (let S = 0; S < m; S++) {
          i[w + S] == 0 ? i[w + S] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: m - S
          });
          const k = v && v[S];
          if (k) {
            const C = (w + S) % e * 2, y = o[C];
            y == null || y != k && o[C + 1] == 1 ? (o[C] = k, o[C + 1] = 1) : y == k && o[C + 1]++;
          }
        }
      }
      r += m, u += b.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; r < f; ) i[r++] == 0 && h++;
    h && (s || (s = [])).push({ type: "missing", row: c, n: h }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const a = new Ze(e, t, i, s);
  let l = !1;
  for (let c = 0; !l && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (l = !0);
  return l && bS(a, o, n), a;
}
function _S(n) {
  let e = -1, t = !1;
  for (let i = 0; i < n.childCount; i++) {
    const r = n.child(i);
    let s = 0;
    if (t)
      for (let o = 0; o < i; o++) {
        const a = n.child(o);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          o + c.attrs.rowspan > i && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < r.childCount; o++) {
      const a = r.child(o);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function bS(n, e, t) {
  n.problems || (n.problems = []);
  const i = {};
  for (let r = 0; r < n.map.length; r++) {
    const s = n.map[r];
    if (i[s]) continue;
    i[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = o.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (r + c) % n.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((a || (a = vS(l)))[c] = d);
    }
    a && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function vS(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function Mt(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const i = n.nodes[t], r = i.spec.tableRole;
      r && (e[r] = i);
    }
  }
  return e;
}
var fi = new lt("selectingCells");
function qr(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function yS(n) {
  for (let e = n.depth; e > 0; e--) {
    const t = n.node(e).type.spec.tableRole;
    if (t === "cell" || t === "header_cell") return n.node(e);
  }
  return null;
}
function En(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function yl(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = qr(e.$head) || xS(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function xS(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function au(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function wS(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function wd(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function R_(n, e, t) {
  const i = n.node(-1), r = Ze.get(i), s = n.start(-1), o = r.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function Xi(n, e, t = 1) {
  const i = { ...n, colspan: n.colspan - t };
  return i.colwidth && (i.colwidth = i.colwidth.slice(), i.colwidth.splice(e, t), i.colwidth.some((r) => r > 0) || (i.colwidth = null)), i;
}
function I_(n, e, t = 1) {
  const i = { ...n, colspan: n.colspan + t };
  if (i.colwidth) {
    i.colwidth = i.colwidth.slice();
    for (let r = 0; r < t; r++) i.colwidth.splice(e, 0, 0);
  }
  return i;
}
function kS(n, e, t) {
  const i = Mt(e.type.schema).header_cell;
  for (let r = 0; r < n.height; r++)
    if (e.nodeAt(n.map[t + r * n.width]).type != i)
      return !1;
  return !0;
}
var We = class Kn extends pe {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const i = e.node(-1), r = Ze.get(i), s = e.start(-1), o = r.rectBetween(
      e.pos - s,
      t.pos - s
    ), a = e.node(0), l = r.cellsInRect(o).filter((u) => u != t.pos - s);
    l.unshift(t.pos - s);
    const c = l.map((u) => {
      const d = i.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new Lm(
        a.resolve(f),
        a.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const i = e.resolve(t.map(this.$anchorCell.pos)), r = e.resolve(t.map(this.$headCell.pos));
    if (au(i) && au(r) && wd(i, r)) {
      const s = this.$anchorCell.node(-1) != i.node(-1);
      return s && this.isRowSelection() ? Kn.rowSelection(i, r) : s && this.isColSelection() ? Kn.colSelection(i, r) : new Kn(i, r);
    }
    return ue.between(i, r);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = Ze.get(e), i = this.$anchorCell.start(-1), r = t.rectBetween(
      this.$anchorCell.pos - i,
      this.$headCell.pos - i
    ), s = {}, o = [];
    for (let l = r.top; l < r.bottom; l++) {
      const c = [];
      for (let u = l * t.width + r.left, d = r.left; d < r.right; d++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const h = t.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const b = r.left - h.left, m = h.right - r.right;
        if (b > 0 || m > 0) {
          let g = p.attrs;
          if (b > 0 && (g = Xi(g, 0, b)), m > 0 && (g = Xi(
            g,
            g.colspan - m,
            m
          )), h.left < r.left) {
            if (p = p.type.createAndFill(g), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(g)}`
              );
          } else
            p = p.type.create(g, p.content);
        }
        if (h.top < r.top || h.bottom > r.bottom) {
          const g = {
            ...p.attrs,
            rowspan: Math.min(h.bottom, r.bottom) - Math.max(h.top, r.top)
          };
          h.top < r.top ? p = p.type.createAndFill(g) : p = p.type.create(g, p.content);
        }
        c.push(p);
      }
      o.push(e.child(l).copy($.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : o;
    return new Y($.from(a), 1, 1);
  }
  replace(e, t = Y.empty) {
    const i = e.steps.length, r = this.ranges;
    for (let o = 0; o < r.length; o++) {
      const { $from: a, $to: l } = r[o], c = e.mapping.slice(i);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        o ? Y.empty : t
      );
    }
    const s = pe.findFrom(
      e.doc.resolve(e.mapping.slice(i).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new Y($.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), i = Ze.get(t), r = this.$anchorCell.start(-1), s = i.cellsInRect(
      i.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), r + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const i = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(i, r) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const i = e.node(-1), r = Ze.get(i), s = e.start(-1), o = r.findCell(e.pos - s), a = r.findCell(t.pos - s), l = e.node(0);
    return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + r.map[o.left])), a.bottom < r.height && (t = l.resolve(
      s + r.map[r.width * (r.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (t = l.resolve(s + r.map[a.left])), o.bottom < r.height && (e = l.resolve(
      s + r.map[r.width * (r.height - 1) + o.right - 1]
    ))), new Kn(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = Ze.get(e), i = this.$anchorCell.start(-1), r = t.colCount(this.$anchorCell.pos - i), s = t.colCount(this.$headCell.pos - i);
    if (Math.min(r, s) > 0) return !1;
    const o = r + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, a) == t.width;
  }
  eq(e) {
    return e instanceof Kn && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const i = e.node(-1), r = Ze.get(i), s = e.start(-1), o = r.findCell(e.pos - s), a = r.findCell(t.pos - s), l = e.node(0);
    return o.left <= a.left ? (o.left > 0 && (e = l.resolve(
      s + r.map[o.top * r.width]
    )), a.right < r.width && (t = l.resolve(
      s + r.map[r.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (t = l.resolve(s + r.map[a.top * r.width])), o.right < r.width && (e = l.resolve(
      s + r.map[r.width * (o.top + 1) - 1]
    ))), new Kn(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Kn(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, i = t) {
    return new Kn(e.resolve(t), e.resolve(i));
  }
  getBookmark() {
    return new SS(this.$anchorCell.pos, this.$headCell.pos);
  }
};
We.prototype.visible = !1;
pe.jsonID("cell", We);
var SS = class P_ {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new P_(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), i = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && i.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && i.index() < i.parent.childCount && wd(t, i) ? new We(t, i) : pe.near(i, 1);
  }
};
function CS(n) {
  if (!(n.selection instanceof We)) return null;
  const e = [];
  return n.selection.forEachCell((t, i) => {
    e.push(
      gt.node(i, i + t.nodeSize, { class: "selectedCell" })
    );
  }), je.create(n.doc, e);
}
function TS({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, i = e.pos, r = n.depth;
  for (; r >= 0 && !(n.after(r + 1) < n.end(r)); r--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, i--)
    ;
  return t == i && /row|table/.test(n.node(r).type.spec.tableRole);
}
function ES({ $from: n, $to: e }) {
  let t, i;
  for (let r = n.depth; r > 0; r--) {
    const s = n.node(r);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let r = e.depth; r > 0; r--) {
    const s = e.node(r);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      i = s;
      break;
    }
  }
  return t !== i && e.parentOffset === 0;
}
function AS(n, e, t) {
  const i = (e || n).selection, r = (e || n).doc;
  let s, o;
  if (i instanceof ae && (o = i.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = We.create(r, i.from);
    else if (o == "row") {
      const a = r.resolve(i.from + 1);
      s = We.rowSelection(a, a);
    } else if (!t) {
      const a = Ze.get(i.node), l = i.from + 1, c = l + a.map[a.width * a.height - 1];
      s = We.create(r, l + 1, c);
    }
  } else i instanceof ue && TS(i) ? s = ue.create(r, i.from) : i instanceof ue && ES(i) && (s = ue.create(r, i.$from.start(), i.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var MS = new lt("fix-tables");
function D_(n, e, t, i) {
  const r = n.childCount, s = e.childCount;
  e: for (let o = 0, a = 0; o < s; o++) {
    const l = e.child(o);
    for (let c = a, u = Math.min(r, o + 3); c < u; c++)
      if (n.child(c) == l) {
        a = c + 1, t += l.nodeSize;
        continue e;
      }
    i(l, t), a < r && n.child(a).sameMarkup(l) ? D_(n.child(a), l, t + 1, i) : l.nodesBetween(0, l.content.size, i, t + 1), t += l.nodeSize;
  }
}
function $_(n, e) {
  let t;
  const i = (r, s) => {
    r.type.spec.tableRole == "table" && (t = OS(n, r, s, t));
  };
  return e ? e.doc != n.doc && D_(e.doc, n.doc, 0, i) : n.doc.descendants(i), t;
}
function OS(n, e, t, i) {
  const r = Ze.get(e);
  if (!r.problems) return i;
  i || (i = n.tr);
  const s = [];
  for (let l = 0; l < r.height; l++) s.push(0);
  for (let l = 0; l < r.problems.length; l++) {
    const c = r.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++) s[c.row + f] += c.n;
      i.setNodeMarkup(
        i.mapping.map(t + 1 + c.pos),
        null,
        Xi(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      i.setNodeMarkup(i.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      i.setNodeMarkup(i.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = i.mapping.map(t);
      i.delete(u, u + e.nodeSize);
    }
  }
  let o, a;
  for (let l = 0; l < s.length; l++)
    s[l] && (o == null && (o = l), a = l);
  for (let l = 0, c = t + 1; l < r.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, f = s[l];
    if (f > 0) {
      let h = "cell";
      u.firstChild && (h = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let m = 0; m < f; m++) {
        const g = Mt(n.schema)[h].createAndFill();
        g && p.push(g);
      }
      const b = (l == 0 || o == l - 1) && a == l ? c + 1 : d - 1;
      i.insert(i.mapping.map(b), p);
    }
    c = d;
  }
  return i.setMeta(MS, { fixTables: !0 });
}
function pn(n) {
  const e = n.selection, t = yl(n), i = t.node(-1), r = t.start(-1), s = Ze.get(i);
  return { ...e instanceof We ? s.rectBetween(
    e.$anchorCell.pos - r,
    e.$headCell.pos - r
  ) : s.findCell(t.pos - r), tableStart: r, map: s, table: i };
}
function B_(n, { map: e, tableStart: t, table: i }, r) {
  let s = r > 0 ? -1 : 0;
  kS(e, i, r + s) && (s = r == 0 || r == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const a = o * e.width + r;
    if (r > 0 && r < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = i.nodeAt(l);
      n.setNodeMarkup(
        n.mapping.map(t + l),
        null,
        I_(c.attrs, r - e.colCount(l))
      ), o += c.attrs.rowspan - 1;
    } else {
      const l = s == null ? Mt(i.type.schema).cell : i.nodeAt(e.map[a + s]).type, c = e.positionAt(o, r, i);
      n.insert(n.mapping.map(t + c), l.createAndFill());
    }
  }
  return n;
}
function NS(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n);
    e(B_(n.tr, t, t.left));
  }
  return !0;
}
function LS(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n);
    e(B_(n.tr, t, t.right));
  }
  return !0;
}
function RS(n, { map: e, table: t, tableStart: i }, r) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const a = o * e.width + r, l = e.map[a], c = t.nodeAt(l), u = c.attrs;
    if (r > 0 && e.map[a - 1] == l || r < e.width - 1 && e.map[a + 1] == l)
      n.setNodeMarkup(
        n.mapping.slice(s).map(i + l),
        null,
        Xi(u, r - e.colCount(l))
      );
    else {
      const d = n.mapping.slice(s).map(i + l);
      n.delete(d, d + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function IS(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n), i = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let r = t.right - 1; RS(i, t, r), r != t.left; r--) {
      const s = t.tableStart ? i.doc.nodeAt(t.tableStart - 1) : i.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = Ze.get(s);
    }
    e(i);
  }
  return !0;
}
function PS(n, e, t) {
  var i;
  const r = Mt(e.type.schema).header_cell;
  for (let s = 0; s < n.width; s++)
    if (((i = e.nodeAt(n.map[s + t * n.width])) == null ? void 0 : i.type) != r)
      return !1;
  return !0;
}
function z_(n, { map: e, tableStart: t, table: i }, r) {
  var s;
  let o = t;
  for (let c = 0; c < r; c++) o += i.child(c).nodeSize;
  const a = [];
  let l = r > 0 ? -1 : 0;
  PS(e, i, r + l) && (l = r == 0 || r == e.height ? null : 0);
  for (let c = 0, u = e.width * r; c < e.width; c++, u++)
    if (r > 0 && r < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], f = i.nodeAt(d).attrs;
      n.setNodeMarkup(t + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const d = l == null ? Mt(i.type.schema).cell : (s = i.nodeAt(e.map[u + l * e.width])) == null ? void 0 : s.type, f = d == null ? void 0 : d.createAndFill();
      f && a.push(f);
    }
  return n.insert(o, Mt(i.type.schema).row.create(null, a)), n;
}
function DS(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n);
    e(z_(n.tr, t, t.top));
  }
  return !0;
}
function $S(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n);
    e(z_(n.tr, t, t.bottom));
  }
  return !0;
}
function BS(n, { map: e, table: t, tableStart: i }, r) {
  let s = 0;
  for (let c = 0; c < r; c++) s += t.child(c).nodeSize;
  const o = s + t.child(r).nodeSize, a = n.mapping.maps.length;
  n.delete(s + i, o + i);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = r * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), r > 0 && d == e.map[u - e.width]) {
        const f = t.nodeAt(d).attrs;
        n.setNodeMarkup(n.mapping.slice(a).map(d + i), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (r < e.height && d == e.map[u + e.width]) {
        const f = t.nodeAt(d), h = f.attrs, p = f.type.create(
          { ...h, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), b = e.positionAt(r + 1, c, t);
        n.insert(n.mapping.slice(a).map(i + b), p), c += h.colspan - 1;
      }
    }
  }
}
function zS(n, e) {
  if (!En(n)) return !1;
  if (e) {
    const t = pn(n), i = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let r = t.bottom - 1; BS(i, t, r), r != t.top; r--) {
      const s = t.tableStart ? i.doc.nodeAt(t.tableStart - 1) : i.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = Ze.get(t.table);
    }
    e(i);
  }
  return !0;
}
function qh(n) {
  const e = n.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function HS({ width: n, height: e, map: t }, i) {
  let r = i.top * n + i.left, s = r, o = (i.bottom - 1) * n + i.left, a = r + (i.right - i.left - 1);
  for (let l = i.top; l < i.bottom; l++) {
    if (i.left > 0 && t[s] == t[s - 1] || i.right < n && t[a] == t[a + 1])
      return !0;
    s += n, a += n;
  }
  for (let l = i.left; l < i.right; l++) {
    if (i.top > 0 && t[r] == t[r - n] || i.bottom < e && t[o] == t[o + n])
      return !0;
    r++, o++;
  }
  return !1;
}
function Gh(n, e) {
  const t = n.selection;
  if (!(t instanceof We) || t.$anchorCell.pos == t.$headCell.pos)
    return !1;
  const i = pn(n), { map: r } = i;
  if (HS(r, i)) return !1;
  if (e) {
    const s = n.tr, o = {};
    let a = $.empty, l, c;
    for (let u = i.top; u < i.bottom; u++)
      for (let d = i.left; d < i.right; d++) {
        const f = r.map[u * r.width + d], h = i.table.nodeAt(f);
        if (!(o[f] || !h))
          if (o[f] = !0, l == null)
            l = f, c = h;
          else {
            qh(h) || (a = a.append(h.content));
            const p = s.mapping.map(f + i.tableStart);
            s.delete(p, p + h.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (s.setNodeMarkup(l + i.tableStart, null, {
      ...I_(
        c.attrs,
        c.attrs.colspan,
        i.right - i.left - c.attrs.colspan
      ),
      rowspan: i.bottom - i.top
    }), a.size) {
      const u = l + 1 + c.content.size, d = qh(c) ? l + 1 : u;
      s.replaceWith(d + i.tableStart, u + i.tableStart, a);
    }
    s.setSelection(
      new We(s.doc.resolve(l + i.tableStart))
    ), e(s);
  }
  return !0;
}
function Jh(n, e) {
  const t = Mt(n.schema);
  return FS(({ node: i }) => t[i.type.spec.tableRole])(n, e);
}
function FS(n) {
  return (e, t) => {
    var i;
    const r = e.selection;
    let s, o;
    if (r instanceof We) {
      if (r.$anchorCell.pos != r.$headCell.pos) return !1;
      s = r.$anchorCell.nodeAfter, o = r.$anchorCell.pos;
    } else {
      if (s = yS(r.$from), !s) return !1;
      o = (i = qr(r.$from)) == null ? void 0 : i.pos;
    }
    if (s == null || o == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
      return !1;
    if (t) {
      let a = s.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const u = pn(e), d = e.tr;
      for (let h = 0; h < u.right - u.left; h++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[h] ? [c[h]] : null
          } : a
        );
      let f;
      for (let h = u.top; h < u.bottom; h++) {
        let p = u.map.positionAt(h, u.left, u.table);
        h == u.top && (p += s.nodeSize);
        for (let b = u.left, m = 0; b < u.right; b++, m++)
          b == u.left && h == u.top || d.insert(
            f = d.mapping.map(p + u.tableStart, 1),
            n({ node: s, row: h, col: b }).createAndFill(l[m])
          );
      }
      d.setNodeMarkup(
        o,
        n({ node: s, row: u.top, col: u.left }),
        l[0]
      ), r instanceof We && d.setSelection(
        new We(
          d.doc.resolve(r.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), t(d);
    }
    return !0;
  };
}
function VS(n, e) {
  return function(t, i) {
    if (!En(t)) return !1;
    const r = yl(t);
    if (r.nodeAfter.attrs[n] === e) return !1;
    if (i) {
      const s = t.tr;
      t.selection instanceof We ? t.selection.forEachCell((o, a) => {
        o.attrs[n] !== e && s.setNodeMarkup(a, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(r.pos, null, {
        ...r.nodeAfter.attrs,
        [n]: e
      }), i(s);
    }
    return !0;
  };
}
function jS(n) {
  return function(e, t) {
    if (!En(e)) return !1;
    if (t) {
      const i = Mt(e.schema), r = pn(e), s = e.tr, o = r.map.cellsInRect(
        n == "column" ? {
          left: r.left,
          top: 0,
          right: r.right,
          bottom: r.map.height
        } : n == "row" ? {
          left: 0,
          top: r.top,
          right: r.map.width,
          bottom: r.bottom
        } : r
      ), a = o.map((l) => r.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        a[l].type == i.header_cell && s.setNodeMarkup(
          r.tableStart + o[l],
          i.cell,
          a[l].attrs
        );
      if (s.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          s.setNodeMarkup(
            r.tableStart + o[l],
            i.header_cell,
            a[l].attrs
          );
      t(s);
    }
    return !0;
  };
}
function Xh(n, e, t) {
  const i = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let r = 0; r < i.length; r++) {
    const s = e.table.nodeAt(i[r]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function Ws(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? jS(n) : function(t, i) {
    if (!En(t)) return !1;
    if (i) {
      const r = Mt(t.schema), s = pn(t), o = t.tr, a = Xh("row", s, r), l = Xh(
        "column",
        s,
        r
      ), u = (n === "column" ? a : n === "row" ? l : !1) ? 1 : 0, d = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? l ? r.cell : r.header_cell : n == "row" ? a ? r.cell : r.header_cell : r.cell;
      s.map.cellsInRect(d).forEach((h) => {
        const p = h + s.tableStart, b = o.doc.nodeAt(p);
        b && o.setNodeMarkup(p, f, b.attrs);
      }), i(o);
    }
    return !0;
  };
}
Ws("row", {
  useDeprecatedLogic: !0
});
Ws("column", {
  useDeprecatedLogic: !0
});
var WS = Ws("cell", {
  useDeprecatedLogic: !0
});
function US(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let i = n.index(-1) - 1, r = n.before(); i >= 0; i--) {
      const s = n.node(-1).child(i), o = s.lastChild;
      if (o)
        return r - 1 - o.nodeSize;
      r -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let i = n.indexAfter(-1), r = n.after(); i < t.childCount; i++) {
      const s = t.child(i);
      if (s.childCount) return r + 1;
      r += s.nodeSize;
    }
  }
  return null;
}
function Yh(n) {
  return function(e, t) {
    if (!En(e)) return !1;
    const i = US(yl(e), n);
    if (i == null) return !1;
    if (t) {
      const r = e.doc.resolve(i);
      t(
        e.tr.setSelection(ue.between(r, wS(r))).scrollIntoView()
      );
    }
    return !0;
  };
}
function KS(n, e) {
  const t = n.selection.$anchor;
  for (let i = t.depth; i > 0; i--)
    if (t.node(i).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(i), t.after(i)).scrollIntoView()
      ), !0;
  return !1;
}
function Lo(n, e) {
  const t = n.selection;
  if (!(t instanceof We)) return !1;
  if (e) {
    const i = n.tr, r = Mt(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(r) || i.replace(
        i.mapping.map(o + 1),
        i.mapping.map(o + s.nodeSize - 1),
        new Y(r, 0, 0)
      );
    }), i.docChanged && e(i);
  }
  return !0;
}
function qS(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: i } = n;
  for (; e.childCount == 1 && (t > 0 && i > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, i--, e = e.child(0).content;
  const r = e.child(0), s = r.type.spec.tableRole, o = r.type.schema, a = [];
  if (s == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, t - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, i - 1);
      (u || d) && (c = lu(
        Mt(o).row,
        new Y(c, u, d)
      ).content), a.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    a.push(
      t || i ? lu(
        Mt(o).row,
        new Y(e, t, i)
      ).content : e
    );
  else
    return null;
  return GS(o, a);
}
function GS(n, e) {
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: a, colspan: l } = s.child(o).attrs;
      for (let c = r; c < r + a; c++)
        t[c] = (t[c] || 0) + l;
    }
  }
  let i = 0;
  for (let r = 0; r < t.length; r++) i = Math.max(i, t[r]);
  for (let r = 0; r < t.length; r++)
    if (r >= e.length && e.push($.empty), t[r] < i) {
      const s = Mt(n).cell.createAndFill(), o = [];
      for (let a = t[r]; a < i; a++)
        o.push(s);
      e[r] = e[r].append($.from(o));
    }
  return { height: e.length, width: i, rows: e };
}
function lu(n, e) {
  const t = n.createAndFill();
  return new Pu(t).replace(0, t.content.size, e).doc;
}
function JS({ width: n, height: e, rows: t }, i, r) {
  if (n != i) {
    const s = [], o = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a], c = [];
      for (let u = s[a] || 0, d = 0; u < i; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > i && (f = f.type.createChecked(
          Xi(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - i
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++)
          s[a + h] = (s[a + h] || 0) + f.attrs.colspan;
      }
      o.push($.from(c));
    }
    t = o, n = i;
  }
  if (e != r) {
    const s = [];
    for (let o = 0, a = 0; o < r; o++, a++) {
      const l = [], c = t[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        o + d.attrs.rowspan > r && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, r - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      s.push($.from(l));
    }
    t = s, e = r;
  }
  return { width: n, height: e, rows: t };
}
function XS(n, e, t, i, r, s, o) {
  const a = n.doc.type.schema, l = Mt(a);
  let c, u;
  if (r > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const h = t.child(d);
      f += h.nodeSize;
      const p = [];
      let b;
      h.lastChild == null || h.lastChild.type == l.cell ? b = c || (c = l.cell.createAndFill()) : b = u || (u = l.header_cell.createAndFill());
      for (let m = e.width; m < r; m++) p.push(b);
      n.insert(n.mapping.slice(o).map(f - 1 + i), p);
    }
  if (s > e.height) {
    const d = [];
    for (let p = 0, b = (e.height - 1) * e.width; p < Math.max(e.width, r); p++) {
      const m = p >= e.width ? !1 : t.nodeAt(e.map[b + p]).type == l.header_cell;
      d.push(
        m ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, $.from(d)), h = [];
    for (let p = e.height; p < s; p++) h.push(f);
    n.insert(n.mapping.slice(o).map(i + t.nodeSize - 2), h);
  }
  return !!(c || u);
}
function Zh(n, e, t, i, r, s, o, a) {
  if (o == 0 || o == e.height) return !1;
  let l = !1;
  for (let c = r; c < s; c++) {
    const u = o * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const f = t.nodeAt(d), { top: h, left: p } = e.findCell(d);
      n.setNodeMarkup(n.mapping.slice(a).map(d + i), null, {
        ...f.attrs,
        rowspan: o - h
      }), n.insert(
        n.mapping.slice(a).map(e.positionAt(o, p, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: h + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function Qh(n, e, t, i, r, s, o, a) {
  if (o == 0 || o == e.width) return !1;
  let l = !1;
  for (let c = r; c < s; c++) {
    const u = c * e.width + o, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const f = t.nodeAt(d), h = e.colCount(d), p = n.mapping.slice(a).map(d + i);
      n.setNodeMarkup(
        p,
        null,
        Xi(
          f.attrs,
          o - h,
          f.attrs.colspan - (o - h)
        )
      ), n.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          Xi(f.attrs, 0, o - h)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function ep(n, e, t, i, r) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = Ze.get(s);
  const { top: a, left: l } = i, c = l + r.width, u = a + r.height, d = n.tr;
  let f = 0;
  function h() {
    if (s = t ? d.doc.nodeAt(t - 1) : d.doc, !s)
      throw new Error("No table found");
    o = Ze.get(s), f = d.mapping.maps.length;
  }
  XS(d, o, s, t, c, u, f) && h(), Zh(d, o, s, t, l, c, a, f) && h(), Zh(d, o, s, t, l, c, u, f) && h(), Qh(d, o, s, t, a, u, l, f) && h(), Qh(d, o, s, t, a, u, c, f) && h();
  for (let p = a; p < u; p++) {
    const b = o.positionAt(p, l, s), m = o.positionAt(p, c, s);
    d.replace(
      d.mapping.slice(f).map(b + t),
      d.mapping.slice(f).map(m + t),
      new Y(r.rows[p - a], 0, 0)
    );
  }
  h(), d.setSelection(
    new We(
      d.doc.resolve(t + o.positionAt(a, l, s)),
      d.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(d);
}
var YS = Ku({
  ArrowLeft: Ro("horiz", -1),
  ArrowRight: Ro("horiz", 1),
  ArrowUp: Ro("vert", -1),
  ArrowDown: Ro("vert", 1),
  "Shift-ArrowLeft": Io("horiz", -1),
  "Shift-ArrowRight": Io("horiz", 1),
  "Shift-ArrowUp": Io("vert", -1),
  "Shift-ArrowDown": Io("vert", 1),
  Backspace: Lo,
  "Mod-Backspace": Lo,
  Delete: Lo,
  "Mod-Delete": Lo
});
function Jo(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function Ro(n, e) {
  return (t, i, r) => {
    if (!r) return !1;
    const s = t.selection;
    if (s instanceof We)
      return Jo(
        t,
        i,
        pe.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = H_(r, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Jo(
        t,
        i,
        pe.near(t.doc.resolve(s.head + e), e)
      );
    {
      const a = t.doc.resolve(o), l = R_(a, n, e);
      let c;
      return l ? c = pe.near(l, 1) : e < 0 ? c = pe.near(t.doc.resolve(a.before(-1)), -1) : c = pe.near(t.doc.resolve(a.after(-1)), 1), Jo(t, i, c);
    }
  };
}
function Io(n, e) {
  return (t, i, r) => {
    if (!r) return !1;
    const s = t.selection;
    let o;
    if (s instanceof We)
      o = s;
    else {
      const l = H_(r, n, e);
      if (l == null) return !1;
      o = new We(t.doc.resolve(l));
    }
    const a = R_(o.$headCell, n, e);
    return a ? Jo(
      t,
      i,
      new We(o.$anchorCell, a)
    ) : !1;
  };
}
function ZS(n, e) {
  const t = n.state.doc, i = qr(t.resolve(e));
  return i ? (n.dispatch(n.state.tr.setSelection(new We(i))), !0) : !1;
}
function QS(n, e, t) {
  if (!En(n.state)) return !1;
  let i = qS(t);
  const r = n.state.selection;
  if (r instanceof We) {
    i || (i = {
      width: 1,
      height: 1,
      rows: [
        $.from(
          lu(Mt(n.state.schema).cell, t)
        )
      ]
    });
    const s = r.$anchorCell.node(-1), o = r.$anchorCell.start(-1), a = Ze.get(s).rectBetween(
      r.$anchorCell.pos - o,
      r.$headCell.pos - o
    );
    return i = JS(i, a.right - a.left, a.bottom - a.top), ep(n.state, n.dispatch, o, a, i), !0;
  } else if (i) {
    const s = yl(n.state), o = s.start(-1);
    return ep(
      n.state,
      n.dispatch,
      o,
      Ze.get(s.node(-1)).findCell(s.pos - o),
      i
    ), !0;
  } else
    return !1;
}
function eC(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const i = tp(n, e.target);
  let r;
  if (e.shiftKey && n.state.selection instanceof We)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && i && (r = qr(n.state.selection.$anchor)) != null && ((t = pc(n, e)) == null ? void 0 : t.pos) != r.pos)
    s(r, e), e.preventDefault();
  else if (!i)
    return;
  function s(l, c) {
    let u = pc(n, c);
    const d = fi.getState(n.state) == null;
    if (!u || !wd(l, u))
      if (d) u = l;
      else return;
    const f = new We(l, u);
    if (d || !n.state.selection.eq(f)) {
      const h = n.state.tr.setSelection(f);
      d && h.setMeta(fi, l.pos), n.dispatch(h);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", a), fi.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(fi, -1));
  }
  function a(l) {
    const c = l, u = fi.getState(n.state);
    let d;
    if (u != null)
      d = n.state.doc.resolve(u);
    else if (tp(n, c.target) != i && (d = pc(n, e), !d))
      return o();
    d && s(d, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", a);
}
function H_(n, e, t) {
  if (!(n.state.selection instanceof ue)) return null;
  const { $head: i } = n.state.selection;
  for (let r = i.depth - 1; r >= 0; r--) {
    const s = i.node(r);
    if ((t < 0 ? i.index(r) : i.indexAfter(r)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const a = i.before(r), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function tp(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function pc(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? qr(n.state.doc.resolve(t.pos)) : null;
}
var tC = class {
  constructor(e, t) {
    this.node = e, this.defaultCellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${t}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), cu(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, cu(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function cu(n, e, t, i, r, s) {
  var o;
  let a = 0, l = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d++) {
      const { colspan: h, colwidth: p } = u.child(d).attrs;
      for (let b = 0; b < h; b++, f++) {
        const m = r == f ? s : p && p[b], g = m ? m + "px" : "";
        if (a += m || i, m || (l = !1), c)
          c.style.width != g && (c.style.width = g), c = c.nextSibling;
        else {
          const v = document.createElement("col");
          v.style.width = g, e.appendChild(v);
        }
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = d;
    }
    l ? (t.style.width = a + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = a + "px");
  }
}
var Zt = new lt(
  "tableColumnResizing"
);
function nC({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: i = tC,
  lastColumnResizable: r = !0
} = {}) {
  const s = new Ge({
    key: Zt,
    state: {
      init(o, a) {
        var l, c;
        const u = (c = (l = s.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, d = Mt(a.schema).table.name;
        return i && u && (u[d] = (f, h) => new i(f, t, h)), new iC(-1, !1);
      },
      apply(o, a) {
        return a.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const a = Zt.getState(o);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, a) => {
          rC(o, a, n, r);
        },
        mouseleave: (o) => {
          sC(o);
        },
        mousedown: (o, a) => {
          oC(o, a, e, t);
        }
      },
      decorations: (o) => {
        const a = Zt.getState(o);
        if (a && a.activeHandle > -1)
          return dC(o, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var iC = class Xo {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, i = e.getMeta(Zt);
    if (i && i.setHandle != null)
      return new Xo(i.setHandle, !1);
    if (i && i.setDragging !== void 0)
      return new Xo(t.activeHandle, i.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let r = e.mapping.map(t.activeHandle, -1);
      return au(e.doc.resolve(r)) || (r = -1), new Xo(r, t.dragging);
    }
    return t;
  }
};
function rC(n, e, t, i) {
  if (!n.editable) return;
  const r = Zt.getState(n.state);
  if (r && !r.dragging) {
    const s = lC(e.target);
    let o = -1;
    if (s) {
      const { left: a, right: l } = s.getBoundingClientRect();
      e.clientX - a <= t ? o = np(n, e, "left", t) : l - e.clientX <= t && (o = np(n, e, "right", t));
    }
    if (o != r.activeHandle) {
      if (!i && o !== -1) {
        const a = n.state.doc.resolve(o), l = a.node(-1), c = Ze.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      F_(n, o);
    }
  }
}
function sC(n) {
  if (!n.editable) return;
  const e = Zt.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && F_(n, -1);
}
function oC(n, e, t, i) {
  var r;
  if (!n.editable) return !1;
  const s = (r = n.dom.ownerDocument.defaultView) != null ? r : window, o = Zt.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const a = n.state.doc.nodeAt(o.activeHandle), l = aC(n, o.activeHandle, a.attrs);
  n.dispatch(
    n.state.tr.setMeta(Zt, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(d) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Zt.getState(n.state);
    f != null && f.dragging && (cC(
      n,
      f.activeHandle,
      ip(f.dragging, d, t)
    ), n.dispatch(
      n.state.tr.setMeta(Zt, { setDragging: null })
    ));
  }
  function u(d) {
    if (!d.which) return c(d);
    const f = Zt.getState(n.state);
    if (f && f.dragging) {
      const h = ip(f.dragging, d, t);
      rp(
        n,
        f.activeHandle,
        h,
        i
      );
    }
  }
  return rp(
    n,
    o.activeHandle,
    l,
    i
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function aC(n, e, { colspan: t, colwidth: i }) {
  const r = i && i[i.length - 1];
  if (r) return r;
  const s = n.domAtPos(e);
  let a = s.node.childNodes[s.offset].offsetWidth, l = t;
  if (i)
    for (let c = 0; c < t; c++)
      i[c] && (a -= i[c], l--);
  return a / l;
}
function lC(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function np(n, e, t, i) {
  const r = t == "right" ? -i : i, s = n.posAtCoords({
    left: e.clientX + r,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, a = qr(n.state.doc.resolve(o));
  if (!a) return -1;
  if (t == "right") return a.pos;
  const l = Ze.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function ip(n, e, t) {
  const i = e.clientX - n.startX;
  return Math.max(t, n.startWidth + i);
}
function F_(n, e) {
  n.dispatch(
    n.state.tr.setMeta(Zt, { setHandle: e })
  );
}
function cC(n, e, t) {
  const i = n.state.doc.resolve(e), r = i.node(-1), s = Ze.get(r), o = i.start(-1), a = s.colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1, l = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + a;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const d = s.map[u], f = r.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : a - s.colCount(d);
    if (f.colwidth && f.colwidth[h] == t) continue;
    const p = f.colwidth ? f.colwidth.slice() : uC(f.colspan);
    p[h] = t, l.setNodeMarkup(o + d, null, { ...f, colwidth: p });
  }
  l.docChanged && n.dispatch(l);
}
function rp(n, e, t, i) {
  const r = n.state.doc.resolve(e), s = r.node(-1), o = r.start(-1), a = Ze.get(s).colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1;
  let l = n.domAtPos(r.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && cu(
    s,
    l.firstChild,
    l,
    i,
    a,
    t
  );
}
function uC(n) {
  return Array(n).fill(0);
}
function dC(n, e) {
  var t;
  const i = [], r = n.doc.resolve(e), s = r.node(-1);
  if (!s)
    return je.empty;
  const o = Ze.get(s), a = r.start(-1), l = o.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = l + c * o.width;
    if ((l == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const d = o.map[u], f = a + d + s.nodeAt(d).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", (t = Zt.getState(n)) != null && t.dragging && i.push(
        gt.node(
          a + d,
          a + d + s.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), i.push(gt.widget(f, h));
    }
  }
  return je.create(n.doc, i);
}
function fC({
  allowTableNodeSelection: n = !1
} = {}) {
  return new Ge({
    key: fi,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const i = e.getMeta(fi);
        if (i != null) return i == -1 ? null : i;
        if (t == null || !e.docChanged) return t;
        const { deleted: r, pos: s } = e.mapping.mapResult(t);
        return r ? null : s;
      }
    },
    props: {
      decorations: CS,
      handleDOMEvents: {
        mousedown: eC
      },
      createSelectionBetween(e) {
        return fi.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: ZS,
      handleKeyDown: YS,
      handlePaste: QS
    },
    appendTransaction(e, t, i) {
      return AS(
        i,
        $_(i, t),
        n
      );
    }
  });
}
var V_ = Ie.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? e.split(",").map((i) => parseInt(i, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["td", Te(this.options.HTMLAttributes, n), 0];
  }
}), j_ = Ie.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? e.split(",").map((i) => parseInt(i, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["th", Te(this.options.HTMLAttributes, n), 0];
  }
}), W_ = Ie.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["tr", Te(this.options.HTMLAttributes, n), 0];
  }
});
function uu(n, e) {
  return e ? ["width", `${Math.max(e, n)}px`] : ["min-width", `${n}px`];
}
function sp(n, e, t, i, r, s) {
  var o;
  let a = 0, l = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u !== null)
    for (let d = 0, f = 0; d < u.childCount; d += 1) {
      const { colspan: h, colwidth: p } = u.child(d).attrs;
      for (let b = 0; b < h; b += 1, f += 1) {
        const m = r === f ? s : p && p[b], g = m ? `${m}px` : "";
        if (a += m || i, m || (l = !1), c) {
          if (c.style.width !== g) {
            const [v, x] = uu(i, m);
            c.style.setProperty(v, x);
          }
          c = c.nextSibling;
        } else {
          const v = document.createElement("col"), [x, w] = uu(i, m);
          v.style.setProperty(x, w), e.appendChild(v);
        }
      }
    }
  for (; c; ) {
    const d = c.nextSibling;
    (o = c.parentNode) == null || o.removeChild(c), c = d;
  }
  l ? (t.style.width = `${a}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${a}px`);
}
var hC = class {
  constructor(n, e) {
    this.node = n, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), sp(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type !== this.node.type ? !1 : (this.node = n, sp(n, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(n) {
    return n.type === "attributes" && (n.target === this.table || this.colgroup.contains(n.target));
  }
};
function pC(n, e, t, i) {
  let r = 0, s = !0;
  const o = [], a = n.firstChild;
  if (!a)
    return {};
  for (let d = 0, f = 0; d < a.childCount; d += 1) {
    const { colspan: h, colwidth: p } = a.child(d).attrs;
    for (let b = 0; b < h; b += 1, f += 1) {
      const m = t === f ? i : p && p[b];
      r += m || e, m || (s = !1);
      const [g, v] = uu(e, m);
      o.push(["col", { style: `${g}: ${v}` }]);
    }
  }
  const l = s ? `${r}px` : "", c = s ? "" : `${r}px`;
  return { colgroup: ["colgroup", {}, ...o], tableWidth: l, tableMinWidth: c };
}
function op(n, e) {
  return n.createAndFill();
}
function mC(n) {
  if (n.cached.tableNodeTypes)
    return n.cached.tableNodeTypes;
  const e = {};
  return Object.keys(n.nodes).forEach((t) => {
    const i = n.nodes[t];
    i.spec.tableRole && (e[i.spec.tableRole] = i);
  }), n.cached.tableNodeTypes = e, e;
}
function gC(n, e, t, i, r) {
  const s = mC(n), o = [], a = [];
  for (let c = 0; c < t; c += 1) {
    const u = op(s.cell);
    if (u && a.push(u), i) {
      const d = op(s.header_cell);
      d && o.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(s.row.createChecked(null, i && c === 0 ? o : a));
  return s.table.createChecked(null, l);
}
function _C(n) {
  return n instanceof We;
}
var Po = ({ editor: n }) => {
  const { selection: e } = n.state;
  if (!_C(e))
    return !1;
  let t = 0;
  const i = Qu(e.ranges[0].$from, (s) => s.type.name === "table");
  return i == null || i.node.descendants((s) => {
    if (s.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(s.type.name) && (t += 1);
  }), t === e.ranges.length ? (n.commands.deleteTable(), !0) : !1;
}, U_ = Ie.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: hC,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    const { colgroup: t, tableWidth: i, tableMinWidth: r } = pC(n, this.options.cellMinWidth);
    return [
      "table",
      Te(this.options.HTMLAttributes, e, {
        style: i ? `width: ${i}` : `min-width: ${r}`
      }),
      t,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: n = 3, cols: e = 3, withHeaderRow: t = !0 } = {}) => ({ tr: i, dispatch: r, editor: s }) => {
        const o = gC(s.schema, n, e, t);
        if (r) {
          const a = i.selection.from + 1;
          i.replaceSelectionWith(o).scrollIntoView().setSelection(ue.near(i.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: n, dispatch: e }) => NS(n, e),
      addColumnAfter: () => ({ state: n, dispatch: e }) => LS(n, e),
      deleteColumn: () => ({ state: n, dispatch: e }) => IS(n, e),
      addRowBefore: () => ({ state: n, dispatch: e }) => DS(n, e),
      addRowAfter: () => ({ state: n, dispatch: e }) => $S(n, e),
      deleteRow: () => ({ state: n, dispatch: e }) => zS(n, e),
      deleteTable: () => ({ state: n, dispatch: e }) => KS(n, e),
      mergeCells: () => ({ state: n, dispatch: e }) => Gh(n, e),
      splitCell: () => ({ state: n, dispatch: e }) => Jh(n, e),
      toggleHeaderColumn: () => ({ state: n, dispatch: e }) => Ws("column")(n, e),
      toggleHeaderRow: () => ({ state: n, dispatch: e }) => Ws("row")(n, e),
      toggleHeaderCell: () => ({ state: n, dispatch: e }) => WS(n, e),
      mergeOrSplit: () => ({ state: n, dispatch: e }) => Gh(n, e) ? !0 : Jh(n, e),
      setCellAttribute: (n, e) => ({ state: t, dispatch: i }) => VS(n, e)(t, i),
      goToNextCell: () => ({ state: n, dispatch: e }) => Yh(1)(n, e),
      goToPreviousCell: () => ({ state: n, dispatch: e }) => Yh(-1)(n, e),
      fixTables: () => ({ state: n, dispatch: e }) => (e && $_(n), !0),
      setCellSelection: (n) => ({ tr: e, dispatch: t }) => {
        if (t) {
          const i = We.create(e.doc, n.anchorCell, n.headCell);
          e.setSelection(i);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: Po,
      "Mod-Backspace": Po,
      Delete: Po,
      "Mod-Delete": Po
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        nC({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      fC({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(n) {
    const e = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      tableRole: Me(oe(n, "tableRole", e))
    };
  }
});
ze.create({
  name: "tableKit",
  addExtensions() {
    const n = [];
    return this.options.table !== !1 && n.push(U_.configure(this.options.table)), this.options.tableCell !== !1 && n.push(V_.configure(this.options.tableCell)), this.options.tableHeader !== !1 && n.push(j_.configure(this.options.tableHeader)), this.options.tableRow !== !1 && n.push(W_.configure(this.options.tableRow)), n;
  }
});
const bC = U_.extend({
  addAttributes() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      style: {
        default: "width: 100%;"
      }
    };
  },
  addOptions() {
    var e;
    const n = (e = this.parent) == null ? void 0 : e.call(this);
    return n && (n.View = class extends n.View {
      update(t) {
        return super.update(t), this.table.style.cssText = t.attrs.style, !0;
      }
    }), n;
  },
  // FIXME: renderHTML with customized attributes
  renderHTML({ HTMLAttributes: n }) {
    return ["table", n, 0];
  }
}), vC = V_.extend({
  content: "inline*",
  addAttributes() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      style: {
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes: n }) {
    const { colspan: e, rowspan: t, style: i, ...r } = n;
    return [
      "td",
      Te(r, {
        colspan: e === 1 ? void 0 : e,
        rowspan: t === 1 ? void 0 : t,
        style: i === "" ? void 0 : i
      }),
      0
    ];
  }
}), yC = j_.extend({
  content: "inline*",
  addAttributes() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      scope: {
        default: ""
      },
      style: {
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes: n }) {
    const { colspan: e, rowspan: t, scope: i, style: r, ...s } = n;
    return [
      "th",
      Te(s, {
        colspan: e === 1 ? void 0 : e,
        rowspan: t === 1 ? void 0 : t,
        scope: i === "" ? void 0 : i,
        style: r === "" ? void 0 : r
      }),
      0
    ];
  }
}), xC = ze.create({
  name: "indent",
  addOptions() {
    return {
      types: ["listItem", "paragraph"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          "data-mt-indent": {
            default: null,
            renderHTML: ({ "data-mt-indent": n }) => n && n !== "0" ? {
              style: `padding-left: ${n * 80}px`
            } : {},
            parseHTML: (n) => Number(n.getAttribute("data-mt-indent"))
          }
        }
      }
    ];
  },
  addCommands() {
    const n = (i, r, s) => {
      var a;
      const o = (a = i == null ? void 0 : i.doc) == null ? void 0 : a.nodeAt(r);
      if (o) {
        let { "data-mt-indent": l, ...c } = o.attrs;
        return l = (l || 0) + s, l > 0 && (c = { ...c, "data-mt-indent": l }), i.setNodeMarkup(r, o.type, c, o.marks);
      }
      return i;
    }, e = (i, r) => {
      const { doc: s, selection: o } = i;
      if (s && o && (o instanceof ue || o instanceof Ut)) {
        const { from: a, to: l } = o;
        s.nodesBetween(a, l, (c, u) => this.options.types.includes(c.type.name) ? (i = n(i, u, r), !1) : !0);
      }
      return i;
    }, t = (i) => () => ({ tr: r, state: s, dispatch: o }) => {
      const { selection: a } = s;
      return r = r.setSelection(a), r = e(r, i), r.docChanged ? (o == null || o(r), !0) : !1;
    };
    return {
      indent: t(1),
      outdent: t(-1)
    };
  }
}), wC = Ie.create({
  name: "div",
  priority: 1e3,
  group: "block",
  content: "block+",
  defining: !0,
  parseHTML() {
    return [
      { tag: "div" },
      { tag: "main" },
      { tag: "article" },
      { tag: "section" },
      { tag: "aside" },
      { tag: "nav" },
      { tag: "header" },
      { tag: "footer" },
      { tag: "figure" },
      { tag: "figcaption" },
      { tag: "details" },
      { tag: "dialog" }
    ];
  },
  renderHTML({ HTMLAttributes: n, node: e }) {
    return [
      e.attrs["data-tag"] || "div",
      Te(this.options.HTMLAttributes, n, {
        "data-tag": void 0
      }),
      0
    ];
  },
  addAttributes() {
    return {
      "data-tag": {
        default: "div",
        parseHTML: (n) => n.tagName.toLowerCase()
      }
    };
  }
}), kC = Qt.create({
  name: "span",
  priority: 1e3,
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "span"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", n, 0];
  }
});
var SC = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, CC = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, TC = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, EC = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, AC = Qt.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (n) => n.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (n) => n.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return /* @__PURE__ */ ya("strong", { ...Te(this.options.HTMLAttributes, n), children: /* @__PURE__ */ ya("slot", {}) });
  },
  addCommands() {
    return {
      setBold: () => ({ commands: n }) => n.setMark(this.name),
      toggleBold: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetBold: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Vr({
        find: SC,
        type: this.type
      }),
      Vr({
        find: TC,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ji({
        find: CC,
        type: this.type
      }),
      Ji({
        find: EC,
        type: this.type
      })
    ];
  }
});
const MC = AC.extend({
  priority: 1e3,
  content: "inline*"
}), OC = Ie.create({
  name: "blockLink",
  priority: 1e3,
  group: "block",
  content: "block+",
  defining: !0,
  addAttributes() {
    return {
      HTMLAttributes: {
        default: {},
        parseHTML: (n) => {
          const e = {};
          return Array.from(n.attributes).forEach((t) => {
            e[t.name] = t.value;
          }), e;
        },
        renderHTML: (n) => n.HTMLAttributes
      },
      "data-mt-rich-text-editor-block": {
        default: null,
        renderHTML: () => null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[data-mt-rich-text-editor-block]",
        getAttrs: (n) => n instanceof HTMLElement ? {
          href: n.getAttribute("href"),
          "data-mt-rich-text-editor-block": n.getAttribute(
            "data-mt-rich-text-editor-block"
          )
        } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { href: e } = n;
    return ["a", Te(this.options.HTMLAttributes, { href: e }), 0];
  },
  addCommands() {
    return {
      setBlockLink: (n = {}) => ({ commands: e }) => e.wrapIn(this.name, n),
      unsetBlockLink: () => ({ commands: n }) => n.lift(this.name)
    };
  }
}), NC = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", LC = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", du = "numeric", fu = "ascii", hu = "alpha", Ts = "asciinumeric", bs = "alphanumeric", pu = "domain", K_ = "emoji", RC = "scheme", IC = "slashscheme", mc = "whitespace";
function PC(n, e) {
  return n in e || (e[n] = []), e[n];
}
function Ri(n, e, t) {
  e[du] && (e[Ts] = !0, e[bs] = !0), e[fu] && (e[Ts] = !0, e[hu] = !0), e[Ts] && (e[bs] = !0), e[hu] && (e[bs] = !0), e[bs] && (e[pu] = !0), e[K_] && (e[pu] = !0);
  for (const i in e) {
    const r = PC(i, t);
    r.indexOf(n) < 0 && r.push(n);
  }
}
function DC(n, e) {
  const t = {};
  for (const i in e)
    e[i].indexOf(n) >= 0 && (t[i] = !0);
  return t;
}
function Wt(n = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = n;
}
Wt.groups = {};
Wt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(n) {
    const e = this, t = e.j[n];
    if (t)
      return t;
    for (let i = 0; i < e.jr.length; i++) {
      const r = e.jr[i][0], s = e.jr[i][1];
      if (s && r.test(n))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(n, e = !1) {
    return e ? n in this.j : !!this.go(n);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(n, e, t, i) {
    for (let r = 0; r < n.length; r++)
      this.tt(n[r], e, t, i);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(n, e, t, i) {
    i = i || Wt.groups;
    let r;
    return e && e.j ? r = e : (r = new Wt(e), t && i && Ri(e, t, i)), this.jr.push([n, r]), r;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(n, e, t, i) {
    let r = this;
    const s = n.length;
    if (!s)
      return r;
    for (let o = 0; o < s - 1; o++)
      r = r.tt(n[o]);
    return r.tt(n[s - 1], e, t, i);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(n, e, t, i) {
    i = i || Wt.groups;
    const r = this;
    if (e && e.j)
      return r.j[n] = e, e;
    const s = e;
    let o, a = r.go(n);
    if (a ? (o = new Wt(), Object.assign(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new Wt(), s) {
      if (i)
        if (o.t && typeof o.t == "string") {
          const l = Object.assign(DC(o.t, i), t);
          Ri(s, l, i);
        } else t && Ri(s, t, i);
      o.t = s;
    }
    return r.j[n] = o, o;
  }
};
const ke = (n, e, t, i, r) => n.ta(e, t, i, r), Xe = (n, e, t, i, r) => n.tr(e, t, i, r), ap = (n, e, t, i, r) => n.ts(e, t, i, r), W = (n, e, t, i, r) => n.tt(e, t, i, r), qn = "WORD", mu = "UWORD", q_ = "ASCIINUMERICAL", G_ = "ALPHANUMERICAL", Us = "LOCALHOST", gu = "TLD", _u = "UTLD", Yo = "SCHEME", fr = "SLASH_SCHEME", kd = "NUM", bu = "WS", Sd = "NL", Es = "OPENBRACE", As = "CLOSEBRACE", wa = "OPENBRACKET", ka = "CLOSEBRACKET", Sa = "OPENPAREN", Ca = "CLOSEPAREN", Ta = "OPENANGLEBRACKET", Ea = "CLOSEANGLEBRACKET", Aa = "FULLWIDTHLEFTPAREN", Ma = "FULLWIDTHRIGHTPAREN", Oa = "LEFTCORNERBRACKET", Na = "RIGHTCORNERBRACKET", La = "LEFTWHITECORNERBRACKET", Ra = "RIGHTWHITECORNERBRACKET", Ia = "FULLWIDTHLESSTHAN", Pa = "FULLWIDTHGREATERTHAN", Da = "AMPERSAND", $a = "APOSTROPHE", Ba = "ASTERISK", ci = "AT", za = "BACKSLASH", Ha = "BACKTICK", Fa = "CARET", hi = "COLON", Cd = "COMMA", Va = "DOLLAR", Rn = "DOT", ja = "EQUALS", Td = "EXCLAMATION", cn = "HYPHEN", Ms = "PERCENT", Wa = "PIPE", Ua = "PLUS", Ka = "POUND", Os = "QUERY", Ed = "QUOTE", J_ = "FULLWIDTHMIDDLEDOT", Ad = "SEMI", In = "SLASH", Ns = "TILDE", qa = "UNDERSCORE", X_ = "EMOJI", Ga = "SYM";
var Y_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: G_,
  AMPERSAND: Da,
  APOSTROPHE: $a,
  ASCIINUMERICAL: q_,
  ASTERISK: Ba,
  AT: ci,
  BACKSLASH: za,
  BACKTICK: Ha,
  CARET: Fa,
  CLOSEANGLEBRACKET: Ea,
  CLOSEBRACE: As,
  CLOSEBRACKET: ka,
  CLOSEPAREN: Ca,
  COLON: hi,
  COMMA: Cd,
  DOLLAR: Va,
  DOT: Rn,
  EMOJI: X_,
  EQUALS: ja,
  EXCLAMATION: Td,
  FULLWIDTHGREATERTHAN: Pa,
  FULLWIDTHLEFTPAREN: Aa,
  FULLWIDTHLESSTHAN: Ia,
  FULLWIDTHMIDDLEDOT: J_,
  FULLWIDTHRIGHTPAREN: Ma,
  HYPHEN: cn,
  LEFTCORNERBRACKET: Oa,
  LEFTWHITECORNERBRACKET: La,
  LOCALHOST: Us,
  NL: Sd,
  NUM: kd,
  OPENANGLEBRACKET: Ta,
  OPENBRACE: Es,
  OPENBRACKET: wa,
  OPENPAREN: Sa,
  PERCENT: Ms,
  PIPE: Wa,
  PLUS: Ua,
  POUND: Ka,
  QUERY: Os,
  QUOTE: Ed,
  RIGHTCORNERBRACKET: Na,
  RIGHTWHITECORNERBRACKET: Ra,
  SCHEME: Yo,
  SEMI: Ad,
  SLASH: In,
  SLASH_SCHEME: fr,
  SYM: Ga,
  TILDE: Ns,
  TLD: gu,
  UNDERSCORE: qa,
  UTLD: _u,
  UWORD: mu,
  WORD: qn,
  WS: bu
});
const Wn = /[a-z]/, ss = new RegExp("\\p{L}", "u"), gc = new RegExp("\\p{Emoji}", "u"), Un = /\d/, _c = /\s/, lp = "\r", bc = `
`, $C = "", BC = "", vc = "";
let Do = null, $o = null;
function zC(n = []) {
  const e = {};
  Wt.groups = e;
  const t = new Wt();
  Do == null && (Do = cp(NC)), $o == null && ($o = cp(LC)), W(t, "'", $a), W(t, "{", Es), W(t, "}", As), W(t, "[", wa), W(t, "]", ka), W(t, "(", Sa), W(t, ")", Ca), W(t, "<", Ta), W(t, ">", Ea), W(t, "", Aa), W(t, "", Ma), W(t, "", Oa), W(t, "", Na), W(t, "", La), W(t, "", Ra), W(t, "", Ia), W(t, "", Pa), W(t, "&", Da), W(t, "*", Ba), W(t, "@", ci), W(t, "`", Ha), W(t, "^", Fa), W(t, ":", hi), W(t, ",", Cd), W(t, "$", Va), W(t, ".", Rn), W(t, "=", ja), W(t, "!", Td), W(t, "-", cn), W(t, "%", Ms), W(t, "|", Wa), W(t, "+", Ua), W(t, "#", Ka), W(t, "?", Os), W(t, '"', Ed), W(t, "/", In), W(t, ";", Ad), W(t, "~", Ns), W(t, "_", qa), W(t, "\\", za), W(t, "", J_);
  const i = Xe(t, Un, kd, {
    [du]: !0
  });
  Xe(i, Un, i);
  const r = Xe(i, Wn, q_, {
    [Ts]: !0
  }), s = Xe(i, ss, G_, {
    [bs]: !0
  }), o = Xe(t, Wn, qn, {
    [fu]: !0
  });
  Xe(o, Un, r), Xe(o, Wn, o), Xe(r, Un, r), Xe(r, Wn, r);
  const a = Xe(t, ss, mu, {
    [hu]: !0
  });
  Xe(a, Wn), Xe(a, Un, s), Xe(a, ss, a), Xe(s, Un, s), Xe(s, Wn), Xe(s, ss, s);
  const l = W(t, bc, Sd, {
    [mc]: !0
  }), c = W(t, lp, bu, {
    [mc]: !0
  }), u = Xe(t, _c, bu, {
    [mc]: !0
  });
  W(t, vc, u), W(c, bc, l), W(c, vc, u), Xe(c, _c, u), W(u, lp), W(u, bc), Xe(u, _c, u), W(u, vc, u);
  const d = Xe(t, gc, X_, {
    [K_]: !0
  });
  W(d, "#"), Xe(d, gc, d), W(d, $C, d);
  const f = W(d, BC);
  W(f, "#"), Xe(f, gc, d);
  const h = [[Wn, o], [Un, r]], p = [[Wn, null], [ss, a], [Un, s]];
  for (let b = 0; b < Do.length; b++)
    si(t, Do[b], gu, qn, h);
  for (let b = 0; b < $o.length; b++)
    si(t, $o[b], _u, mu, p);
  Ri(gu, {
    tld: !0,
    ascii: !0
  }, e), Ri(_u, {
    utld: !0,
    alpha: !0
  }, e), si(t, "file", Yo, qn, h), si(t, "mailto", Yo, qn, h), si(t, "http", fr, qn, h), si(t, "https", fr, qn, h), si(t, "ftp", fr, qn, h), si(t, "ftps", fr, qn, h), Ri(Yo, {
    scheme: !0,
    ascii: !0
  }, e), Ri(fr, {
    slashscheme: !0,
    ascii: !0
  }, e), n = n.sort((b, m) => b[0] > m[0] ? 1 : -1);
  for (let b = 0; b < n.length; b++) {
    const m = n[b][0], v = n[b][1] ? {
      [RC]: !0
    } : {
      [IC]: !0
    };
    m.indexOf("-") >= 0 ? v[pu] = !0 : Wn.test(m) ? Un.test(m) ? v[Ts] = !0 : v[fu] = !0 : v[du] = !0, ap(t, m, m, v);
  }
  return ap(t, "localhost", Us, {
    ascii: !0
  }), t.jd = new Wt(Ga), {
    start: t,
    tokens: Object.assign({
      groups: e
    }, Y_)
  };
}
function Z_(n, e) {
  const t = HC(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), i = t.length, r = [];
  let s = 0, o = 0;
  for (; o < i; ) {
    let a = n, l = null, c = 0, u = null, d = -1, f = -1;
    for (; o < i && (l = a.go(t[o])); )
      a = l, a.accepts() ? (d = 0, f = 0, u = a) : d >= 0 && (d += t[o].length, f++), c += t[o].length, s += t[o].length, o++;
    s -= d, o -= f, c -= d, r.push({
      t: u.t,
      // token type/name
      v: e.slice(s - c, s),
      // string value
      s: s - c,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return r;
}
function HC(n) {
  const e = [], t = n.length;
  let i = 0;
  for (; i < t; ) {
    let r = n.charCodeAt(i), s, o = r < 55296 || r > 56319 || i + 1 === t || (s = n.charCodeAt(i + 1)) < 56320 || s > 57343 ? n[i] : n.slice(i, i + 2);
    e.push(o), i += o.length;
  }
  return e;
}
function si(n, e, t, i, r) {
  let s;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    n.j[l] ? s = n.j[l] : (s = new Wt(i), s.jr = r.slice(), n.j[l] = s), n = s;
  }
  return s = new Wt(t), s.jr = r.slice(), n.j[e[o - 1]] = s, s;
}
function cp(n) {
  const e = [], t = [];
  let i = 0, r = "0123456789";
  for (; i < n.length; ) {
    let s = 0;
    for (; r.indexOf(n[i + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(t.join(""));
      for (let o = parseInt(n.substring(i, i + s), 10); o > 0; o--)
        t.pop();
      i += s;
    } else
      t.push(n[i]), i++;
  }
  return e;
}
const Ks = {
  defaultProtocol: "http",
  events: null,
  format: up,
  formatHref: up,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Md(n, e = null) {
  let t = Object.assign({}, Ks);
  n && (t = Object.assign(t, n instanceof Md ? n.o : n));
  const i = t.ignoreTags, r = [];
  for (let s = 0; s < i.length; s++)
    r.push(i[s].toUpperCase());
  this.o = t, e && (this.defaultRender = e), this.ignoreTags = r;
}
Md.prototype = {
  o: Ks,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(n) {
    return n;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(n) {
    return this.get("validate", n.toString(), n);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(n, e, t) {
    const i = e != null;
    let r = this.o[n];
    return r && (typeof r == "object" ? (r = t.t in r ? r[t.t] : Ks[n], typeof r == "function" && i && (r = r(e, t))) : typeof r == "function" && i && (r = r(e, t.t, t)), r);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(n, e, t) {
    let i = this.o[n];
    return typeof i == "function" && e != null && (i = i(e, t.t, t)), i;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(n) {
    const e = n.render(this);
    return (this.get("render", null, n) || this.defaultRender)(e, n.t, n);
  }
};
function up(n) {
  return n;
}
function Q_(n, e) {
  this.t = "token", this.v = n, this.tk = e;
}
Q_.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(n) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(n) {
    const e = this.toString(), t = n.get("truncate", e, this), i = n.get("format", e, this);
    return t && i.length > t ? i.substring(0, t) + "" : i;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(n) {
    return n.get("formatHref", this.toHref(n.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(n = Ks.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(n),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(n) {
    return {
      type: this.t,
      value: this.toFormattedString(n),
      isLink: this.isLink,
      href: this.toFormattedHref(n),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(n) {
    return n.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(n) {
    const e = this, t = this.toHref(n.get("defaultProtocol")), i = n.get("formatHref", t, this), r = n.get("tagName", t, e), s = this.toFormattedString(n), o = {}, a = n.get("className", t, e), l = n.get("target", t, e), c = n.get("rel", t, e), u = n.getObj("attributes", t, e), d = n.getObj("events", t, e);
    return o.href = i, a && (o.class = a), l && (o.target = l), c && (o.rel = c), u && Object.assign(o, u), {
      tagName: r,
      attributes: o,
      content: s,
      eventListeners: d
    };
  }
};
function xl(n, e) {
  class t extends Q_ {
    constructor(r, s) {
      super(r, s), this.t = n;
    }
  }
  for (const i in e)
    t.prototype[i] = e[i];
  return t.t = n, t;
}
const dp = xl("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), fp = xl("text"), FC = xl("nl"), Bo = xl("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(n = Ks.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${n}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const n = this.tk;
    return n.length >= 2 && n[0].t !== Us && n[1].t === hi;
  }
}), ln = (n) => new Wt(n);
function VC({
  groups: n
}) {
  const e = n.domain.concat([Da, Ba, ci, za, Ha, Fa, Va, ja, cn, kd, Ms, Wa, Ua, Ka, In, Ga, Ns, qa]), t = [$a, hi, Cd, Rn, Td, Ms, Os, Ed, Ad, Ta, Ea, Es, As, ka, wa, Sa, Ca, Aa, Ma, Oa, Na, La, Ra, Ia, Pa], i = [Da, $a, Ba, za, Ha, Fa, Va, ja, cn, Es, As, Ms, Wa, Ua, Ka, Os, In, Ga, Ns, qa], r = ln(), s = W(r, Ns);
  ke(s, i, s), ke(s, n.domain, s);
  const o = ln(), a = ln(), l = ln();
  ke(r, n.domain, o), ke(r, n.scheme, a), ke(r, n.slashscheme, l), ke(o, i, s), ke(o, n.domain, o);
  const c = W(o, ci);
  W(s, ci, c), W(a, ci, c), W(l, ci, c);
  const u = W(s, Rn);
  ke(u, i, s), ke(u, n.domain, s);
  const d = ln();
  ke(c, n.domain, d), ke(d, n.domain, d);
  const f = W(d, Rn);
  ke(f, n.domain, d);
  const h = ln(dp);
  ke(f, n.tld, h), ke(f, n.utld, h), W(c, Us, h);
  const p = W(d, cn);
  W(p, cn, p), ke(p, n.domain, d), ke(h, n.domain, d), W(h, Rn, f), W(h, cn, p);
  const b = W(h, hi);
  ke(b, n.numeric, dp);
  const m = W(o, cn), g = W(o, Rn);
  W(m, cn, m), ke(m, n.domain, o), ke(g, i, s), ke(g, n.domain, o);
  const v = ln(Bo);
  ke(g, n.tld, v), ke(g, n.utld, v), ke(v, n.domain, o), ke(v, i, s), W(v, Rn, g), W(v, cn, m), W(v, ci, c);
  const x = W(v, hi), w = ln(Bo);
  ke(x, n.numeric, w);
  const S = ln(Bo), k = ln();
  ke(S, e, S), ke(S, t, k), ke(k, e, S), ke(k, t, k), W(v, In, S), W(w, In, S);
  const C = W(a, hi), y = W(l, hi), A = W(y, In), _ = W(A, In);
  ke(a, n.domain, o), W(a, Rn, g), W(a, cn, m), ke(l, n.domain, o), W(l, Rn, g), W(l, cn, m), ke(C, n.domain, S), W(C, In, S), W(C, Os, S), ke(_, n.domain, S), ke(_, e, S), W(_, In, S);
  const T = [
    [Es, As],
    // {}
    [wa, ka],
    // []
    [Sa, Ca],
    // ()
    [Ta, Ea],
    // <>
    [Aa, Ma],
    // 
    [Oa, Na],
    // 
    [La, Ra],
    // 
    [Ia, Pa]
    // 
  ];
  for (let M = 0; M < T.length; M++) {
    const [z, P] = T[M], V = W(S, z);
    W(k, z, V), W(V, P, S);
    const U = ln(Bo);
    ke(V, e, U);
    const J = ln();
    ke(V, t), ke(U, e, U), ke(U, t, J), ke(J, e, U), ke(J, t, J), W(U, P, S), W(J, P, S);
  }
  return W(r, Us, v), W(r, Sd, FC), {
    start: r,
    tokens: Y_
  };
}
function jC(n, e, t) {
  let i = t.length, r = 0, s = [], o = [];
  for (; r < i; ) {
    let a = n, l = null, c = null, u = 0, d = null, f = -1;
    for (; r < i && !(l = a.go(t[r].t)); )
      o.push(t[r++]);
    for (; r < i && (c = l || a.go(t[r].t)); )
      l = null, a = c, a.accepts() ? (f = 0, d = a) : f >= 0 && f++, r++, u++;
    if (f < 0)
      r -= u, r < i && (o.push(t[r]), r++);
    else {
      o.length > 0 && (s.push(yc(fp, e, o)), o = []), r -= f, u -= f;
      const h = d.t, p = t.slice(r - u, r);
      s.push(yc(h, e, p));
    }
  }
  return o.length > 0 && s.push(yc(fp, e, o)), s;
}
function yc(n, e, t) {
  const i = t[0].s, r = t[t.length - 1].e, s = e.slice(i, r);
  return new n(s, t);
}
const WC = typeof console < "u" && console && console.warn || (() => {
}), UC = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Ke = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function KC() {
  return Wt.groups = {}, Ke.scanner = null, Ke.parser = null, Ke.tokenQueue = [], Ke.pluginQueue = [], Ke.customSchemes = [], Ke.initialized = !1, Ke;
}
function hp(n, e = !1) {
  if (Ke.initialized && WC(`linkifyjs: already initialized - will not register custom scheme "${n}" ${UC}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Ke.customSchemes.push([n, e]);
}
function qC() {
  Ke.scanner = zC(Ke.customSchemes);
  for (let n = 0; n < Ke.tokenQueue.length; n++)
    Ke.tokenQueue[n][1]({
      scanner: Ke.scanner
    });
  Ke.parser = VC(Ke.scanner.tokens);
  for (let n = 0; n < Ke.pluginQueue.length; n++)
    Ke.pluginQueue[n][1]({
      scanner: Ke.scanner,
      parser: Ke.parser
    });
  return Ke.initialized = !0, Ke;
}
function Od(n) {
  return Ke.initialized || qC(), jC(Ke.parser.start, n, Z_(Ke.scanner.start, n));
}
Od.scan = Z_;
function e0(n, e = null, t = null) {
  if (e && typeof e == "object") {
    if (t)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    t = e, e = null;
  }
  const i = new Md(t), r = Od(n), s = [];
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.isLink && (!e || a.t === e) && i.check(a) && s.push(a.toFormattedObject(i));
  }
  return s;
}
var Nd = "[\0- -\u2029]", GC = new RegExp(Nd), JC = new RegExp(`${Nd}$`), XC = new RegExp(Nd, "g");
function YC(n) {
  return n.length === 1 ? n[0].isLink : n.length === 3 && n[1].isLink ? ["()", "[]"].includes(n[0].value + n[2].value) : !1;
}
function ZC(n) {
  return new Ge({
    key: new lt("autolink"),
    appendTransaction: (e, t, i) => {
      const r = e.some((c) => c.docChanged) && !t.doc.eq(i.doc), s = e.some((c) => c.getMeta("preventAutolink"));
      if (!r || s)
        return;
      const { tr: o } = i, a = Zu(t.doc, [...e]);
      if (ad(a).forEach(({ newRange: c }) => {
        const u = Mg(i.doc, c, (h) => h.isTextblock);
        let d, f;
        if (u.length > 1)
          d = u[0], f = i.doc.textBetween(
            d.pos,
            d.pos + d.node.nodeSize,
            void 0,
            " "
          );
        else if (u.length) {
          const h = i.doc.textBetween(c.from, c.to, " ", " ");
          if (!JC.test(h))
            return;
          d = u[0], f = i.doc.textBetween(d.pos, c.to, void 0, " ");
        }
        if (d && f) {
          const h = f.split(GC).filter(Boolean);
          if (h.length <= 0)
            return !1;
          const p = h[h.length - 1], b = d.pos + f.lastIndexOf(p);
          if (!p)
            return !1;
          const m = Od(p).map((g) => g.toObject(n.defaultProtocol));
          if (!YC(m))
            return !1;
          m.filter((g) => g.isLink).map((g) => ({
            ...g,
            from: b + g.start + 1,
            to: b + g.end + 1
          })).filter((g) => i.schema.marks.code ? !i.doc.rangeHasMark(g.from, g.to, i.schema.marks.code) : !0).filter((g) => n.validate(g.value)).filter((g) => n.shouldAutoLink(g.value)).forEach((g) => {
            ml(g.from, g.to, i.doc).some((v) => v.mark.type === n.type) || o.addMark(
              g.from,
              g.to,
              n.type.create({
                href: g.href
              })
            );
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function QC(n) {
  return new Ge({
    key: new lt("handleClickLink"),
    props: {
      handleClick: (e, t, i) => {
        var r, s;
        if (i.button !== 0 || !e.editable)
          return !1;
        let o = null;
        if (i.target instanceof HTMLAnchorElement)
          o = i.target;
        else {
          let u = i.target;
          const d = [];
          for (; u.nodeName !== "DIV"; )
            d.push(u), u = u.parentNode;
          o = d.find((f) => f.nodeName === "A");
        }
        if (!o)
          return !1;
        const a = od(e.state, n.type.name), l = (r = o == null ? void 0 : o.href) != null ? r : a.href, c = (s = o == null ? void 0 : o.target) != null ? s : a.target;
        return n.enableClickSelection && n.editor.commands.extendMarkRange(n.type.name), o && l ? (window.open(l, c), !0) : !1;
      }
    }
  });
}
function eT(n) {
  return new Ge({
    key: new lt("handlePasteLink"),
    props: {
      handlePaste: (e, t, i) => {
        const { state: r } = e, { selection: s } = r, { empty: o } = s;
        if (o)
          return !1;
        let a = "";
        i.content.forEach((c) => {
          a += c.textContent;
        });
        const l = e0(a, { defaultProtocol: n.defaultProtocol }).find(
          (c) => c.isLink && c.value === a
        );
        return !a || !l ? !1 : n.editor.commands.setMark(n.type, {
          href: l.href
        });
      }
    }
  });
}
function Ai(n, e) {
  const t = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return e && e.forEach((i) => {
    const r = typeof i == "string" ? i : i.scheme;
    r && t.push(r);
  }), !n || n.replace(XC, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${t.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var tT = Qt.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((n) => {
      if (typeof n == "string") {
        hp(n);
        return;
      }
      hp(n.scheme, n.optionalSlashes);
    });
  },
  onDestroy() {
    KC();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (n, e) => !!Ai(n, e.protocols),
      validate: (n) => !!n,
      shouldAutoLink: (n) => !!n
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(n) {
          return n.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (n) => {
          const e = n.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (t) => !!Ai(t, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return this.options.isAllowedUri(n.href, {
      defaultValidate: (e) => !!Ai(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Te(this.options.HTMLAttributes, n), 0] : ["a", Te(this.options.HTMLAttributes, { ...n, href: "" }), 0];
  },
  addCommands() {
    return {
      setLink: (n) => ({ chain: e }) => {
        const { href: t } = n;
        return this.options.isAllowedUri(t, {
          defaultValidate: (i) => !!Ai(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, n).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (n) => ({ chain: e }) => {
        const { href: t } = n || {};
        return t && !this.options.isAllowedUri(t, {
          defaultValidate: (i) => !!Ai(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : e().toggleMark(this.name, n, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: n }) => n().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ji({
        find: (n) => {
          const e = [];
          if (n) {
            const { protocols: t, defaultProtocol: i } = this.options, r = e0(n).filter(
              (s) => s.isLink && this.options.isAllowedUri(s.value, {
                defaultValidate: (o) => !!Ai(o, t),
                protocols: t,
                defaultProtocol: i
              })
            );
            r.length && r.forEach(
              (s) => e.push({
                text: s.value,
                data: {
                  href: s.href
                },
                index: s.start
              })
            );
          }
          return e;
        },
        type: this.type,
        getAttributes: (n) => {
          var e;
          return {
            href: (e = n.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const n = [], { protocols: e, defaultProtocol: t } = this.options;
    return this.options.autolink && n.push(
      ZC({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (i) => this.options.isAllowedUri(i, {
          defaultValidate: (r) => !!Ai(r, e),
          protocols: e,
          defaultProtocol: t
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), this.options.openOnClick === !0 && n.push(
      QC({
        type: this.type,
        editor: this.editor,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && n.push(
      eT({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      })
    ), n;
  }
});
const nT = tT.extend({
  addOptions() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      shortcutHandler: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(n) {
          return n.getAttribute("href");
        }
      },
      target: {
        default: null
      },
      title: {
        default: null
      },
      rel: {
        default: null
      },
      class: {
        default: null
      },
      "data-inline": {
        default: "true",
        renderHTML: () => null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a:not([data-mt-rich-text-editor-block])",
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement))
            return !1;
          const e = {};
          return Array.from(n.attributes).forEach((t) => {
            e[t.name] = t.value;
          }), {
            HTMLAttributes: e,
            "data-inline": n.getAttribute("data-inline")
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { HTMLAttributes: e = {}, ...t } = n;
    return ["a", { ...e, ...t, "data-inline": void 0 }, 0];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-k": () => {
        var n, e;
        return (e = (n = this.options).shortcutHandler) == null || e.call(n), !0;
      }
    };
  },
  addCommands() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      setInlineLinkShortcutHandler: (e) => () => {
        this.options.shortcutHandler = e;
      }
    };
  }
});
var iT = Ie.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["p", Te(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: n }) => n.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const rT = iT.extend({
  name: "paragraph",
  priority: 1e3,
  group: "block",
  content: "inline*",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    const { MTRichTextEditorHTMLAttributes: t, textAlign: i, ...r } = n.attrs;
    return ["p", Te(this.options.HTMLAttributes, r, e), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: n }) => n.setNode(this.name)
    };
  }
}), sT = Ie.create({
  name: "textBlock",
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "mt-text-block",
        getAttrs: (n) => n instanceof HTMLElement ? {} : !1
      }
    ];
  },
  renderHTML() {
    return ["mt-text-block", 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: ({ editor: n }) => {
        if (!n.isActive(this.name))
          return !1;
        const { state: e } = n, { selection: t } = e, { $from: i } = t, r = i.node(-1);
        if (!r) return !1;
        const s = i.after(-1), o = i.parent.content.cut(i.parentOffset).toJSON();
        if (!n.chain().insertContentAt(s, {
          type: r.type.name,
          content: [
            {
              type: this.name,
              content: o
            }
          ]
        }).deleteRange({ from: i.pos, to: i.after() }).run()) return !1;
        const u = n.state.doc.resolve(s + 1).start();
        return n.chain().setTextSelection(u).focus().run(), !0;
      }
    };
  },
  addStorage() {
    return {
      originalText: ""
    };
  }
}), oT = Ie.create({
  name: "pre",
  priority: 1e3,
  group: "block",
  content: "inline*|text*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["pre", n, 0];
  },
  addCommands() {
    return {
      setPre: () => ({ commands: n }) => n.setNode(this.name),
      unsetPre: () => ({ commands: n }) => n.setNode("paragraph")
    };
  }
}), aT = Ie.create({
  name: "code",
  priority: 1e3,
  group: "inline",
  inline: !0,
  content: "text*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "code",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["code", n, 0];
  }
}), lT = Ie.create({
  name: "descriptionList",
  priority: 1e3,
  group: "block",
  content: "(descriptionTerm|descriptionDetails)+",
  defining: !0,
  parseHTML() {
    return [{ tag: "dl" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["dl", n, 0];
  }
}), cT = Ie.create({
  name: "descriptionTerm",
  priority: 1e3,
  group: "block",
  content: "(textBlock|paragraph) block*",
  defining: !0,
  parseHTML() {
    return [{ tag: "dt" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["dt", n, 0];
  }
}), uT = Ie.create({
  name: "descriptionDetails",
  priority: 1e3,
  group: "block",
  content: "(textBlock|paragraph) block*",
  defining: !0,
  parseHTML() {
    return [{ tag: "dd" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["dd", n, 0];
  }
}), dT = Ie.create({
  name: "summary",
  priority: 1e3,
  group: "block",
  content: "inline*",
  defining: !0,
  parseHTML() {
    return [{ tag: "summary" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["summary", n, 0];
  }
}), fT = w_.extend({
  name: "listItem",
  priority: 1e3,
  content: "(textBlock|block)*",
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Te(this.options.HTMLAttributes, n), 0];
  }
}), hT = Ie.create({
  name: "script",
  group: "inline",
  content: "text*",
  inline: !0,
  atom: !0,
  parseHTML() {
    return [
      {
        tag: "mt-rich-text-editor-script",
        preserveWhitespace: "full"
      }
    ];
  },
  addNodeView() {
    const n = ["https://gist.github.com"];
    return ({ node: e }) => {
      const t = document.createElement("div");
      t.classList.add("mt-rich-text-editor-script");
      const i = e.attrs.MTRichTextEditorHTMLAttributes || {};
      t.dataset.mtRichTextEditorScriptTitle = "<script " + Object.entries(i).map(([o, a]) => `${o}="${a}"`).join(" ") + "/>";
      const r = i.src, s = r && (() => {
        try {
          return new URL(r).origin;
        } catch {
          return;
        }
      })();
      if (s && n.some((o) => s === o)) {
        t.classList.add("mt-rich-text-editor-script--preview");
        const o = document.createElement("iframe");
        o.style.width = "100%", o.style.border = "none";
        const a = `
          <!DOCTYPE html>
          <html>
            <head>
              <style>
                html, body {
                  margin: 0;
                  padding: 0;
                  overflow: hidden;
                }
                ::-webkit-scrollbar {
                  display: none;
                }
              </style>
              <script>
                const resizeObserver = new ResizeObserver((entries) => {
                  const height = document.body.scrollHeight;
                  window.frameElement.style.height = \`\${height}px\`;
                });

                window.addEventListener('load', () => {
                  resizeObserver.observe(document.body);
                });

                const events = ['mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu', 'mousemove'];
                events.forEach(eventName => {
                  document.addEventListener(eventName, (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    window.frameElement.click();
                  }, true);
                });
              <\/script>
              <script src="${r}"><\/script>
            </head>
            <body></body>
          </html>
        `;
        return o.srcdoc = a, t.appendChild(o), {
          dom: t
        };
      }
      return t.innerText = e.content.content.map((o) => o.text).join("").replace(/^\n/, "").replace(/\s+$/, ""), {
        dom: t
      };
    };
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["mt-rich-text-editor-script", n, 0];
  }
}), pT = Ie.create({
  name: "embedObject",
  priority: 1e3,
  group: "block",
  content: "block*",
  defining: !0,
  addAttributes() {
    return {
      "data-mt-rich-text-editor-block": {
        default: null,
        renderHTML: () => null
      },
      content: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mt-rich-text-editor-embed-object",
        getAttrs: (n) => n instanceof HTMLElement ? {
          href: n.getAttribute("href"),
          "data-mt-rich-text-editor-block": n.getAttribute(
            "data-mt-rich-text-editor-block"
          ),
          content: n.getAttribute("data-mt-rich-text-editor-content") || n.innerHTML
        } : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "mt-rich-text-editor-embed-object",
      Te(this.options.HTMLAttributes, {
        "data-mt-rich-text-editor-content": n.content
      }),
      0
    ];
  },
  addNodeView() {
    return ({ node: n }) => {
      const e = document.createElement("iframe");
      e.setAttribute("frameborder", "0"), e.setAttribute("allowfullscreen", "true"), e.style.width = "100%";
      const t = `
      <!DOCTYPE html>
      <html>
        <head>
          <style>
            html, body {
              margin: 0;
              padding: 0;
              overflow: hidden;
            }
            ::-webkit-scrollbar {
              display: none;
            }
          </style>
          <script>
            const resizeObserver = new ResizeObserver((entries) => {
              const height = document.body.scrollHeight;
              const width = document.body.scrollWidth;
              window.frameElement.style.height = \`\${height}px\`;
              window.frameElement.style.width = \`\${width}px\`;
            });
            
            window.addEventListener('load', () => {
              resizeObserver.observe(document.body);
            });

            const events = ['mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu', 'mousemove'];
            events.forEach(eventName => {
              document.addEventListener(eventName, (e) => {
                e.stopPropagation();
                e.preventDefault();
                window.frameElement.click();
              }, true);
            });
          <\/script>
        </head>
        <body>
          ${n.attrs.content}
        </body>
      </html>
    `;
      return e.srcdoc = t, {
        dom: e,
        update: () => !0
      };
    };
  },
  addCommands() {
    return {
      getEmbedObject: (n) => () => this.options.resolver(n),
      insertEmbedObject: (n) => ({ state: e, commands: t }) => {
        const i = e.selection.$anchor.pos;
        return t.insertContent({
          type: this.name,
          attrs: {
            content: n
          }
        }), t.setTextSelection(i + 2), !0;
      }
    };
  }
}), mT = ze.create({
  name: "markdown",
  addCommands() {
    return {
      // FIXME: fix type error
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      isMarkdownConversionAvailable: () => () => !!this.options.toHtml,
      // FIXME: fix type error
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      markdownToHtml: (n) => () => this.options.toHtml(n)
    };
  }
}), gT = aS.extend({
  addOptions() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      registerShortcuts: !0
    };
  },
  addKeyboardShortcuts() {
    var n;
    return this.options.registerShortcuts ? ((n = this.parent) == null ? void 0 : n.call(this)) ?? {} : {};
  }
}), _T = /* @__PURE__ */ new Set([
  "onabortonblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncontextmenu",
  "oncuechange",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onmousedown",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onmousewheel",
  "onpause",
  "onplay",
  "onplaying",
  "onprogress",
  "onratechange",
  "onreset",
  "onscroll",
  "onseeked",
  "onseeking",
  "onseeking",
  "onselect",
  "onshow",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "onvolumechange",
  "onwaiting",
  "formaction",
  "action"
]), bT = ze.create({
  name: "mt-rich-text-editor-global",
  addGlobalAttributes() {
    return [
      {
        types: [
          "div",
          "pre",
          "code",
          "blockquote",
          "bulletList",
          "document",
          "embedObject",
          "hardBreak",
          "heading",
          "horizontalRule",
          "iframe",
          "image",
          "inlineLink",
          "listItem",
          "orderedList",
          "paragraph",
          "span",
          "textStyle",
          "script",
          "table",
          "tableRow",
          "tableCell",
          "tableHeader",
          "link",
          "blockLink",
          "descriptionList",
          "descriptionTerm",
          "descriptionDetails"
        ],
        attributes: {
          MTRichTextEditorHTMLAttributes: {
            default: {},
            parseHTML: (n) => {
              const e = {}, t = {};
              for (const i of n.attributes)
                /^data-mt-rich-text-editor-/.test(i.name) || (_T.has(i.name.toLowerCase()) ? t[i.name] = i.value : e[i.name] = i.value);
              return Object.keys(t).length > 0 && (e["data-mt-rich-text-editor-event-attributes"] = JSON.stringify(t)), e;
            },
            renderHTML: (n) => n.MTRichTextEditorHTMLAttributes
          }
        }
      }
    ];
  }
});
window.customElements.define(
  "mt-rich-text-editor-mt-function-tag",
  class extends HTMLElement {
    connectedCallback() {
      this.style.color = "#9333ea", this.style.fontFamily = "monospace";
      const n = ["data-tag-name", "contenteditable", "style", "class"], e = this.getAttribute("data-tag-name");
      if (!e)
        return;
      let t = "";
      Array.from(this.attributes).filter((i) => !n.includes(i.name)).forEach((i) => {
        t += ` ${i.name}="${i.value}"`;
      }), this.textContent = `<mt:${e}${t}>`;
    }
  }
);
const vT = Ie.create({
  name: "mt-rich-text-editor-mt-function-tag",
  group: "inline",
  inline: !0,
  atom: !0,
  addAttributes() {
    return {
      "data-tag-name": {
        default: null
      },
      HTMLAttributes: {
        default: {},
        parseHTML: (n) => {
          const e = {}, t = ["data-tag-name", "contenteditable", "style", "class"];
          return Array.from(n.attributes).filter((i) => !t.includes(i.name)).forEach((i) => {
            e[i.name] = i.value;
          }), e;
        },
        renderHTML: (n) => n.HTMLAttributes
      }
    };
  },
  addInputRules() {
    return [
      new Qi({
        find: /<\$?mt:?(var|include)([^>]*)\$?>$/i,
        handler: ({ state: n, range: e, match: t }) => {
          const r = new DOMParser().parseFromString(
            t[0].replace(/^<\$/, "<").replace(/\$>$/, ">"),
            "text/html"
          ).body.firstChild, s = {
            "data-tag-name": t[1],
            HTMLAttributes: {}
          };
          for (const a of r.attributes)
            a.name !== "data-tag-name" && (s.HTMLAttributes[a.name] = a.value);
          const o = this.type.create(s);
          n.tr.replaceWith(e.from, e.to, o);
        }
      })
    ];
  },
  parseHTML() {
    return [
      {
        tag: "mt-rich-text-editor-mt-function-tag",
        getAttrs: (n) => n instanceof HTMLElement ? {
          "data-tag-name": n.getAttribute("data-tag-name"),
          ...Object.fromEntries(
            Array.from(n.attributes).filter((e) => e.name !== "data-tag-name").map((e) => [e.name, e.value])
          )
        } : {}
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["mt-rich-text-editor-mt-function-tag", Te(n)];
  }
}), yT = ze.create({
  name: "mt-rich-text-editor-group",
  addExtensions() {
    return [bT, vT];
  }
}), pp = {
  openOnClick: !1
}, xT = ze.create({
  name: "mt-rich-text-editor",
  addExtensions() {
    var e, t, i, r, s, o, a, l, c, u, d, f, h, p, b, m, g, v, x, w, S, k, C, y, A, _, T, M, z, P, V, U, J, re, te, ge, se, Be, fe, Je, we, R, tt, he, ct;
    const n = [];
    return this.options.movableType !== !1 && n.push(yT.configure((e = this.options) == null ? void 0 : e.movableType)), this.options.undoRedo !== !1 && n.push(gT.configure((t = this.options) == null ? void 0 : t.undoRedo)), this.options.document !== !1 && n.push(ck.configure((i = this.options) == null ? void 0 : i.document)), this.options.text !== !1 && n.push(uk.configure((r = this.options) == null ? void 0 : r.text)), this.options.subscript !== !1 && n.push(dk.configure((s = this.options) == null ? void 0 : s.subscript)), this.options.superscript !== !1 && n.push(fk.configure((o = this.options) == null ? void 0 : o.superscript)), this.options.image !== !1 && n.push(
      pk.configure(
        ((a = this.options) == null ? void 0 : a.image) ?? {
          inline: !0,
          allowBase64: !0
        }
      )
    ), this.options.hardBreak !== !1 && n.push(mk.configure((l = this.options) == null ? void 0 : l.hardBreak)), this.options.bold !== !1 && n.push(MC.configure((c = this.options) == null ? void 0 : c.bold)), this.options.italic !== !1 && n.push(yk.configure((u = this.options) == null ? void 0 : u.italic)), this.options.underline !== !1 && n.push(xk.configure((d = this.options) == null ? void 0 : d.underline)), this.options.strike !== !1 && n.push(Bk.configure((f = this.options) == null ? void 0 : f.strike)), this.options.blockquote !== !1 && n.push(kk.configure((h = this.options) == null ? void 0 : h.blockquote)), this.options.table !== !1 && n.push(
      bC.configure(
        ((p = this.options) == null ? void 0 : p.table) ?? {
          resizable: !0
        }
      )
    ), this.options.tableRow !== !1 && n.push(W_.configure((b = this.options) == null ? void 0 : b.tableRow)), this.options.tableHeader !== !1 && n.push(yC.configure((m = this.options) == null ? void 0 : m.tableHeader)), this.options.tableCell !== !1 && n.push(vC.configure((g = this.options) == null ? void 0 : g.tableCell)), this.options.bulletList !== !1 && n.push(x_.configure((v = this.options) == null ? void 0 : v.bulletList)), this.options.heading !== !1 && n.push(Ik.configure((x = this.options) == null ? void 0 : x.heading)), this.options.horizontalRule !== !1 && n.push(Pk.configure((w = this.options) == null ? void 0 : w.horizontalRule)), this.options.orderedList !== !1 && n.push(A_.configure((S = this.options) == null ? void 0 : S.orderedList)), this.options.dropcursor !== !1 && n.push(sS.configure((k = this.options) == null ? void 0 : k.dropcursor)), this.options.gapcursor !== !1 && n.push(oS.configure((C = this.options) == null ? void 0 : C.gapcursor)), this.options.textAlign !== !1 && n.push(
      lS.configure(
        ((y = this.options) == null ? void 0 : y.textAlign) ?? {
          types: ["heading", "paragraph"],
          defaultAlignment: ""
        }
      )
    ), this.options.color !== !1 && n.push(fS.configure((A = this.options) == null ? void 0 : A.color)), this.options.backgroundColor !== !1 && n.push(pS.configure((_ = this.options) == null ? void 0 : _.backgroundColor)), this.options.textStyle !== !1 && n.push(uS.configure((T = this.options) == null ? void 0 : T.textStyle)), this.options.iframe !== !1 && n.push(mS.configure((M = this.options) == null ? void 0 : M.iframe)), this.options.indent !== !1 && n.push(xC.configure((z = this.options) == null ? void 0 : z.indent)), this.options.paragraph !== !1 && n.push(rT.configure((P = this.options) == null ? void 0 : P.paragraph)), this.options.textBlock !== !1 && n.push(sT.configure((V = this.options) == null ? void 0 : V.textBlock)), this.options.pre !== !1 && n.push(oT.configure((U = this.options) == null ? void 0 : U.pre)), this.options.code !== !1 && n.push(aT.configure((J = this.options) == null ? void 0 : J.code)), this.options.descriptionList !== !1 && n.push(lT.configure((re = this.options) == null ? void 0 : re.descriptionList)), this.options.descriptionTerm !== !1 && n.push(cT.configure((te = this.options) == null ? void 0 : te.descriptionTerm)), this.options.descriptionDetails !== !1 && n.push(uT.configure((ge = this.options) == null ? void 0 : ge.descriptionDetails)), this.options.summary !== !1 && n.push(dT.configure((se = this.options) == null ? void 0 : se.summary)), this.options.listItem !== !1 && n.push(fT.configure((Be = this.options) == null ? void 0 : Be.listItem)), this.options.div !== !1 && n.push(wC.configure((fe = this.options) == null ? void 0 : fe.div)), this.options.span !== !1 && n.push(kC.configure((Je = this.options) == null ? void 0 : Je.span)), this.options.inlineLink !== !1 && n.push(nT.configure(((we = this.options) == null ? void 0 : we.inlineLink) ?? pp)), this.options.blockLink !== !1 && n.push(OC.configure(((R = this.options) == null ? void 0 : R.blockLink) ?? pp)), this.options.script !== !1 && n.push(hT.configure((tt = this.options) == null ? void 0 : tt.script)), this.options.embedObject !== !1 && n.push(pT.configure((he = this.options) == null ? void 0 : he.embedObject)), this.options.markdown !== !1 && n.push(mT.configure((ct = this.options) == null ? void 0 : ct.markdown)), n;
  }
});
function st(n, e, [t, i] = [0, 0]) {
  De && t === 0 && Wi();
  var r = n, s = null, o = null, a = lb, l = t > 0 ? Su : 0, c = !1;
  const u = (f, h = !0) => {
    c = !0, d(h, f);
  }, d = (f, h) => {
    if (a === (a = f)) return;
    let p = !1;
    if (De && i !== -1) {
      if (t === 0) {
        const m = (
          /** @type {Comment} */
          r.data
        );
        m === cb ? i = 0 : m === Vp ? i = 1 / 0 : (i = parseInt(m.substring(1)), i !== i && (i = a ? 1 / 0 : -1));
      }
      const b = i > t;
      !!a === b && (r = Lc(), zi(r), Yn(!1), p = !0, i = -1);
    }
    a ? (s ? Rs(s) : h && (s = Rr(() => h(r))), o && Qo(o, () => {
      o = null;
    })) : (o ? Rs(o) : h && (o = Rr(() => h(r, [t + 1, i]))), s && Qo(s, () => {
      s = null;
    })), p && Yn(!0);
  };
  Ya(() => {
    c = !1, e(u), c || d(null, null);
  }, l), De && (r = yn);
}
function kn(n, e) {
  return e;
}
function wT(n, e, t, i) {
  for (var r = [], s = e.length, o = 0; o < s; o++)
    db(e[o].e, r, !0);
  var a = s > 0 && r.length === 0 && t !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      t.parentNode
    );
    fb(l), l.append(
      /** @type {Element} */
      t
    ), i.clear(), ui(n, e[0].prev, e[s - 1].next);
  }
  hb(r, () => {
    for (var c = 0; c < s; c++) {
      var u = e[c];
      a || (i.delete(u.k), ui(n, u.prev, u.next)), Eu(u.e, !a);
    }
  });
}
function ft(n, e, t, i, r, s = null) {
  var o = n, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & Kp) !== 0;
  if (l) {
    var c = (
      /** @type {Element} */
      n
    );
    o = De ? zi(
      /** @type {Comment | Text} */
      Au(c)
    ) : c.appendChild(jp());
  }
  De && Wi();
  var u = null, d = !1, f = ea(() => {
    var h = t();
    return Mu(h) ? h : h == null ? [] : Wp(h);
  });
  Ya(() => {
    var h = E(f), p = h.length;
    if (d && p === 0)
      return;
    d = p === 0;
    let b = !1;
    if (De) {
      var m = (
        /** @type {Comment} */
        o.data === Vp
      );
      m !== (p === 0) && (o = Lc(), zi(o), Yn(!1), b = !0);
    }
    if (De) {
      for (var g = null, v, x = 0; x < p; x++) {
        if (yn.nodeType === 8 && /** @type {Comment} */
        yn.data === mb) {
          o = /** @type {Comment} */
          yn, b = !0, Yn(!1);
          break;
        }
        var w = h[x], S = i(w, x);
        v = t0(
          yn,
          a,
          g,
          null,
          w,
          S,
          x,
          r,
          e,
          t
        ), a.items.set(S, v), g = v;
      }
      p > 0 && zi(Lc());
    }
    De || kT(h, a, o, r, e, i, t), s !== null && (p === 0 ? u ? Rs(u) : u = Rr(() => s(o)) : u !== null && Qo(u, () => {
      u = null;
    })), b && Yn(!0), E(f);
  }), De && (o = yn);
}
function kT(n, e, t, i, r, s, o) {
  var P, V, U, J;
  var a = (r & ub) !== 0, l = (r & (Cu | Tu)) !== 0, c = n.length, u = e.items, d = e.first, f = d, h, p = null, b, m = [], g = [], v, x, w, S;
  if (a)
    for (S = 0; S < c; S += 1)
      v = n[S], x = s(v, S), w = u.get(x), w !== void 0 && ((P = w.a) == null || P.measure(), (b ?? (b = /* @__PURE__ */ new Set())).add(w));
  for (S = 0; S < c; S += 1) {
    if (v = n[S], x = s(v, S), w = u.get(x), w === void 0) {
      var k = f ? (
        /** @type {TemplateNode} */
        f.e.nodes_start
      ) : t;
      p = t0(
        k,
        e,
        p,
        p === null ? e.first : p.next,
        v,
        x,
        S,
        i,
        r,
        o
      ), u.set(x, p), m = [], g = [], f = p.next;
      continue;
    }
    if (l && ST(w, v, S, r), (w.e.f & Nl) !== 0 && (Rs(w.e), a && ((V = w.a) == null || V.unfix(), (b ?? (b = /* @__PURE__ */ new Set())).delete(w))), w !== f) {
      if (h !== void 0 && h.has(w)) {
        if (m.length < g.length) {
          var C = g[0], y;
          p = C.prev;
          var A = m[0], _ = m[m.length - 1];
          for (y = 0; y < m.length; y += 1)
            mp(m[y], C, t);
          for (y = 0; y < g.length; y += 1)
            h.delete(g[y]);
          ui(e, A.prev, _.next), ui(e, p, A), ui(e, _, C), f = C, p = _, S -= 1, m = [], g = [];
        } else
          h.delete(w), mp(w, f, t), ui(e, w.prev, w.next), ui(e, w, p === null ? e.first : p.next), ui(e, p, w), p = w;
        continue;
      }
      for (m = [], g = []; f !== null && f.k !== x; )
        (f.e.f & Nl) === 0 && (h ?? (h = /* @__PURE__ */ new Set())).add(f), g.push(f), f = f.next;
      if (f === null)
        continue;
      w = f;
    }
    m.push(w), p = w, f = w.next;
  }
  if (f !== null || h !== void 0) {
    for (var T = h === void 0 ? [] : Wp(h); f !== null; )
      (f.e.f & Nl) === 0 && T.push(f), f = f.next;
    var M = T.length;
    if (M > 0) {
      var z = (r & Kp) !== 0 && c === 0 ? t : null;
      if (a) {
        for (S = 0; S < M; S += 1)
          (U = T[S].a) == null || U.measure();
        for (S = 0; S < M; S += 1)
          (J = T[S].a) == null || J.fix();
      }
      wT(e, T, z, u);
    }
  }
  a && Up(() => {
    var re;
    if (b !== void 0)
      for (w of b)
        (re = w.a) == null || re.apply();
  }), Is.first = e.first && e.first.e, Is.last = p && p.e;
}
function ST(n, e, t, i) {
  (i & Cu) !== 0 && Wd(n.v, e), (i & Tu) !== 0 ? Wd(
    /** @type {Value<number>} */
    n.i,
    t
  ) : n.i = t;
}
function t0(n, e, t, i, r, s, o, a, l, c) {
  var u = (l & Cu) !== 0, d = (l & pb) === 0, f = u ? d ? gr(r) : Ud(r) : r, h = (l & Tu) === 0 ? o : Ud(o), p = {
    i: h,
    v: f,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: t,
    next: i
  };
  try {
    return p.e = Rr(() => a(n, f, h, c), De), p.e.prev = t && t.e, p.e.next = i && i.e, t === null ? e.first = p : (t.next = p, t.e.next = p.e), i !== null && (i.prev = p, i.e.prev = p.e), p;
  } finally {
  }
}
function mp(n, e, t) {
  for (var i = n.next ? (
    /** @type {TemplateNode} */
    n.next.e.nodes_start
  ) : t, r = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : t, s = (
    /** @type {TemplateNode} */
    n.e.nodes_start
  ); s !== i; ) {
    var o = (
      /** @type {TemplateNode} */
      qp(s)
    );
    r.before(s), s = o;
  }
}
function ui(n, e, t) {
  e === null ? n.first = t : (e.next = t, e.e.next = t && t.e), t !== null && (t.prev = e, t.e.prev = e && e.e);
}
function qt(n, e, t, i, r) {
  var s = n, o = "", a;
  Ya(() => {
    if (o === (o = e() ?? "")) {
      De && Wi();
      return;
    }
    a !== void 0 && (Eu(a), a = void 0), o !== "" && (a = Rr(() => {
      if (De) {
        yn.data;
        for (var l = Wi(), c = l; l !== null && (l.nodeType !== 8 || /** @type {Comment} */
        l.data !== ""); )
          c = l, l = /** @type {TemplateNode} */
          qp(l);
        if (l === null)
          throw _b(), bb;
        Rc(yn, c), s = zi(l);
        return;
      }
      var u = o + "", d = gb(u);
      Rc(
        /** @type {TemplateNode} */
        Au(d),
        /** @type {TemplateNode} */
        d.lastChild
      ), s.before(d);
    }));
  });
}
function wr(n, e, t, i, r) {
  var a;
  De && Wi();
  var s = (a = e.$$slots) == null ? void 0 : a[t], o = !1;
  s === !0 && (s = e[t === "default" ? "children" : t], o = !0), s === void 0 || s(n, o ? () => i : i);
}
function CT(n) {
  const e = {};
  n.children && (e.default = !0);
  for (const t in n.$$slots)
    e[t] = !0;
  return e;
}
function Gr(n, e, t, i, r, s) {
  let o = De;
  De && Wi();
  var a, l, c = null;
  De && yn.nodeType === 1 && (c = /** @type {Element} */
  yn, Wi());
  var u = (
    /** @type {TemplateNode} */
    De ? yn : n
  ), d;
  Ya(() => {
    const f = e() || null;
    var h = f === "svg" ? vb : null;
    f !== a && (d && (f === null ? Qo(d, () => {
      d = null, l = null;
    }) : f === l ? Rs(d) : (Eu(d), Kd(!1))), f && f !== l && (d = Rr(() => {
      if (c = De ? (
        /** @type {Element} */
        c
      ) : h ? document.createElementNS(h, f) : document.createElement(f), Rc(c, c), i) {
        De && yb(f) && c.append(document.createComment(""));
        var p = (
          /** @type {TemplateNode} */
          De ? Au(c) : c.appendChild(jp())
        );
        De && (p === null ? Yn(!1) : zi(p)), i(c, p);
      }
      Is.nodes_end = c, u.before(c);
    })), a = f, a && (l = a), Kd(!0));
  }, Su), o && (Yn(!0), zi(u));
}
function St(n, e, t) {
  Za(() => {
    var i = jr(() => e(n, t == null ? void 0 : t()) || {});
    if (t && (i != null && i.update)) {
      var r = !1, s = (
        /** @type {any} */
        {}
      );
      Ou(() => {
        var o = t();
        Qa(o), r && xb(s, o) && (s = o, i.update(o));
      }), r = !0;
    }
    if (i != null && i.destroy)
      return () => (
        /** @type {Function} */
        i.destroy()
      );
  });
}
function n0(n) {
  var e, t, i = "";
  if (typeof n == "string" || typeof n == "number") i += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var r = n.length;
    for (e = 0; e < r; e++) n[e] && (t = n0(n[e])) && (i && (i += " "), i += t);
  } else for (t in n) n[t] && (i && (i += " "), i += t);
  return i;
}
function TT() {
  for (var n, e, t = 0, i = "", r = arguments.length; t < r; t++) (n = arguments[t]) && (e = n0(n)) && (i && (i += " "), i += e);
  return i;
}
function i0(n) {
  return typeof n == "object" ? TT(n) : n ?? "";
}
const gp = [...` 	
\r\f\v\uFEFF`];
function ET(n, e, t) {
  var i = n == null ? "" : "" + n;
  if (e && (i = i ? i + " " + e : e), t) {
    for (var r in t)
      if (t[r])
        i = i ? i + " " + r : r;
      else if (i.length)
        for (var s = r.length, o = 0; (o = i.indexOf(r, o)) >= 0; ) {
          var a = o + s;
          (o === 0 || gp.includes(i[o - 1])) && (a === i.length || gp.includes(i[a])) ? i = (o === 0 ? "" : i.substring(0, o)) + i.substring(a + 1) : o = a;
        }
  }
  return i === "" ? null : i;
}
function _p(n, e = !1) {
  var t = e ? " !important;" : ";", i = "";
  for (var r in n) {
    var s = n[r];
    s != null && s !== "" && (i += " " + r + ": " + s + t);
  }
  return i;
}
function xc(n) {
  return n[0] !== "-" || n[1] !== "-" ? n.toLowerCase() : n;
}
function AT(n, e) {
  if (e) {
    var t = "", i, r;
    if (Array.isArray(e) ? (i = e[0], r = e[1]) : i = e, n) {
      n = String(n).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var s = !1, o = 0, a = !1, l = [];
      i && l.push(...Object.keys(i).map(xc)), r && l.push(...Object.keys(r).map(xc));
      var c = 0, u = -1;
      const b = n.length;
      for (var d = 0; d < b; d++) {
        var f = n[d];
        if (a ? f === "/" && n[d - 1] === "*" && (a = !1) : s ? s === f && (s = !1) : f === "/" && n[d + 1] === "*" ? a = !0 : f === '"' || f === "'" ? s = f : f === "(" ? o++ : f === ")" && o--, !a && s === !1 && o === 0) {
          if (f === ":" && u === -1)
            u = d;
          else if (f === ";" || d === b - 1) {
            if (u !== -1) {
              var h = xc(n.substring(c, u).trim());
              if (!l.includes(h)) {
                f !== ";" && d++;
                var p = n.substring(c, d).trim();
                t += " " + p + ";";
              }
            }
            c = d + 1, u = -1;
          }
        }
      }
    }
    return i && (t += _p(i)), r && (t += _p(r, !0)), t = t.trim(), t === "" ? null : t;
  }
  return n == null ? null : String(n);
}
function pt(n, e, t, i, r, s) {
  var o = n.__className;
  if (De || o !== t || o === void 0) {
    var a = ET(t, i, s);
    (!De || a !== n.getAttribute("class")) && (a == null ? n.removeAttribute("class") : e ? n.className = a : n.setAttribute("class", a)), n.__className = t;
  } else if (s && r !== s)
    for (var l in s) {
      var c = !!s[l];
      (r == null || c !== !!r[l]) && n.classList.toggle(l, c);
    }
  return s;
}
function wc(n, e = {}, t, i) {
  for (var r in t) {
    var s = t[r];
    e[r] !== s && (t[r] == null ? n.style.removeProperty(r) : n.style.setProperty(r, s, i));
  }
}
function qs(n, e, t, i) {
  var r = n.__style;
  if (De || r !== e) {
    var s = AT(e, i);
    (!De || s !== n.getAttribute("style")) && (s == null ? n.removeAttribute("style") : n.style.cssText = s), n.__style = e;
  } else i && (Array.isArray(i) ? (wc(n, t == null ? void 0 : t[0], i[0]), wc(n, t == null ? void 0 : t[1], i[1], "important")) : wc(n, t, i));
  return i;
}
const as = Symbol("class"), ls = Symbol("style"), r0 = Symbol("is custom element"), s0 = Symbol("is html");
function ht(n) {
  if (De) {
    var e = !1, t = () => {
      if (!e) {
        if (e = !0, n.hasAttribute("value")) {
          var i = n.value;
          Ae(n, "value", null), n.value = i;
        }
        if (n.hasAttribute("checked")) {
          var r = n.checked;
          Ae(n, "checked", null), n.checked = r;
        }
      }
    };
    n.__on_r = t, Tb(t), Eb();
  }
}
function bp(n, e) {
  var t = Ld(n);
  t.checked !== (t.checked = // treat null and undefined the same for the initial value
  e ?? void 0) && (n.checked = e);
}
function MT(n, e) {
  e ? n.hasAttribute("selected") || n.setAttribute("selected", "") : n.removeAttribute("selected");
}
function Ae(n, e, t, i) {
  var r = Ld(n);
  De && (r[e] = n.getAttribute(e), e === "src" || e === "srcset" || e === "href" && n.nodeName === "LINK") || r[e] !== (r[e] = t) && (e === "loading" && (n[wb] = t), t == null ? n.removeAttribute(e) : typeof t != "string" && a0(n).includes(e) ? n[e] = t : n.setAttribute(e, t));
}
function o0(n, e, t, i, r = !1) {
  var s = Ld(n), o = s[r0], a = !s[s0];
  let l = De && o;
  l && Yn(!1);
  var c = e || {}, u = n.tagName === "OPTION";
  for (var d in e)
    d in t || (t[d] = null);
  t.class ? t.class = i0(t.class) : t[as] && (t.class = null), t[ls] && (t.style ?? (t.style = null));
  var f = a0(n);
  for (const x in t) {
    let w = t[x];
    if (u && x === "value" && w == null) {
      n.value = n.__value = "", c[x] = w;
      continue;
    }
    if (x === "class") {
      var h = n.namespaceURI === "http://www.w3.org/1999/xhtml";
      pt(n, h, w, i, e == null ? void 0 : e[as], t[as]), c[x] = w, c[as] = t[as];
      continue;
    }
    if (x === "style") {
      qs(n, w, e == null ? void 0 : e[ls], t[ls]), c[x] = w, c[ls] = t[ls];
      continue;
    }
    var p = c[x];
    if (w !== p) {
      c[x] = w;
      var b = x[0] + x[1];
      if (b !== "$$")
        if (b === "on") {
          const S = {}, k = "$$" + x;
          let C = x.slice(2);
          var m = Lb(C);
          if (Ab(C) && (C = C.slice(0, -7), S.capture = !0), !m && p) {
            if (w != null) continue;
            n.removeEventListener(C, c[k], S), c[k] = null;
          }
          if (w != null)
            if (m)
              n[`__${C}`] = w, Ot([C]);
            else {
              let y = function(A) {
                c[x].call(this, A);
              };
              c[k] = Mb(C, n, y, S);
            }
          else m && (n[`__${C}`] = void 0);
        } else if (x === "style")
          Ae(n, x, w);
        else if (x === "autofocus")
          Ob(
            /** @type {HTMLElement} */
            n,
            !!w
          );
        else if (!o && (x === "__value" || x === "value" && w != null))
          n.value = n.__value = w;
        else if (x === "selected" && u)
          MT(
            /** @type {HTMLOptionElement} */
            n,
            w
          );
        else {
          var g = x;
          a || (g = Nb(g));
          var v = g === "defaultValue" || g === "defaultChecked";
          if (w == null && !o && !v)
            if (s[x] = null, g === "value" || g === "checked") {
              let S = (
                /** @type {HTMLInputElement} */
                n
              );
              const k = e === void 0;
              if (g === "value") {
                let C = S.defaultValue;
                S.removeAttribute(g), S.defaultValue = C, S.value = S.__value = k ? C : null;
              } else {
                let C = S.defaultChecked;
                S.removeAttribute(g), S.defaultChecked = C, S.checked = k ? C : !1;
              }
            } else
              n.removeAttribute(x);
          else v || f.includes(g) && (o || typeof w != "string") ? n[g] = w : typeof w != "function" && Ae(n, g, w);
        }
    }
  }
  return l && Yn(!0), c;
}
function Ld(n) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    n.__attributes ?? (n.__attributes = {
      [r0]: n.nodeName.includes("-"),
      [s0]: n.namespaceURI === kb
    })
  );
}
var vp = /* @__PURE__ */ new Map();
function a0(n) {
  var e = vp.get(n.nodeName);
  if (e) return e;
  vp.set(n.nodeName, e = []);
  for (var t, i = n, r = Element.prototype; r !== i; ) {
    t = Cb(i);
    for (var s in t)
      t[s].set && e.push(s);
    i = Sb(i);
  }
  return e;
}
const OT = () => performance.now(), Jn = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (n) => requestAnimationFrame(n)
  ),
  now: () => OT(),
  tasks: /* @__PURE__ */ new Set()
};
function l0() {
  const n = Jn.now();
  Jn.tasks.forEach((e) => {
    e.c(n) || (Jn.tasks.delete(e), e.f());
  }), Jn.tasks.size !== 0 && Jn.tick(l0);
}
function NT(n) {
  let e;
  return Jn.tasks.size === 0 && Jn.tick(l0), {
    promise: new Promise((t) => {
      Jn.tasks.add(e = { c: n, f: t });
    }),
    abort() {
      Jn.tasks.delete(e);
    }
  };
}
function zo(n, e) {
  zb(() => {
    n.dispatchEvent(new CustomEvent(e));
  });
}
function LT(n) {
  if (n === "float") return "cssFloat";
  if (n === "offset") return "cssOffset";
  if (n.startsWith("--")) return n;
  const e = n.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (t) => t[0].toUpperCase() + t.slice(1)
  ).join("");
}
function yp(n) {
  const e = {}, t = n.split(";");
  for (const i of t) {
    const [r, s] = i.split(":");
    if (!r || s === void 0) break;
    const o = LT(r.trim());
    e[o] = s.trim();
  }
  return e;
}
const RT = (n) => n;
function Ho(n, e, t, i) {
  var r = (n & $b) !== 0, s = (n & Bb) !== 0, o = r && s, a = (n & Db) !== 0, l = o ? "both" : r ? "in" : "out", c, u = e.inert, d = e.style.overflow, f, h;
  function p() {
    var x = Fb, w = Is;
    qd(null), Gd(null);
    try {
      return c ?? (c = t()(e, (i == null ? void 0 : i()) ?? /** @type {P} */
      {}, {
        direction: l
      }));
    } finally {
      qd(x), Gd(w);
    }
  }
  var b = {
    is_global: a,
    in() {
      var x;
      if (e.inert = u, !r) {
        h == null || h.abort(), (x = h == null ? void 0 : h.reset) == null || x.call(h);
        return;
      }
      s || f == null || f.abort(), zo(e, "introstart"), f = vu(e, p(), h, 1, () => {
        zo(e, "introend"), f == null || f.abort(), f = c = void 0, e.style.overflow = d;
      });
    },
    out(x) {
      if (!s) {
        x == null || x(), c = void 0;
        return;
      }
      e.inert = !0, zo(e, "outrostart"), h = vu(e, p(), f, 0, () => {
        zo(e, "outroend"), x == null || x();
      });
    },
    stop: () => {
      f == null || f.abort(), h == null || h.abort();
    }
  }, m = (
    /** @type {Effect} */
    Is
  );
  if ((m.transitions ?? (m.transitions = [])).push(b), r && Rb) {
    var g = a;
    if (!g) {
      for (var v = (
        /** @type {Effect | null} */
        m.parent
      ); v && (v.f & Su) !== 0; )
        for (; (v = v.parent) && (v.f & Ib) === 0; )
          ;
      g = !v || (v.f & Pb) !== 0;
    }
    g && Za(() => {
      jr(() => b.in());
    });
  }
}
function vu(n, e, t, i, r) {
  var s = i === 1;
  if (Hb(e)) {
    var o, a = !1;
    return Up(() => {
      if (!a) {
        var m = e({ direction: s ? "in" : "out" });
        o = vu(n, m, t, i, r);
      }
    }), {
      abort: () => {
        a = !0, o == null || o.abort();
      },
      deactivate: () => o.deactivate(),
      reset: () => o.reset(),
      t: () => o.t()
    };
  }
  if (t == null || t.deactivate(), !(e != null && e.duration))
    return r(), {
      abort: es,
      deactivate: es,
      reset: es,
      t: () => i
    };
  const { delay: l = 0, css: c, tick: u, easing: d = RT } = e;
  var f = [];
  if (s && t === void 0 && (u && u(0, 1), c)) {
    var h = yp(c(0, 1));
    f.push(h, h);
  }
  var p = () => 1 - i, b = n.animate(f, { duration: l });
  return b.onfinish = () => {
    var m = (t == null ? void 0 : t.t()) ?? 1 - i;
    t == null || t.abort();
    var g = i - m, v = (
      /** @type {number} */
      e.duration * Math.abs(g)
    ), x = [];
    if (v > 0) {
      var w = !1;
      if (c)
        for (var S = Math.ceil(v / 16.666666666666668), k = 0; k <= S; k += 1) {
          var C = m + g * d(k / S), y = yp(c(C, 1 - C));
          x.push(y), w || (w = y.overflow === "hidden");
        }
      w && (n.style.overflow = "hidden"), p = () => {
        var A = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          b.currentTime
        );
        return m + g * d(A / v);
      }, u && NT(() => {
        if (b.playState !== "running") return !1;
        var A = p();
        return u(A, 1 - A), !0;
      });
    }
    b = n.animate(x, { duration: v, fill: "forwards" }), b.onfinish = () => {
      p = () => i, u == null || u(i, 1 - i), r();
    };
  }, {
    abort: () => {
      b && (b.cancel(), b.effect = null, b.onfinish = es);
    },
    deactivate: () => {
      r = es;
    },
    reset: () => {
      i === 0 && (u == null || u(1, 0));
    },
    t: () => p()
  };
}
function kt(n, e, t = e) {
  var i = Vb();
  Nu(n, "input", (r) => {
    var s = r ? n.defaultValue : n.value;
    if (s = kc(n) ? Sc(s) : s, t(s), i && s !== (s = e())) {
      var o = n.selectionStart, a = n.selectionEnd;
      n.value = s ?? "", a !== null && (n.selectionStart = o, n.selectionEnd = Math.min(a, n.value.length));
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  (De && n.defaultValue !== n.value || // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  jr(e) == null && n.value) && t(kc(n) ? Sc(n.value) : n.value), Ou(() => {
    var r = e();
    kc(n) && r === Sc(n.value) || n.type === "date" && !r && !n.value || r !== n.value && (n.value = r ?? "");
  });
}
function xp(n, e, t = e) {
  Nu(n, "change", (i) => {
    var r = i ? n.defaultChecked : n.checked;
    t(r);
  }), // If we are hydrating and the value has since changed,
  // then use the update value from the input instead.
  (De && n.defaultChecked !== n.checked || // If defaultChecked is set, then checked == defaultChecked
  jr(e) == null) && t(n.checked), Ou(() => {
    var i = e();
    n.checked = !!i;
  });
}
function kc(n) {
  var e = n.type;
  return e === "number" || e === "range";
}
function Sc(n) {
  return n === "" ? null : +n;
}
function c0(n, e, t) {
  if (n.multiple)
    return PT(n, e);
  for (var i of n.options) {
    var r = Ls(i);
    if (jb(r, e)) {
      i.selected = !0;
      return;
    }
  }
  (!t || e !== void 0) && (n.selectedIndex = -1);
}
function IT(n, e) {
  Za(() => {
    var t = new MutationObserver(() => {
      var i = n.__value;
      c0(n, i);
    });
    return t.observe(n, {
      // Listen to option element changes
      childList: !0,
      subtree: !0,
      // because of <optgroup>
      // Listen to option element value attribute changes
      // (doesn't get notified of select value changes,
      // because that property is not reflected as an attribute)
      attributes: !0,
      attributeFilter: ["value"]
    }), () => {
      t.disconnect();
    };
  });
}
function mr(n, e, t = e) {
  var i = !0;
  Nu(n, "change", (r) => {
    var s = r ? "[selected]" : ":checked", o;
    if (n.multiple)
      o = [].map.call(n.querySelectorAll(s), Ls);
    else {
      var a = n.querySelector(s) ?? // will fall back to first non-disabled option if no option is selected
      n.querySelector("option:not([disabled])");
      o = a && Ls(a);
    }
    t(o);
  }), Za(() => {
    var r = e();
    if (c0(n, r, i), i && r === void 0) {
      var s = n.querySelector(":checked");
      s !== null && (r = Ls(s), t(r));
    }
    n.__value = r, i = !1;
  }), IT(n);
}
function PT(n, e) {
  for (var t of n.options)
    t.selected = ~e.indexOf(Ls(t));
}
function Ls(n) {
  return "__value" in n ? n.__value : n.value;
}
function Fo(n) {
  return function(...e) {
    var t = (
      /** @type {Event} */
      e[0]
    );
    return t.preventDefault(), n == null ? void 0 : n.apply(this, e);
  };
}
function wl(n = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    ys
  ), t = e.l.u;
  if (!t) return;
  let i = () => Qa(e.s);
  if (n) {
    let r = 0, s = (
      /** @type {Record<string, any>} */
      {}
    );
    const o = Kb(() => {
      let a = !1;
      const l = e.s;
      for (const c in l)
        l[c] !== s[c] && (s[c] = l[c], a = !0);
      return a && r++, r;
    });
    i = () => E(o);
  }
  t.b.length && Wb(() => {
    wp(e, i), Jd(t.b);
  }), $e(() => {
    const r = jr(() => t.m.map(Ub));
    return () => {
      for (const s of r)
        typeof s == "function" && s();
    };
  }), t.a.length && $e(() => {
    wp(e, i), Jd(t.a);
  });
}
function wp(n, e) {
  if (n.l.s)
    for (const t of n.l.s) E(t);
  e();
}
function Ja(n, e) {
  var s;
  var t = (
    /** @type {Record<string, Function[] | Function>} */
    (s = n.$$events) == null ? void 0 : s[e.type]
  ), i = Mu(t) ? t.slice() : t == null ? [] : [t];
  for (var r of i)
    r.call(this, e);
}
function u0(n) {
  ys === null && Gp(), qb && ys.l !== null ? BT(ys).m.push(n) : $e(() => {
    const e = jr(n);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function DT(n, e, { bubbles: t = !1, cancelable: i = !1 } = {}) {
  return new CustomEvent(n, { detail: e, bubbles: t, cancelable: i });
}
function $T() {
  const n = ys;
  return n === null && Gp(), (e, t, i) => {
    var s;
    const r = (
      /** @type {Record<string, Function | Function[]>} */
      (s = n.s.$$events) == null ? void 0 : s[
        /** @type {any} */
        e
      ]
    );
    if (r) {
      const o = Mu(r) ? r.slice() : [r], a = DT(
        /** @type {string} */
        e,
        t,
        i
      );
      for (const l of o)
        l.call(n.x, a);
      return !a.defaultPrevented;
    }
    return !0;
  };
}
function BT(n) {
  var e = (
    /** @type {ComponentContextLegacy} */
    n.l
  );
  return e.u ?? (e.u = { a: [], b: [], m: [] });
}
const d0 = (n, e) => {
  let t;
  return (...i) => {
    clearTimeout(t), t = setTimeout(() => n(...i), e);
  };
};
var vs = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
var zT = vs.exports, kp;
function HT() {
  return kp || (kp = 1, function(n, e) {
    (function() {
      var t = {
        function: !0,
        object: !0
      }, i = t[typeof window] && window || this, r = e, s = n && !n.nodeType && n, o = r && s && typeof ph == "object" && ph;
      o && (o.global === o || o.window === o || o.self === o) && (i = o);
      var a = Math.pow(2, 53) - 1, l = /\bOpera/, c = Object.prototype, u = c.hasOwnProperty, d = c.toString;
      function f(y) {
        return y = String(y), y.charAt(0).toUpperCase() + y.slice(1);
      }
      function h(y, A, _) {
        var T = {
          "10.0": "10",
          "6.4": "10 Technical Preview",
          "6.3": "8.1",
          "6.2": "8",
          "6.1": "Server 2008 R2 / 7",
          "6.0": "Server 2008 / Vista",
          "5.2": "Server 2003 / XP 64-bit",
          "5.1": "XP",
          "5.01": "2000 SP1",
          "5.0": "2000",
          "4.0": "NT",
          "4.90": "ME"
        };
        return A && _ && /^Win/i.test(y) && !/^Windows Phone /i.test(y) && (T = T[/[\d.]+$/.exec(y)]) && (y = "Windows " + T), y = String(y), A && _ && (y = y.replace(RegExp(A, "i"), _)), y = b(
          y.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
        ), y;
      }
      function p(y, A) {
        var _ = -1, T = y ? y.length : 0;
        if (typeof T == "number" && T > -1 && T <= a)
          for (; ++_ < T; )
            A(y[_], _, y);
        else
          m(y, A);
      }
      function b(y) {
        return y = S(y), /^(?:webOS|i(?:OS|P))/.test(y) ? y : f(y);
      }
      function m(y, A) {
        for (var _ in y)
          u.call(y, _) && A(y[_], _, y);
      }
      function g(y) {
        return y == null ? f(y) : d.call(y).slice(8, -1);
      }
      function v(y, A) {
        var _ = y != null ? typeof y[A] : "number";
        return !/^(?:boolean|number|string|undefined)$/.test(_) && (_ == "object" ? !!y[A] : !0);
      }
      function x(y) {
        return String(y).replace(/([ -])(?!$)/g, "$1?");
      }
      function w(y, A) {
        var _ = null;
        return p(y, function(T, M) {
          _ = A(_, T, M, y);
        }), _;
      }
      function S(y) {
        return String(y).replace(/^ +| +$/g, "");
      }
      function k(y) {
        var A = i, _ = y && typeof y == "object" && g(y) != "String";
        _ && (A = y, y = null);
        var T = A.navigator || {}, M = T.userAgent || "";
        y || (y = M);
        var z = _ ? !!T.likeChrome : /\bChrome\b/.test(y) && !/internal|\n/i.test(d.toString()), P = "Object", V = _ ? P : "ScriptBridgingProxyObject", U = _ ? P : "Environment", J = _ && A.java ? "JavaPackage" : g(A.java), re = _ ? P : "RuntimeObject", te = /\bJava/.test(J) && A.java, ge = te && g(A.environment) == U, se = te ? "a" : "", Be = te ? "b" : "", fe = A.document || {}, Je = A.operamini || A.opera, we = l.test(we = _ && Je ? Je["[[Class]]"] : g(Je)) ? we : Je = null, R, tt = y, he = [], ct = null, Ne = y == M, X = Ne && Je && typeof Je.version == "function" && Je.version(), Ee, me = Ft([
          { label: "EdgeHTML", pattern: "Edge" },
          "Trident",
          { label: "WebKit", pattern: "AppleWebKit" },
          "iCab",
          "Presto",
          "NetFront",
          "Tasman",
          "KHTML",
          "Gecko"
        ]), D = nn([
          "Adobe AIR",
          "Arora",
          "Avant Browser",
          "Breach",
          "Camino",
          "Electron",
          "Epiphany",
          "Fennec",
          "Flock",
          "Galeon",
          "GreenBrowser",
          "iCab",
          "Iceweasel",
          "K-Meleon",
          "Konqueror",
          "Lunascape",
          "Maxthon",
          { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
          "Midori",
          "Nook Browser",
          "PaleMoon",
          "PhantomJS",
          "Raven",
          "Rekonq",
          "RockMelt",
          { label: "Samsung Internet", pattern: "SamsungBrowser" },
          "SeaMonkey",
          { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
          "Sleipnir",
          "SlimBrowser",
          { label: "SRWare Iron", pattern: "Iron" },
          "Sunrise",
          "Swiftfox",
          "Vivaldi",
          "Waterfox",
          "WebPositive",
          { label: "Yandex Browser", pattern: "YaBrowser" },
          { label: "UC Browser", pattern: "UCBrowser" },
          "Opera Mini",
          { label: "Opera Mini", pattern: "OPiOS" },
          "Opera",
          { label: "Opera", pattern: "OPR" },
          "Chromium",
          "Chrome",
          { label: "Chrome", pattern: "(?:HeadlessChrome)" },
          { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
          { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
          { label: "Firefox for iOS", pattern: "FxiOS" },
          { label: "IE", pattern: "IEMobile" },
          { label: "IE", pattern: "MSIE" },
          "Safari"
        ]), de = er([
          { label: "BlackBerry", pattern: "BB10" },
          "BlackBerry",
          { label: "Galaxy S", pattern: "GT-I9000" },
          { label: "Galaxy S2", pattern: "GT-I9100" },
          { label: "Galaxy S3", pattern: "GT-I9300" },
          { label: "Galaxy S4", pattern: "GT-I9500" },
          { label: "Galaxy S5", pattern: "SM-G900" },
          { label: "Galaxy S6", pattern: "SM-G920" },
          { label: "Galaxy S6 Edge", pattern: "SM-G925" },
          { label: "Galaxy S7", pattern: "SM-G930" },
          { label: "Galaxy S7 Edge", pattern: "SM-G935" },
          "Google TV",
          "Lumia",
          "iPad",
          "iPod",
          "iPhone",
          "Kindle",
          { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
          "Nexus",
          "Nook",
          "PlayBook",
          "PlayStation Vita",
          "PlayStation",
          "TouchPad",
          "Transformer",
          { label: "Wii U", pattern: "WiiU" },
          "Wii",
          "Xbox One",
          { label: "Xbox 360", pattern: "Xbox" },
          "Xoom"
        ]), be = ut({
          Apple: { iPad: 1, iPhone: 1, iPod: 1 },
          Alcatel: {},
          Archos: {},
          Amazon: { Kindle: 1, "Kindle Fire": 1 },
          Asus: { Transformer: 1 },
          "Barnes & Noble": { Nook: 1 },
          BlackBerry: { PlayBook: 1 },
          Google: { "Google TV": 1, Nexus: 1 },
          HP: { TouchPad: 1 },
          HTC: {},
          Huawei: {},
          Lenovo: {},
          LG: {},
          Microsoft: { Xbox: 1, "Xbox One": 1 },
          Motorola: { Xoom: 1 },
          Nintendo: { "Wii U": 1, Wii: 1 },
          Nokia: { Lumia: 1 },
          Oppo: {},
          Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
          Sony: { PlayStation: 1, "PlayStation Vita": 1 },
          Xiaomi: { Mi: 1, Redmi: 1 }
        }), j = rn([
          "Windows Phone",
          "KaiOS",
          "Android",
          "CentOS",
          { label: "Chrome OS", pattern: "CrOS" },
          "Debian",
          { label: "DragonFly BSD", pattern: "DragonFly" },
          "Fedora",
          "FreeBSD",
          "Gentoo",
          "Haiku",
          "Kubuntu",
          "Linux Mint",
          "OpenBSD",
          "Red Hat",
          "SuSE",
          "Ubuntu",
          "Xubuntu",
          "Cygwin",
          "Symbian OS",
          "hpwOS",
          "webOS ",
          "webOS",
          "Tablet OS",
          "Tizen",
          "Linux",
          "Mac OS X",
          "Macintosh",
          "Mac",
          "Windows 98;",
          "Windows "
        ]);
        function Ft(Ue) {
          return w(Ue, function(Pe, Se) {
            return Pe || RegExp("\\b" + (Se.pattern || x(Se)) + "\\b", "i").exec(y) && (Se.label || Se);
          });
        }
        function ut(Ue) {
          return w(Ue, function(Pe, Se, Ct) {
            return Pe || (Se[de] || Se[/^[a-z]+(?: +[a-z]+\b)*/i.exec(de)] || RegExp("\\b" + x(Ct) + "(?:\\b|\\w*\\d)", "i").exec(y)) && Ct;
          });
        }
        function nn(Ue) {
          return w(Ue, function(Pe, Se) {
            return Pe || RegExp("\\b" + (Se.pattern || x(Se)) + "\\b", "i").exec(y) && (Se.label || Se);
          });
        }
        function rn(Ue) {
          return w(Ue, function(Pe, Se) {
            var Ct = Se.pattern || x(Se);
            return !Pe && (Pe = RegExp("\\b" + Ct + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(y)) && (Pe = h(Pe, Ct, Se.label || Se)), Pe;
          });
        }
        function er(Ue) {
          return w(Ue, function(Pe, Se) {
            var Ct = Se.pattern || x(Se);
            return !Pe && (Pe = RegExp("\\b" + Ct + " *\\d+[.\\w_]*", "i").exec(y) || RegExp("\\b" + Ct + " *\\w+-[\\w]*", "i").exec(y) || RegExp("\\b" + Ct + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(y)) && ((Pe = String(Se.label && !RegExp(Ct, "i").test(Se.label) ? Se.label : Pe).split("/"))[1] && !/[\d.]+/.test(Pe[0]) && (Pe[0] += " " + Pe[1]), Se = Se.label || Se, Pe = b(Pe[0].replace(RegExp(Ct, "i"), Se).replace(RegExp("; *(?:" + Se + "[_-])?", "i"), " ").replace(RegExp("(" + Se + ")[-_.]?(\\w)", "i"), "$1 $2"))), Pe;
          });
        }
        function sn(Ue) {
          return w(Ue, function(Pe, Se) {
            return Pe || (RegExp(Se + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(y) || 0)[1] || null;
          });
        }
        function Vn() {
          return this.description || "";
        }
        if (me && (me = [me]), /\bAndroid\b/.test(j) && !de && (R = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(y)) && (de = S(R[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), be && !de ? de = er([be]) : be && de && (de = de.replace(RegExp("^(" + x(be) + ")[-_.\\s]", "i"), be + " ").replace(RegExp("^(" + x(be) + ")[-_.]?(\\w)", "i"), be + " $2")), (R = /\bGoogle TV\b/.exec(de)) && (de = R[0]), /\bSimulator\b/i.test(y) && (de = (de ? de + " " : "") + "Simulator"), D == "Opera Mini" && /\bOPiOS\b/.test(y) && he.push("running in Turbo/Uncompressed mode"), D == "IE" && /\blike iPhone OS\b/.test(y) ? (R = k(y.replace(/like iPhone OS/, "")), be = R.manufacturer, de = R.product) : /^iP/.test(de) ? (D || (D = "Safari"), j = "iOS" + ((R = / OS ([\d_]+)/i.exec(y)) ? " " + R[1].replace(/_/g, ".") : "")) : D == "Konqueror" && /^Linux\b/i.test(j) ? j = "Kubuntu" : be && be != "Google" && (/Chrome/.test(D) && !/\bMobile Safari\b/i.test(y) || /\bVita\b/.test(de)) || /\bAndroid\b/.test(j) && /^Chrome/.test(D) && /\bVersion\//i.test(y) ? (D = "Android Browser", j = /\bAndroid\b/.test(j) ? j : "Android") : D == "Silk" ? (/\bMobi/i.test(y) || (j = "Android", he.unshift("desktop mode")), /Accelerated *= *true/i.test(y) && he.unshift("accelerated")) : D == "UC Browser" && /\bUCWEB\b/.test(y) ? he.push("speed mode") : D == "PaleMoon" && (R = /\bFirefox\/([\d.]+)\b/.exec(y)) ? he.push("identifying as Firefox " + R[1]) : D == "Firefox" && (R = /\b(Mobile|Tablet|TV)\b/i.exec(y)) ? (j || (j = "Firefox OS"), de || (de = R[1])) : !D || (R = !/\bMinefield\b/i.test(y) && /\b(?:Firefox|Safari)\b/.exec(D)) ? (D && !de && /[\/,]|^[^(]+?\)/.test(y.slice(y.indexOf(R + "/") + 8)) && (D = null), (R = de || be || j) && (de || be || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(j)) && (D = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(j) ? j : R) + " Browser")) : D == "Electron" && (R = (/\bChrome\/([\d.]+)\b/.exec(y) || 0)[1]) && he.push("Chromium " + R), X || (X = sn([
          "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
          "Version",
          x(D),
          "(?:Firefox|Minefield|NetFront)"
        ])), (R = me == "iCab" && parseFloat(X) > 3 && "WebKit" || /\bOpera\b/.test(D) && (/\bOPR\b/.test(y) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(y) && !/^(?:Trident|EdgeHTML)$/.test(me) && "WebKit" || !me && /\bMSIE\b/i.test(y) && (j == "Mac OS" ? "Tasman" : "Trident") || me == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(D) && "NetFront") && (me = [R]), D == "IE" && (R = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(y) || 0)[1]) ? (D += " Mobile", j = "Windows Phone " + (/\+$/.test(R) ? R : R + ".x"), he.unshift("desktop mode")) : /\bWPDesktop\b/i.test(y) ? (D = "IE Mobile", j = "Windows Phone 8.x", he.unshift("desktop mode"), X || (X = (/\brv:([\d.]+)/.exec(y) || 0)[1])) : D != "IE" && me == "Trident" && (R = /\brv:([\d.]+)/.exec(y)) && (D && he.push("identifying as " + D + (X ? " " + X : "")), D = "IE", X = R[1]), Ne) {
          if (v(A, "global"))
            if (te && (R = te.lang.System, tt = R.getProperty("os.arch"), j = j || R.getProperty("os.name") + " " + R.getProperty("os.version")), ge) {
              try {
                X = A.require("ringo/engine").version.join("."), D = "RingoJS";
              } catch {
                (R = A.system) && R.global.system == A.system && (D = "Narwhal", j || (j = R[0].os || null));
              }
              D || (D = "Rhino");
            } else typeof A.process == "object" && !A.process.browser && (R = A.process) && (typeof R.versions == "object" && (typeof R.versions.electron == "string" ? (he.push("Node " + R.versions.node), D = "Electron", X = R.versions.electron) : typeof R.versions.nw == "string" && (he.push("Chromium " + X, "Node " + R.versions.node), D = "NW.js", X = R.versions.nw)), D || (D = "Node.js", tt = R.arch, j = R.platform, X = /[\d.]+/.exec(R.version), X = X ? X[0] : null));
          else g(R = A.runtime) == V ? (D = "Adobe AIR", j = R.flash.system.Capabilities.os) : g(R = A.phantom) == re ? (D = "PhantomJS", X = (R = R.version || null) && R.major + "." + R.minor + "." + R.patch) : typeof fe.documentMode == "number" && (R = /\bTrident\/(\d+)/i.exec(y)) ? (X = [X, fe.documentMode], (R = +R[1] + 4) != X[1] && (he.push("IE " + X[1] + " mode"), me && (me[1] = ""), X[1] = R), X = D == "IE" ? String(X[1].toFixed(1)) : X[0]) : typeof fe.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(D) && (he.push("masking as " + D + " " + X), D = "IE", X = "11.0", me = ["Trident"], j = "Windows");
          j = j && b(j);
        }
        if (X && (R = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(X) || /(?:alpha|beta)(?: ?\d)?/i.exec(y + ";" + (Ne && T.appMinorVersion)) || /\bMinefield\b/i.test(y) && "a") && (ct = /b/i.test(R) ? "beta" : "alpha", X = X.replace(RegExp(R + "\\+?$"), "") + (ct == "beta" ? Be : se) + (/\d+\+?/.exec(R) || "")), D == "Fennec" || D == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(j))
          D = "Firefox Mobile";
        else if (D == "Maxthon" && X)
          X = X.replace(/\.[\d.]+/, ".x");
        else if (/\bXbox\b/i.test(de))
          de == "Xbox 360" && (j = null), de == "Xbox 360" && /\bIEMobile\b/.test(y) && he.unshift("mobile mode");
        else if ((/^(?:Chrome|IE|Opera)$/.test(D) || D && !de && !/Browser|Mobi/.test(D)) && (j == "Windows CE" || /Mobi/i.test(y)))
          D += " Mobile";
        else if (D == "IE" && Ne)
          try {
            A.external === null && he.unshift("platform preview");
          } catch {
            he.unshift("embedded");
          }
        else (/\bBlackBerry\b/.test(de) || /\bBB10\b/.test(y)) && (R = (RegExp(de.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(y) || 0)[1] || X) ? (R = [R, /BB10/.test(y)], j = (R[1] ? (de = null, be = "BlackBerry") : "Device Software") + " " + R[0], X = null) : this != m && de != "Wii" && (Ne && Je || /Opera/.test(D) && /\b(?:MSIE|Firefox)\b/i.test(y) || D == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(j) || D == "IE" && (j && !/^Win/.test(j) && X > 5.5 || /\bWindows XP\b/.test(j) && X > 8 || X == 8 && !/\bTrident\b/.test(y))) && !l.test(R = k.call(m, y.replace(l, "") + ";")) && R.name && (R = "ing as " + R.name + ((R = R.version) ? " " + R : ""), l.test(D) ? (/\bIE\b/.test(R) && j == "Mac OS" && (j = null), R = "identify" + R) : (R = "mask" + R, we ? D = b(we.replace(/([a-z])([A-Z])/g, "$1 $2")) : D = "Opera", /\bIE\b/.test(R) && (j = null), Ne || (X = null)), me = ["Presto"], he.push(R));
        (R = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(y) || 0)[1]) && (R = [parseFloat(R.replace(/\.(\d)$/, ".0$1")), R], D == "Safari" && R[1].slice(-1) == "+" ? (D = "WebKit Nightly", ct = "alpha", X = R[1].slice(0, -1)) : (X == R[1] || X == (R[2] = (/\bSafari\/([\d.]+\+?)/i.exec(y) || 0)[1])) && (X = null), R[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(y) || 0)[1], R[0] == 537.36 && R[2] == 537.36 && parseFloat(R[1]) >= 28 && me == "WebKit" && (me = ["Blink"]), !Ne || !z && !R[1] ? (me && (me[1] = "like Safari"), R = (R = R[0], R < 400 ? 1 : R < 500 ? 2 : R < 526 ? 3 : R < 533 ? 4 : R < 534 ? "4+" : R < 535 ? 5 : R < 537 ? 6 : R < 538 ? 7 : R < 601 ? 8 : R < 602 ? 9 : R < 604 ? 10 : R < 606 ? 11 : R < 608 ? 12 : "12")) : (me && (me[1] = "like Chrome"), R = R[1] || (R = R[0], R < 530 ? 1 : R < 532 ? 2 : R < 532.05 ? 3 : R < 533 ? 4 : R < 534.03 ? 5 : R < 534.07 ? 6 : R < 534.1 ? 7 : R < 534.13 ? 8 : R < 534.16 ? 9 : R < 534.24 ? 10 : R < 534.3 ? 11 : R < 535.01 ? 12 : R < 535.02 ? "13+" : R < 535.07 ? 15 : R < 535.11 ? 16 : R < 535.19 ? 17 : R < 536.05 ? 18 : R < 536.1 ? 19 : R < 537.01 ? 20 : R < 537.11 ? "21+" : R < 537.13 ? 23 : R < 537.18 ? 24 : R < 537.24 ? 25 : R < 537.36 ? 26 : me != "Blink" ? "27" : "28")), me && (me[1] += " " + (R += typeof R == "number" ? ".x" : /[.+]/.test(R) ? "" : "+")), D == "Safari" && (!X || parseInt(X) > 45) ? X = R : D == "Chrome" && /\bHeadlessChrome/i.test(y) && he.unshift("headless")), D == "Opera" && (R = /\bzbov|zvav$/.exec(j)) ? (D += " ", he.unshift("desktop mode"), R == "zvav" ? (D += "Mini", X = null) : D += "Mobile", j = j.replace(RegExp(" *" + R + "$"), "")) : D == "Safari" && /\bChrome\b/.exec(me && me[1]) ? (he.unshift("desktop mode"), D = "Chrome Mobile", X = null, /\bOS X\b/.test(j) ? (be = "Apple", j = "iOS 4.3+") : j = null) : /\bSRWare Iron\b/.test(D) && !X && (X = sn("Chrome")), X && X.indexOf(R = /[\d.]+$/.exec(j)) == 0 && y.indexOf("/" + R + "-") > -1 && (j = S(j.replace(R, ""))), j && j.indexOf(D) != -1 && !RegExp(D + " OS").test(j) && (j = j.replace(RegExp(" *" + x(D) + " *"), "")), me && !/\b(?:Avant|Nook)\b/.test(D) && (/Browser|Lunascape|Maxthon/.test(D) || D != "Safari" && /^iOS/.test(j) && /\bSafari\b/.test(me[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(D) && me[1]) && (R = me[me.length - 1]) && he.push(R), he.length && (he = ["(" + he.join("; ") + ")"]), be && de && de.indexOf(be) < 0 && he.push("on " + be), de && he.push((/^on /.test(he[he.length - 1]) ? "" : "on ") + de), j && (R = / ([\d.+]+)$/.exec(j), Ee = R && j.charAt(j.length - R[0].length - 1) == "/", j = {
          architecture: 32,
          family: R && !Ee ? j.replace(R[0], "") : j,
          version: R ? R[1] : null,
          toString: function() {
            var Ue = this.version;
            return this.family + (Ue && !Ee ? " " + Ue : "") + (this.architecture == 64 ? " 64-bit" : "");
          }
        }), (R = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(tt)) && !/\bi686\b/i.test(tt) ? (j && (j.architecture = 64, j.family = j.family.replace(RegExp(" *" + R), "")), D && (/\bWOW64\b/i.test(y) || Ne && /\w(?:86|32)$/.test(T.cpuClass || T.platform) && !/\bWin64; x64\b/i.test(y)) && he.unshift("32-bit")) : j && /^OS X/.test(j.family) && D == "Chrome" && parseFloat(X) >= 39 && (j.architecture = 64), y || (y = null);
        var He = {};
        return He.description = y, He.layout = me && me[0], He.manufacturer = be, He.name = D, He.prerelease = ct, He.product = de, He.ua = y, He.version = D && X, He.os = j || {
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          architecture: null,
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          family: null,
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          version: null,
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          toString: function() {
            return "null";
          }
        }, He.parse = k, He.toString = Vn, He.version && he.unshift(X), He.name && he.unshift(D), j && D && !(j == String(j).split(" ")[0] && (j == D.split(" ")[0] || de)) && he.push(de ? "(" + j + ")" : "on " + j), he.length && (He.description = he.join(" ")), He;
      }
      var C = k();
      r && s ? m(C, function(y, A) {
        r[A] = y;
      }) : i.platform = C;
    }).call(zT);
  }(vs, vs.exports)), vs.exports;
}
var FT = HT();
const VT = /* @__PURE__ */ Z2(FT), yu = {
  mac: {
    cmd: "",
    alt: "",
    ctrl: "",
    shift: ""
  },
  other: {
    cmd: "Ctrl+",
    alt: "Alt+",
    ctrl: "Ctrl+",
    shift: "Shift+"
  }
};
let Sp = !1, f0 = yu.other;
const jT = (n) => {
  var e;
  Sp = ["OS X", "iOS"].includes(((e = n.os) == null ? void 0 : e.family) || ""), f0 = Sp ? yu.mac : yu.other;
};
jT(VT);
const Rd = (n) => n.replace(/(ctrl|cmd|alt|shift)\+/g, (e, t) => f0[t] || t), WT = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">
    <path fill-rule="evenodd" d="M12.767 13.084l-2.211 2.211 2.233 2.233-.789.789-3-3 3-3 .767.767zm.884 4.538l2.327-2.327-2.305-2.305.673-.673 3 3-3 3-.695-.695zm-5.561-15.622h9.916c1.101 0 1.993.898 1.993 1.991v16.018c0 1.099-.895 1.991-1.994 1.991h-12.012c-1.101 0-1.994-.897-1.994-1.999v-14.044l4.09-3.957zm.599 2l-.1 2.606h-2.59v13.394h12v-16h-9.31z"/>
</svg>
`;
Gb();
var UT = Z("<div></div>");
function h0(n, e) {
  ye(e, !0);
  let t = Q(e, "element", 7), i = Q(e, "event", 7), r = Q(e, "onReady", 7);
  if (typeof t() == "string") {
    const a = customElements.get(t());
    if (a)
      t(new a());
    else {
      const l = t();
      t(document.createElement("div")), t().innerHTML = l;
    }
  }
  let s = ce(void 0);
  $e(() => {
    E(s).appendChild(t()), setTimeout(() => {
      t().dispatchEvent(i()), r()(t());
    });
  });
  var o = UT();
  return et(o, (a) => q(s, a), () => E(s)), dt("mt-component-update", o, function(a) {
    Ja.call(this, e, a);
  }), F(n, o), xe({
    get element() {
      return t();
    },
    set element(a) {
      t(a), ee();
    },
    get event() {
      return i();
    },
    set event(a) {
      i(a), ee();
    },
    get onReady() {
      return r();
    },
    set onReady(a) {
      r(a), ee();
    }
  });
}
ve(h0, { element: {}, event: {}, onReady: {} }, [], [], !0);
var KT = Z('<div class="d-flex flex-column"><!> <!> <!></div>');
function qT(n, e) {
  ye(e, !1);
  let t = Q(e, "namespace", 12), i = Q(e, "detail", 12), r = gr([]), s = 0;
  window.MT.UI.Component.getAll(t()).then((b) => {
    q(r, b);
  });
  let a = [], l = gr();
  function c(b) {
    ++s === E(r).length && [...E(l).childNodes].filter((m) => m instanceof HTMLElement).forEach((m, g) => {
      var v, x;
      (x = m.style).order || (x.order = ((v = m.firstElementChild) == null ? void 0 : v.style.order) || String((g + 1) * 100));
    });
  }
  function u(b) {
    b.dispatchEvent(new CustomEvent("mt-component-init", { detail: i() })), c();
  }
  u0(() => {
    E(l).addEventListener("mt-component-update", (b) => {
      a.forEach((m) => {
        m.dispatchEvent(new CustomEvent("mt-component-update", { detail: b.detail }));
      });
    });
  }), wl();
  var d = KT(), f = L(d);
  wr(f, e, "prepend", {});
  var h = H(f, 2);
  ft(h, 1, () => E(r), kn, (b, m) => {
    var g = wi(), v = Re(g);
    {
      var x = (S) => {
        var k = wi(), C = Re(k);
        Gr(C, () => E(m), !1, (y, A) => {
          St(y, (_) => u == null ? void 0 : u(_)), dt("mt-component-update", y, function(_) {
            Ja.call(this, e, _);
          });
        }), F(S, k);
      }, w = (S) => {
        const k = ea(() => new CustomEvent("mt-component-init", { detail: i() }));
        h0(S, {
          get element() {
            return E(m);
          },
          get event() {
            return E(k);
          },
          onReady: c,
          $$events: {
            "mt-component-update"(C) {
              Ja.call(this, e, C);
            }
          }
        });
      };
      st(v, (S) => {
        typeof E(m) == "string" && customElements.get(E(m)) ? S(x) : S(w, !1);
      });
    }
    F(b, g);
  });
  var p = H(h, 2);
  return wr(p, e, "append", {}), O(d), et(d, (b) => q(l, b), () => E(l)), F(n, d), xe({
    get namespace() {
      return t();
    },
    set namespace(b) {
      t(b), ee();
    },
    get detail() {
      return i();
    },
    set detail(b) {
      i(b), ee();
    }
  });
}
ve(qT, { namespace: {}, detail: {} }, ["prepend", "append"], [], !0);
const GT = (n) => n;
function JT(n) {
  const e = n - 1;
  return e * e * e + 1;
}
function Cp(n) {
  const e = typeof n == "string" && n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return e ? [parseFloat(e[1]), e[2] || "px"] : [
    /** @type {number} */
    n,
    "px"
  ];
}
function Tp(n, { delay: e = 0, duration: t = 400, easing: i = GT } = {}) {
  const r = +getComputedStyle(n).opacity;
  return {
    delay: e,
    duration: t,
    easing: i,
    css: (s) => `opacity: ${s * r}`
  };
}
function Ep(n, { delay: e = 0, duration: t = 400, easing: i = JT, x: r = 0, y: s = 0, opacity: o = 0 } = {}) {
  const a = getComputedStyle(n), l = +a.opacity, c = a.transform === "none" ? "" : a.transform, u = l * (1 - o), [d, f] = Cp(r), [h, p] = Cp(s);
  return {
    delay: e,
    duration: t,
    easing: i,
    css: (b, m) => `
			transform: ${c} translate(${(1 - b) * d}${f}, ${(1 - b) * h}${p});
			opacity: ${l - u * m}`
  };
}
function XT(n) {
  return --n * n * n * n * n + 1;
}
const p0 = Symbol();
function YT(n) {
  Jb(p0, n);
}
function ZT() {
  return Xb(p0);
}
var QT = Z('<div class="modal show svelte-1m2bluk" tabindex="-1" role="dialog" aria-modal="true"><div role="document"><div class="modal-content"><!></div></div></div> <div class="modal-backdrop show"></div>', 1);
const eE = {
  hash: "svelte-1m2bluk",
  code: ".modal.svelte-1m2bluk {display:block;}"
};
function An(n, e) {
  ye(e, !1), Ht(n, eE);
  const t = $T();
  let i = Q(e, "open", 12, !0), r = Q(e, "id", 12, void 0), s = Q(e, "size", 12, void 0), o = Q(e, "describedby", 12, ""), a = Q(e, "labelledby", 12, "");
  function l() {
    document.body.classList.add("modal-open");
  }
  function c() {
    document.body.classList.remove("modal-open");
  }
  YT({
    closeModal() {
      i(!1);
    }
  }), Jp(() => Qa(i()), () => {
    i() ? l() : c();
  }), Xp(), wl();
  var u = wi(), d = Re(u);
  {
    var f = (h) => {
      var p = QT(), b = Re(p), m = L(b), g = L(m), v = L(g);
      wr(v, e, "default", {}), O(g), O(m), O(b);
      var x = H(b, 2);
      ne(() => {
        Ae(b, "id", r()), Ae(b, "aria-labelledby", a()), Ae(b, "aria-describedby", o()), pt(m, 1, `modal-dialog ${s() ? `modal-${s()}` : ""}`, "svelte-1m2bluk");
      }), Ho(1, m, () => Ep, () => ({ y: -50, duration: 300 })), Ho(2, m, () => Ep, () => ({ y: -50, duration: 300, easing: XT })), dt("introend", b, () => {
        t("open");
      }), dt("outroend", b, () => {
        setTimeout(
          () => {
            t("close");
          },
          100
        );
      }), Ho(3, b, () => Tp), Ho(3, x, () => Tp, () => ({ duration: 150 })), F(h, p);
    };
    st(d, (h) => {
      i() && h(f);
    });
  }
  return F(n, u), xe({
    get open() {
      return i();
    },
    set open(h) {
      i(h), ee();
    },
    get id() {
      return r();
    },
    set id(h) {
      r(h), ee();
    },
    get size() {
      return s();
    },
    set size(h) {
      s(h), ee();
    },
    get describedby() {
      return o();
    },
    set describedby(h) {
      o(h), ee();
    },
    get labelledby() {
      return a();
    },
    set labelledby(h) {
      a(h), ee();
    }
  });
}
ve(
  An,
  {
    open: {},
    id: {},
    size: {},
    describedby: {},
    labelledby: {}
  },
  ["default"],
  [],
  !0
);
var tE = Z('<div class="modal-header"><h4 class="modal-title"><!></h4> <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div>'), nE = Z('<div class="modal-footer"><!></div>'), iE = Z('<div><!> <div class="modal-body svelte-1grmgzm"><!></div> <!></div>');
const rE = {
  hash: "svelte-1grmgzm",
  code: ".modal-body.svelte-1grmgzm {max-height:600px;}"
};
function Mn(n, e) {
  const t = CT(e);
  ye(e, !1), Ht(n, rE);
  let i = ZT(), r = Q(e, "close", 12, () => {
    i.closeModal();
  });
  wl();
  var s = iE(), o = L(s);
  {
    var a = (f) => {
      var h = tE(), p = L(h), b = L(p);
      wr(b, e, "title", {}), O(p);
      var m = H(p, 2);
      O(h), dt("click", m, function(...g) {
        var v;
        (v = r()) == null || v.apply(this, g);
      }), F(f, h);
    };
    st(o, (f) => {
      t.title && f(a);
    });
  }
  var l = H(o, 2), c = L(l);
  wr(c, e, "body", {}), O(l);
  var u = H(l, 2);
  {
    var d = (f) => {
      var h = nE(), p = L(h);
      wr(p, e, "footer", {}), O(h), F(f, h);
    };
    st(u, (f) => {
      t.footer && f(d);
    });
  }
  return O(s), F(n, s), xe({
    get close() {
      return r();
    },
    set close(f) {
      r(f), ee();
    }
  });
}
ve(Mn, { close: {} }, ["title", "body", "footer"], [], !0);
var sE = Z('<li class="page-item" aria-hidden="true">...</li>'), oE = Z('<li class="page-item active"><a href="#" class="page-link"> <span class="visually-hidden">(current)</span></a></li>'), aE = Z('<li><a href="#" class="page-link"> </a></li>'), lE = Z('<div class="row"><div class="col-auto mx-auto"><nav aria-label="object list"><ul class="pagination d-none d-md-flex"><li class="page-item"><a href="#"></a></li> <!> <li class="page-item"><a href="#"></a></li></ul></nav></div></div>');
function cE(n, e) {
  ye(e, !1);
  let t = Q(e, "data", 12), i = gr(), r = gr(), s = gr();
  Jp(
    () => (E(i), Qa(t()), E(r), E(s)),
    () => {
      var u, d;
      q(i, ((u = t()) == null ? void 0 : u.totalPages) ?? 0), q(r, ((d = t()) == null ? void 0 : d.currentPage) ?? 0), q(s, []);
      let c = !1;
      for (let f = 1; f <= E(i); f++)
        f < 3 || f > E(i) - 2 || Math.abs(f - E(r)) < 2 ? (E(s).push(f), c = !1) : c || (E(s).push(0), c = !0);
    }
  ), Xp(), wl();
  var o = wi(), a = Re(o);
  {
    var l = (c) => {
      var u = lE(), d = L(u), f = L(d), h = L(f), p = L(h), b = L(p);
      let m;
      b.textContent = window.trans("Previous"), O(p);
      var g = H(p, 2);
      ft(g, 1, () => E(s), kn, (S, k) => {
        var C = wi(), y = Re(C);
        {
          var A = (T) => {
            var M = sE();
            F(T, M);
          }, _ = (T, M) => {
            {
              var z = (V) => {
                var U = oE(), J = L(U), re = L(J);
                Yp(), O(J), O(U), ne(() => B(re, `${E(k) ?? ""} `)), dt("click", J, Fo(function(te) {
                  Ja.call(this, e, te);
                })), F(V, U);
              }, P = (V) => {
                var U = aE();
                let J;
                var re = L(U), te = L(re, !0);
                O(re), O(U), ne(
                  (ge) => {
                    J = pt(U, 1, "page-item", null, J, ge), B(te, E(k));
                  },
                  [
                    () => ({
                      "first-last": E(k) === 1 || E(k) === E(i)
                    })
                  ],
                  ea
                ), dt("click", re, Fo(() => t().setPage(E(k)))), F(V, U);
              };
              st(
                T,
                (V) => {
                  E(k) === E(r) ? V(z) : V(P, !1);
                },
                M
              );
            }
          };
          st(y, (T) => {
            E(k) === 0 ? T(A) : T(_, !1);
          });
        }
        F(S, C);
      });
      var v = H(g, 2), x = L(v);
      let w;
      x.textContent = window.trans("Next"), O(v), O(h), O(f), O(d), O(u), ne(
        (S, k) => {
          m = pt(b, 1, "page-link", null, m, S), w = pt(x, 1, "page-link", null, w, k);
        },
        [
          () => ({ disabled: E(r) <= 1 }),
          () => ({
            disabled: E(r) === E(i)
          })
        ],
        ea
      ), dt("click", b, Fo(() => E(r) > 1 && t().setPage(E(r) - 1))), dt("click", x, Fo(() => E(r) !== E(i) && t().setPage(E(r) + 1))), F(c, u);
    };
    st(a, (c) => {
      t() && E(i) && E(r) && c(l);
    });
  }
  return F(n, o), xe({
    get data() {
      return t();
    },
    set data(c) {
      t(c), ee();
    }
  });
}
ve(cE, { data: {} }, [], [], !0);
var uE = Z('<div class="form-group mb-3"><textarea id="source_text" class="form-control" style="height: calc(100vh - 240px)"></textarea></div>'), dE = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function m0(n, e) {
  ye(e, !0);
  let t = Q(e, "onSubmit", 7), i = Q(e, "onClose", 7), r;
  $e(() => {
    r == null || r.focus();
  });
  let s = ce(""), o;
  return An(n, {
    size: "lg",
    $$events: {
      close(...a) {
        var l;
        (l = i()) == null || l.apply(this, a);
      }
    },
    children: (a, l) => {
      Mn(a, {
        get close() {
          return o;
        },
        set close(c) {
          o = c;
        },
        $$slots: {
          title: (c, u) => {
            var d = Cn();
            ne((f) => B(d, f), [() => I("Source Code")]), F(c, d);
          },
          body: (c, u) => {
            var d = uE(), f = L(d);
            Zp(f), et(f, (h) => r = h, () => r), O(d), ne((h) => Ae(f, "aria-label", h), [() => I("Source Code")]), kt(f, () => E(s), (h) => q(s, h)), F(c, d);
          },
          footer: (c, u) => {
            var d = dE(), f = Re(d);
            f.__click = () => {
              t()(E(s)), o();
            };
            var h = L(f, !0);
            O(f);
            var p = H(f, 2);
            p.__click = o;
            var b = L(p, !0);
            O(p), ne(
              (m, g, v, x) => {
                Ae(f, "title", m), B(h, g), Ae(p, "title", v), B(b, x);
              },
              [
                () => I("Insert (s)"),
                () => I("Insert"),
                () => I("Cancel (x)"),
                () => I("Cancel")
              ]
            ), F(c, d);
          }
        }
      });
    },
    $$slots: { default: !0 }
  }), xe({
    get onSubmit() {
      return t();
    },
    set onSubmit(a) {
      t(a), ee();
    },
    get onClose() {
      return i();
    },
    set onClose(a) {
      i(a), ee();
    }
  });
}
Ot(["click"]);
ve(m0, { onSubmit: {}, onClose: {} }, [], [], !0);
const fE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_49)">
        <path d="M47.55 54.84L42.12 49.41L55.53 36L42.12 22.59L47.55 17.16L63.68 33.29C65.18 34.79 65.18 37.22 63.68 38.72L47.55 54.85V54.84Z" fill="black"/>
        <path d="M24.45 54.84L8.32001 38.71C6.82001 37.21 6.82001 34.78 8.32001 33.28L24.45 17.15L29.88 22.58L16.47 35.99L29.88 49.4L24.45 54.83V54.84Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_49">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`;
var hE = Z('<div class="form-group mb-3"><textarea id="source_text" class="form-control" style="height: calc(100vh - 240px); max-height: 568px"></textarea></div>'), pE = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function g0(n, e) {
  ye(e, !0);
  let t = Q(e, "text", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7);
  t(y_.html(t()));
  let s;
  $e(() => {
    s == null || s.focus();
  });
  let o;
  return An(n, {
    size: "lg",
    $$events: {
      close(...a) {
        var l;
        (l = r()) == null || l.apply(this, a);
      }
    },
    children: (a, l) => {
      Mn(a, {
        get close() {
          return o;
        },
        set close(c) {
          o = c;
        },
        $$slots: {
          title: (c, u) => {
            var d = Cn();
            ne((f) => B(d, f), [() => I("Source Code")]), F(c, d);
          },
          body: (c, u) => {
            var d = hE(), f = L(d);
            Zp(f), et(f, (h) => s = h, () => s), O(d), ne((h) => Ae(f, "aria-label", h), [() => I("Source Code")]), kt(f, t), F(c, d);
          },
          footer: (c, u) => {
            var d = pE(), f = Re(d);
            f.__click = () => {
              i()(t()), o();
            };
            var h = L(f, !0);
            O(f);
            var p = H(f, 2);
            p.__click = o;
            var b = L(p, !0);
            O(p), ne(
              (m, g, v, x) => {
                Ae(f, "title", m), B(h, g), Ae(p, "title", v), B(b, x);
              },
              [
                () => I("Save (s)"),
                () => I("Save"),
                () => I("Cancel (x)"),
                () => I("Cancel")
              ]
            ), F(c, d);
          }
        }
      });
    },
    $$slots: { default: !0 }
  }), xe({
    get text() {
      return t();
    },
    set text(a) {
      t(a), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(a) {
      i(a), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(a) {
      r(a), ee();
    }
  });
}
Ot(["click"]);
ve(g0, { text: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const mE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M18.045 7.95c0-1.877-1.596-3.95-4.207-3.95h-8.262c-.427 0-.576.24-.576.647v14.79c0 .406.204.563.631.563h8.484c3.111 0 4.885-2.063 4.885-4.342 0-2.306-1.446-3.943-2.96-4.27.9-.409 2.006-1.561 2.006-3.438zm-5.326-.95c.867 0 1.497.682 1.497 1.5 0 .694-.52 1.5-1.497 1.5h-4.52v-3h4.52zm-4.52 9.5v-3h5.57c.897 0 1.472.775 1.472 1.5 0 .948-.79 1.5-1.472 1.5h-5.57z"/></svg>', gE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M12.435 16.33l.105-.38c.005-.021.557-2.182 1.147-4.438 1.015-3.879 1.263-4.66 1.318-4.779.189-.396.495-.695.936-.916.381-.19.866-.315 1.443-.373.17-.018.33-.113.447-.267.106-.14.168-.317.168-.486 0-.381-.306-.692-.682-.692h-7.733c-.376 0-.682.311-.682.692v.024c0 .341.241.628.573.682.439.072 1.042.172 1.515.399.243.116.431.257.557.418.143.182.213.393.213.642 0 .467-.135.935-.265 1.387l-.082.291c-.167.603-.412 1.519-.696 2.579-.655 2.441-1.47 5.477-1.675 6.055-.138.389-.65 1.311-2.413 1.448-.171.013-.332.092-.447.219-.117.129-.181.294-.181.47v.002c0 .381.306.692.682.692h7.735c.376 0 .682-.311.682-.692v-.005c0-.349-.257-.644-.598-.685l-.201-.024c-.679-.079-1.523-.179-1.878-.647-.165-.217-.217-.504-.163-.872.035-.249.105-.491.178-.745"/></svg>', _E = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M6 20h12v1h-12v-1zm12-7.242c0 1.907-.532 3.324-1.596 4.251-1.064.927-2.535 1.391-4.414 1.391-1.905 0-3.379-.46-4.424-1.381-1.044-.921-1.567-2.341-1.567-4.261v-8.758h3.094v8.758c0 .381.033.756.099 1.124.066.368.204.694.414.976.21.283.502.513.877.69.374.178.877.266 1.507.266 1.103 0 1.865-.247 2.286-.74.42-.493.631-1.266.631-2.318v-8.758h3.094v8.758z"/></svg>', bE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_45)">
        <path d="M64.8 37.01H51.4V36.28C51.4 32.16 52.74 30.45 55.27 30.45C57.39 30.45 58.58 31.7 58.98 33.73H63.16C62.44 29.02 59.54 26.77 55.27 26.77C50.43 26.77 47.03 29.64 47.03 36.29V37.02H42.11C43.55 36.14 44.47 34.7 44.47 32.7C44.47 28.86 41.69 27.05 36.61 27.05H29.4V37.01H23.97L20.5 27.05H16.32L12.85 37.01H7.19V40.21H11.74L8.83 48.57H13.51L14.82 44.48H22.03L23.34 48.57H27.99L25.08 40.21H29.39V48.57H37.28C42.96 48.57 45.14 45.73 45.14 42.39C45.14 41.56 45 40.84 44.76 40.2H47.04C47.33 46.17 50.63 48.85 55.25 48.85C59.87 48.85 62.4 46.73 63.11 41.89H58.96C58.49 44.07 57.43 45.17 55.25 45.17C52.92 45.17 51.6 43.59 51.41 40.21H64.79V37.01H64.8ZM33.77 30.72H36.2C39.35 30.72 40.1 31.59 40.1 33.09C40.1 34.59 39.07 35.55 36.67 35.55H33.77V30.71V30.72ZM18.42 33.22L19.64 37.01H17.21L18.43 33.22H18.42ZM20.85 40.8H15.98L16.17 40.2H20.65L20.84 40.8H20.85ZM40.79 42.05C40.79 43.89 39.54 44.89 36.92 44.89H33.77V40.21H40.14C40.58 40.65 40.8 41.25 40.8 42.05H40.79Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_45">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, vE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M8 11.505c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm0 6c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm0-12c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm-3 1.495c-.552 0-1-.448-1-1s.448-1 1-1 1 .448 1 1-.448 1-1 1zm0 6c-.552 0-1-.448-1-1s.448-1 1-1 1 .448 1 1-.448 1-1 1zm0 6c-.552 0-1-.448-1-1s.448-1 1-1 1 .448 1 1-.448 1-1 1z"/></svg>', yE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M6 18.5h-2v-.5h2v-1h.5v2.5h-2.5v-.5h2v-.5zm-2-6.25v-.25h2v-1h.5v1.5h-2v.5h2v.5h-2.5v-1.25zm4-.745c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm0 6c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm0-12c0-.279.229-.505.5-.505h10.999c.276 0 .5.214.5.505v.991c0 .279-.229.505-.5.505h-10.999c-.276 0-.5-.214-.5-.505v-.991zm-3-1.005h.5v3h-.5v-3zm-1 6.5h2v.5h-2v-.5zm0 6h2v.5h-2v-.5z"/></svg>', xE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <path d="M63 32H9V40H63V32Z" fill="black"/>
</svg>
`, wE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_31)">
        <path d="M30.09 44.49H13.05V31.36C13.05 26.53 14.05 22.71 16.07 19.92C18.09 17.13 21.53 14.66 26.41 12.51L30.09 19.49C27.09 20.9 25.01 22.31 23.86 23.7C22.71 25.1 22.07 26.75 21.94 28.66H30.09V44.49ZM49.95 44.49H32.91V31.36C32.91 26.53 33.91 22.71 35.93 19.92C37.95 17.13 41.39 14.66 46.27 12.51L49.95 19.49C46.95 20.9 44.87 22.31 43.72 23.7C42.57 25.09 41.93 26.75 41.8 28.66H49.95V44.49Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_31">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, kE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">
    <path fill-rule="evenodd" d="M16.407 6.284l1.732 1c.957.552 1.284 1.775.732 2.732l-5 8.66c-.552.957-1.775 1.284-2.732.732l-1.732-1-1.5 2.598c-.276.478-.888.642-1.366.366-.478-.276-.642-.888-.366-1.366l1.5-2.598-1.732-1c-.957-.552-1.284-1.775-.732-2.732l5-8.66c.552-.957 1.775-1.284 2.732-.732l1.732 1 1.5-2.598c.276-.478.888-.642 1.366-.366.478.276.642.888.366 1.366l-1.5 2.598zm-1 1.732l-.5.866c-.276.478-.888.642-1.366.366-.478-.276-.642-.888-.366-1.366l.5-.866-1.299-.75c-.239-.138-.545-.056-.683.183l-4.5 7.794c-.138.239-.056.545.183.683l1.299.75.5-.866c.276-.478.888-.642 1.366-.366.478.276.642.888.366 1.366l-.5.866 1.299.75c.239.138.545.056.683-.183l4.5-7.794c.138-.239.056-.545-.183-.683l-1.299-.75zm-6.696-.402l-1.961 3.397c.443-.415.872-.503 1.287-.263.415.24.564.661.445 1.263l1.961-3.397c-.448.57-.921.711-1.42.423-.499-.288-.603-.762-.312-1.423zm6.928 4l-1.961 3.397c.443-.415.872-.503 1.287-.263.415.24.564.661.445 1.263l1.961-3.397c-.448.57-.921.711-1.42.423-.499-.288-.603-.762-.312-1.423zm4.464 1.634c.138.239.056.545-.183.683l-.866.5c-.239.138-.545.056-.683-.183s-.056-.545.183-.683l.866-.5c.239-.138.545-.056.683.183zm-2.866 2.964c.276 0 .5.224.5.5v1c0 .276-.224.5-.5.5s-.5-.224-.5-.5v-1c0-.276.224-.5.5-.5zm2.732.268c-.138.239-.444.321-.683.183l-.866-.5c-.239-.138-.321-.444-.183-.683.138-.239.444-.321.683-.183l.866.5c.239.138.321.444.183.683zm-12.64-10.607c.276 0 .5.224.5.5v1c0 .276-.224.5-.5.5s-.5-.224-.5-.5v-1c0-.276.224-.5.5-.5zm-1.134 3.964c.138.239.056.545-.183.683l-.866.5c-.239.138-.545.056-.683-.183s-.056-.545.183-.683l.866-.5c.239-.138.545-.056.683.183zm.134-1.232c-.138.239-.444.321-.683.183l-.866-.5c-.239-.138-.321-.444-.183-.683.138-.239.444-.321.683-.183l.866.5c.239.138.321.444.183.683z"/>
</svg>
`, SE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_171)">
        <path d="M43.45 22.79H26.67L34.86 14.43L28.46 8.10001L9.65002 27.31L28.47 46.52L34.87 40.19L26.68 31.83H43.46C48.93 31.83 53.38 36.4 53.38 42.02V44.69C53.38 50.31 48.93 54.88 43.46 54.88V63.9C53.88 63.9 62.36 55.28 62.36 44.68V42.01C62.36 31.41 53.88 22.79 43.46 22.79H43.45Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_171">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, CE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_35)">
        <path d="M43.53 8.10001L37.13 14.43L45.32 22.79H28.54C18.12 22.79 9.64001 31.41 9.64001 42.01V44.68C9.64001 55.28 18.12 63.9 28.54 63.9V54.88C23.07 54.88 18.62 50.31 18.62 44.69V42.02C18.62 36.4 23.07 31.83 28.54 31.83H45.32L37.13 40.19L43.53 46.52L62.35 27.31L43.53 8.10001Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_35">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, TE = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_39)">
        <path d="M39 56.99H9V62.99H39V56.99Z" fill="black"/>
        <path d="M57 9L55.41 17.02H40.79L33.12 52.49H23.45L31.12 17.02H16.5L18.09 9H57Z" fill="black"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M56.7601 52.5L62.1101 47.15C63.2801 45.98 63.2801 44.08 62.1101 42.91L62.0801 42.88C60.9101 41.71 59.0101 41.71 57.8401 42.88L52.4901 48.23L47.1401 42.88C45.9701 41.71 44.0701 41.71 42.9001 42.88L42.8701 42.91C41.7001 44.08 41.7001 45.98 42.8701 47.15L48.2201 52.5L42.8701 57.85C41.7001 59.02 41.7001 60.92 42.8701 62.09L42.9001 62.12C44.0701 63.29 45.9701 63.29 47.1401 62.12L52.4901 56.77L57.8401 62.12C59.0101 63.29 60.9101 63.29 62.0801 62.12L62.1101 62.09C63.2801 60.92 63.2801 59.02 62.1101 57.85L56.7601 52.5Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_39">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, EE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path id="a" fill-rule="evenodd" d="M8 6.49c0-.271.229-.49.5-.49h10.999c.276 0 .5.215.5.49v3.019c0 .271-.229.49-.5.49h-10.999c-.276 0-.5-.215-.5-.49v-3.019zm-4-1.994c0-.274.214-.496.505-.496h.991c.279 0 .505.226.505.496v15.007c0 .274-.214.496-.505.496h-.991c-.279 0-.505-.226-.505-.496v-15.007zm4 9.994c0-.271.231-.49.5-.49h6.999c.276 0 .5.215.5.49v3.019c0 .271-.231.49-.5.49h-6.999c-.276 0-.5-.215-.5-.49v-3.019z"/></svg>
`, AE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M11 13v-2h-7.5c-.276 0-.5-.215-.5-.49v-3.019c0-.271.228-.49.5-.49h7.5v-2.504c0-.274.214-.496.505-.496h.991c.279 0 .505.226.505.496v2.504h7.5c.276 0 .5.215.5.49v3.019c0 .271-.228.49-.5.49h-7.5v2h2.5c.276 0 .5.215.5.49v3.019c0 .271-.231.49-.5.49h-2.5v2.504c0 .274-.214.496-.505.496h-.991c-.279 0-.505-.226-.505-.496v-2.504h-2.5c-.276 0-.5-.215-.5-.49v-3.019c0-.271.231-.49.5-.49h2.5z"/></svg>', ME = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M4 6.49c0-.271.229-.49.5-.49h10.999c.276 0 .5.215.5.49v3.019c0 .271-.229.49-.5.49h-10.999c-.276 0-.5-.215-.5-.49v-3.019zm4 8c0-.271.231-.49.5-.49h6.999c.276 0 .5.215.5.49v3.019c0 .271-.231.49-.5.49h-6.999c-.276 0-.5-.215-.5-.49v-3.019zm10-9.994c0-.274.214-.496.505-.496h.991c.279 0 .505.226.505.496v15.007c0 .274-.214.496-.505.496h-.991c-.279 0-.505-.226-.505-.496v-15.007z"/></svg>', OE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M6.553 12.06c0 .06-.036.112-.088.135l.002.003-3.216 1.856a.147.147 0 0 1-.25-.1H3v-3.787a.148.148 0 0 1 .253-.103l3.229 1.864-.004.006a.146.146 0 0 1 .075.126zM3.5 3h17a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm6 5h11a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm0 5h11a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm-6 5h17a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5z"/></svg>', NE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M3 12.06c0-.055.031-.1.075-.126l-.004-.006L6.3 10.064a.147.147 0 0 1 .253.103v3.786a.147.147 0 0 1-.25.101l-3.216-1.856.001-.003A.147.147 0 0 1 3 12.06zM3.5 3h17a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm6 5h11a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm0 5h11a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5zm-6 5h17a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-17a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5z"/></svg>', LE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path fill-rule="evenodd" d="M3.923 15.095c.019-.117.102-.213.215-.249.113-.036.236-.006.319.077l1.08 1.08 2.899-2.899c.123-.123.323-.123.446 0l1.998 1.998c.123.123.123.323 0 .446l-2.9 2.899 1.08 1.08c.084.083.114.207.078.319-.036.113-.131.196-.248.215l-5.523.933c-.101.017-.203-.015-.276-.087v-.001c-.072-.072-.105-.174-.088-.274l.919-5.538zm16.154-6.19c-.019.117-.102.213-.215.249-.113.036-.236.006-.32-.077l-1.08-1.08-2.899 2.899c-.123.123-.323.123-.446 0l-1.998-1.998c-.123-.123-.123-.323 0-.446l2.9-2.9-1.08-1.08c-.084-.084-.114-.207-.078-.319.036-.113.132-.196.248-.215l5.523-.933c.101-.017.203.016.276.088v.001c.072.072.105.174.088.274l-.919 5.538z"/></svg>
`, en = (n, e, t, i, r, s) => {
  var o, a;
  return i ?? (i = `toggle${e.slice(0, 1).toUpperCase() + e.slice(1)}`), r ?? (r = "is-active"), s ?? (s = (l) => l.tiptap.isActive(e)), a = class extends Wr {
    constructor() {
      super();
      Le(this, o);
      Oe(this, o, document.createElement("button")), G(this, o).title = typeof n == "string" ? I(n) : `${I(n[0])} (${Rd(n[1])})`, G(this, o).innerHTML = t, this.shadowRoot.appendChild(G(this, o));
    }
    connectedCallback() {
      super.connectedCallback(), this.addEventListener("click", () => {
        const c = this.tiptap;
        c && (typeof i == "function" ? i(c) : c.chain().focus()[i]().run());
      });
    }
    onEditorUpdate() {
      if (r !== !1) {
        const c = s(this.editor);
        G(this, o).classList.toggle(r, c), r === "is-disabled" && (G(this, o).disabled = c);
      }
    }
  }, o = new WeakMap(), a;
}, Id = (n, e, t) => {
  var r, s;
  const i = e.substring(5).toLowerCase();
  return s = class extends Wr {
    constructor() {
      super();
      Le(this, r);
      Oe(this, r, document.createElement("button")), G(this, r).title = typeof n == "string" ? I(n) : `${I(n[0])} (${Rd(n[1])})`, G(this, r).innerHTML = t, this.shadowRoot.appendChild(G(this, r));
    }
    connectedCallback() {
      super.connectedCallback(), this.addEventListener("click", () => {
        const a = this.tiptap;
        if (!a)
          return;
        const l = a.state.selection.$head.parent.type.name;
        a.getAttributes(l).textAlign === i ? a.chain().focus().unsetTextAlign().run() : a.chain().focus().setTextAlign(i).run();
      });
    }
    onEditorUpdate() {
      const a = this.tiptap;
      if (!a)
        return;
      const l = a.state.selection.$head.parent.type.name, c = a.getAttributes(l).textAlign;
      G(this, r).classList.toggle("is-active", c === i);
    }
  }, r = new WeakMap(), s;
}, RE = en(["Bold", "cmd+B"], "bold", mE), IE = en(["Italic", "cmd+I"], "italic", gE), PE = en(
  ["Underline", "cmd+U"],
  "underline",
  _E
), DE = en("Strike", "strike", bE), $E = en(
  "Unlink",
  "unlink",
  kE,
  "unsetLink",
  "is-disabled",
  (n) => !n.tiptap.isActive("link")
), BE = en(
  "Bullet List",
  "bulletList",
  vE,
  (n) => {
    n.chain().focus().lift(n.state.selection.$from.before()).setNode(n.isActive("bulletList") ? "paragraph" : "textBlock").run(), n.chain().toggleBulletList().run();
  }
), zE = en(
  "Ordered List",
  "orderedList",
  yE,
  (n) => {
    n.chain().focus().lift(n.state.selection.$from.before()).setNode(n.isActive("orderedList") ? "paragraph" : "textBlock").run(), n.chain().toggleOrderedList().run();
  }
), HE = en("Blockquote", "blockquote", wE), FE = en(
  ["Undo", "cmd+Z"],
  "undo",
  SE,
  "undo",
  "is-disabled",
  (n) => iS(n.tiptap.state) === 0
), VE = en(
  ["Redo", "cmd+Y"],
  "redo",
  CE,
  "redo",
  "is-disabled",
  (n) => rS(n.tiptap.state) === 0
), jE = en(
  "Remove Format",
  "removeFormat",
  TE,
  (n) => n.chain().focus().unsetAllMarks().clearNodes().run(),
  !1
), WE = Id("Align Left", "alignLeft", EE), UE = Id(
  "Align Center",
  "alignCenter",
  AE
), KE = Id(
  "Align Right",
  "alignRight",
  ME
), qE = en("Indent", "indent", OE, "indent", !1), GE = en("Outdent", "outdent", NE, "outdent", !1);
class JE extends Wr {
  constructor() {
    super();
    const e = document.createElement("button");
    e.title = I("Horizontal Rule"), e.innerHTML = xE, this.shadowRoot.appendChild(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", () => {
      const e = this.tiptap;
      e && e.chain().focus().setHorizontalRule().run();
    });
  }
}
class XE extends Wr {
  constructor() {
    super();
    const e = document.createElement("button");
    e.title = I("Insert HTML"), e.innerHTML = WT, this.shadowRoot.appendChild(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", () => {
      const e = this.tiptap;
      if (!e)
        return;
      const t = Nt(m0, {
        target: document.body,
        props: {
          onSubmit: (i) => {
            e.commands.insertContent(_r(i));
          },
          onClose: () => {
            at(t);
          }
        }
      });
    });
  }
}
class YE extends Wr {
  constructor() {
    super();
    const e = document.createElement("button");
    e.title = I("Toggle to HTML editing mode"), e.innerHTML = fE, this.shadowRoot.appendChild(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", () => {
      const e = this.tiptap;
      if (!e)
        return;
      const t = Nt(g0, {
        target: document.body,
        props: {
          text: Ic(e.getHTML()),
          onSubmit: (i) => {
            e.commands.setContent(_r(i));
          },
          onClose: () => {
            at(t);
          }
        }
      });
    });
  }
}
var pi, Ii;
class ZE extends Wr {
  constructor() {
    super();
    Le(this, pi);
    Le(this, Ii);
    Oe(this, Ii, document.createElement("style")), G(this, Ii).textContent = "body { overflow: hidden; }", Oe(this, pi, document.createElement("button")), G(this, pi).title = I("Full Screen"), G(this, pi).innerHTML = LE, this.shadowRoot.appendChild(G(this, pi));
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", () => {
      const t = this.editor;
      if (!t)
        return;
      const i = t[vn].classList.contains(
        "mt-rich-text-editor-editor--fullscreen"
      );
      t[vn].classList.toggle("mt-rich-text-editor-editor--fullscreen"), G(this, pi).classList.toggle("is-active", !i), i ? document.body.removeChild(G(this, Ii)) : document.body.appendChild(G(this, Ii));
    });
  }
}
pi = new WeakMap(), Ii = new WeakMap();
const _0 = (n) => class extends n {
  constructor() {
    super(...arguments);
    _n(this, "editor");
    _n(this, "options", {});
  }
  get tiptap() {
    var t;
    return (t = this.editor) == null ? void 0 : t.tiptap;
  }
  get shadowRoot() {
    return super.shadowRoot;
  }
  onEditorInit(t, i) {
    this.editor = t, this.options = i;
  }
  onEditorUpdate() {
  }
}, b0 = document.createElement("style");
b0.textContent = Yb;
const tn = (n) => class extends _0(n) {
  connectedCallback() {
    super.connectedCallback(), this.shadowRoot.appendChild(b0.cloneNode(!0));
  }
}, QE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">
    <path fill-rule="evenodd" d="M16.366 6.438l1.732 1c.957.552 1.284 1.775.732 2.732l-5 8.66c-.552.957-1.775 1.284-2.732.732l-1.732-1-1.5 2.598c-.276.478-.888.642-1.366.366-.478-.276-.642-.888-.366-1.366l1.5-2.598-1.732-1c-.957-.552-1.284-1.775-.732-2.732l5-8.66c.552-.957 1.775-1.284 2.732-.732l1.732 1 1.5-2.598c.276-.478.888-.642 1.366-.366.478.276.642.888.366 1.366l-1.5 2.598zm-1 1.732l-.5.866c-.276.478-.888.642-1.366.366-.478-.276-.642-.888-.366-1.366l.5-.866-1.299-.75c-.239-.138-.545-.056-.683.183l-4.5 7.794c-.138.239-.056.545.183.683l1.299.75.5-.866c.276-.478.888-.642 1.366-.366.478.276.642.888.366 1.366l-.5.866 1.299.75c.239.138.545.056.683-.183l4.5-7.794c.138-.239.056-.545-.183-.683l-1.299-.75z"/>
</svg>
`;
var eA = Z('<div class="toolbar-group svelte-16z2bvg"></div>'), tA = Z("<div></div>");
const nA = {
  hash: "svelte-16z2bvg",
  code: `.toolbar.svelte-16z2bvg {position:absolute;background-color:#fff;border:1px solid #ccc;z-index:1200;border-radius:4px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);gap:5px;}.toolbar.svelte-16z2bvg::after,
  .toolbar.svelte-16z2bvg::before {content:"";position:absolute;left:50%;transform:translateX(-50%);width:0;height:0;}

  /* Arrow at the bottom */.toolbar--top.svelte-16z2bvg::before {bottom:-9px;border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid #ccc;}.toolbar--top.svelte-16z2bvg::after {bottom:-7px;border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff;}

  /* Arrow at the top */.toolbar--bottom.svelte-16z2bvg::before {top:-9px;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:8px solid #ccc;}.toolbar--bottom.svelte-16z2bvg::after {top:-7px;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff;}.toolbar-group.svelte-16z2bvg {display:flex;gap:5px;padding:4px;}.toolbar-item.svelte-16z2bvg {display:flex;align-items:center;justify-content:center;}`
};
function Pd(n, e) {
  ye(e, !0), Ht(n, nA);
  const t = Q(e, "editor", 7), i = Q(e, "condition", 7), r = Q(e, "targetNodeName", 7), s = Q(e, "targetNodeTagName", 7), o = Q(e, "items", 7), a = t().tiptap, l = a.view.dom, c = {}, u = o().map((S) => S.map((k) => ({
    name: k,
    elementName: Jr("toolbar", k),
    icon: k
  })));
  let d = ce(!1), f = ce(0), h = ce(0), p, b = ce(!1);
  const m = () => {
    if (q(d, !t().getStructureMode() && i()(), !0), E(d)) {
      v();
      for (const S in c)
        "onEditorUpdate" in c[S] && c[S].onEditorUpdate();
    }
  };
  a.on("selectionUpdate", m), a.on("update", m);
  const g = (S) => {
    var A;
    const k = S.dom.getBoundingClientRect(), { selection: C } = S.state;
    let y = null;
    if (a.isActive(r())) {
      const _ = S.domAtPos(C.from);
      if (_.node && (y = _.node, y.nodeType === Node.TEXT_NODE && (y = y.parentElement)), s() === "A" && (y == null ? void 0 : y.tagName) !== "A") {
        const T = S.domAtPos(C.from - 1);
        T.node && (y = T.node, y.nodeType === Node.TEXT_NODE && (y = y.parentElement));
      }
      if (y && s() !== y.tagName) {
        const T = y.querySelector(s());
        T && (y = T);
      }
    }
    if (!y) {
      const _ = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ((A = C.node) == null ? void 0 : A.type.name) === r() ? C.$anchor : Zi((T) => T.type.name === r())(C)
      );
      if (!_) {
        q(f, 0), q(h, 0);
        return;
      }
      if (y = S.nodeDOM(_.pos), !y) {
        q(f, 0), q(h, 0);
        return;
      }
    }
    (async () => {
      y instanceof HTMLImageElement && !y.complete && await new Promise((re) => {
        y.onload = re;
      });
      const _ = y.getBoundingClientRect();
      if (!(_.top < k.bottom && _.bottom > k.top && _.left < k.right && _.right > k.left)) {
        q(f, 0), q(h, 0);
        return;
      }
      const M = (p == null ? void 0 : p.offsetWidth) || 0, z = (p == null ? void 0 : p.offsetHeight) || 0, P = y.offsetWidth, V = _.top - k.top - z - 10, U = _.bottom - k.top + 10;
      q(b, V < 0), q(f, E(b) ? U : V, !0);
      const J = _.left - k.left + P / 2 - M / 2;
      J + k.left < vo ? q(h, vo - k.left) : J + k.left + P > window.innerWidth - vo ? q(h, window.innerWidth - vo - k.left - P) : q(h, J);
    })();
  }, v = () => {
    try {
      g(a.view);
    } catch {
    }
  };
  function x(S, k) {
    return c[k] = S, "onEditorInit" in c[k] && c[k].onEditorInit(t(), {}), {
      destroy() {
        delete c[k];
      }
    };
  }
  $e(() => {
    l.addEventListener("scroll", () => {
      E(d) && v();
    }), E(d) && v();
  });
  var w = tA();
  return ft(w, 21, () => u, kn, (S, k) => {
    var C = eA();
    ft(C, 21, () => E(k), (y) => y.name, (y, A) => {
      var _ = wi(), T = Re(_);
      Gr(T, () => E(A).elementName, !1, (M, z) => {
        St(M, (P, V) => x == null ? void 0 : x(P, V), () => E(A).name), pt(M, 0, "toolbar-item svelte-16z2bvg");
      }), F(y, _);
    }), O(C), F(S, C);
  }), O(w), et(w, (S) => p = S, () => p), ne(() => {
    pt(w, 1, `toolbar ${E(b) ? "toolbar--bottom" : "toolbar--top"}`, "svelte-16z2bvg"), qs(w, `
    display: ${E(d) && (E(f) || E(h)) ? "flex" : "none"};
    background-color: #fff;
    top: ${E(f)}px; 
    left: ${E(h)}px;
  `);
  }), F(n, w), xe({
    get editor() {
      return t();
    },
    set editor(S) {
      t(S), ee();
    },
    get condition() {
      return i();
    },
    set condition(S) {
      i(S), ee();
    },
    get targetNodeName() {
      return r();
    },
    set targetNodeName(S) {
      r(S), ee();
    },
    get targetNodeTagName() {
      return s();
    },
    set targetNodeTagName(S) {
      s(S), ee();
    },
    get items() {
      return o();
    },
    set items(S) {
      o(S), ee();
    }
  });
}
ve(
  Pd,
  {
    editor: {},
    condition: {},
    targetNodeName: {},
    targetNodeTagName: {},
    items: {}
  },
  [],
  [],
  !0
);
function v0(n, e) {
  ye(e, !0);
  const t = Q(e, "editor", 7);
  return Pd(n, {
    get editor() {
      return t();
    },
    targetNodeName: "link",
    targetNodeTagName: "A",
    condition: () => {
      var r, s;
      return !t().isPasting() && ((r = t().tiptap) == null ? void 0 : r.isActive("link")) && !((s = t().tiptap) != null && s.isActive("link", { class: "mt-asset-link" }));
    },
    items: [["previewLink", "editLink", "unlink"]]
  }), xe({
    get editor() {
      return t();
    },
    set editor(r) {
      t(r), ee();
    }
  });
}
ve(v0, { editor: {} }, [], [], !0);
var kr;
class iA {
  constructor({ editor: e }) {
    Le(this, kr);
    Oe(this, kr, Nt(v0, {
      target: e.tiptap.view.dom.getRootNode(),
      props: {
        editor: e
      }
    }));
  }
  destroy() {
    G(this, kr) && at(G(this, kr));
  }
}
kr = new WeakMap();
var rA = Z('<div class="form-group mb-3"><label for="link-url" class="form-label"> </label> <input type="url" id="link-url" class="form-control"></div> <div class="form-group mb-3"><label for="link-text" class="form-label"> </label> <input type="text" id="link-text" class="form-control"></div> <div class="form-group mb-3"><label for="link-title" class="form-label"> </label> <input type="text" id="link-title" class="form-control"></div> <div class="form-group mb-3"><label for="link-target" class="form-label"> </label> <select id="link-target" class="form-select"><option> </option><option> </option></select></div>', 1), sA = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function Dd(n, e) {
  ye(e, !0);
  let t = Q(e, "linkData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().url)), o = ce(Fe(t().text)), a = ce(Fe(t().title)), l = ce(Fe(t().target)), c;
  $e(() => {
    c == null || c.focus();
  });
  let u = t().text !== "";
  const d = () => {
    u = !0;
  };
  $e(() => {
    u || q(o, E(s), !0);
  });
  let f, h;
  return et(
    An(n, {
      $$events: {
        close(...p) {
          var b;
          (b = r()) == null || b.apply(this, p);
        }
      },
      children: (p, b) => {
        Mn(p, {
          get close() {
            return h;
          },
          set close(m) {
            h = m;
          },
          $$slots: {
            title: (m, g) => {
              var v = Cn();
              ne((x) => B(v, x), [() => I("Insert Link")]), F(m, v);
            },
            body: (m, g) => {
              var v = rA(), x = Re(v), w = L(x), S = L(w, !0);
              O(w);
              var k = H(w, 2);
              ht(k), et(k, (fe) => c = fe, () => c), O(x);
              var C = H(x, 2), y = L(C), A = L(y, !0);
              O(y);
              var _ = H(y, 2);
              ht(_), _.__change = d, O(C);
              var T = H(C, 2), M = L(T), z = L(M, !0);
              O(M);
              var P = H(M, 2);
              ht(P), O(T);
              var V = H(T, 2), U = L(V), J = L(U, !0);
              O(U);
              var re = H(U, 2), te = L(re);
              te.value = (te.__value = "_self") == null ? "" : "_self";
              var ge = L(te, !0);
              O(te);
              var se = H(te);
              se.value = (se.__value = "_blank") == null ? "" : "_blank";
              var Be = L(se, !0);
              O(se), O(re), O(V), ne(
                (fe, Je, we, R, tt, he) => {
                  B(S, fe), B(A, Je), B(z, we), B(J, R), B(ge, tt), B(Be, he);
                },
                [
                  () => I("Link URL"),
                  () => I("Link Text"),
                  () => I("Title"),
                  () => I("Link Target"),
                  () => I("LINK_TARGET_SELF"),
                  () => I("LINK_TARGET_BLANK")
                ]
              ), kt(k, () => E(s), (fe) => q(s, fe)), kt(_, () => E(o), (fe) => q(o, fe)), kt(P, () => E(a), (fe) => q(a, fe)), mr(re, () => E(l), (fe) => q(l, fe)), F(m, v);
            },
            footer: (m, g) => {
              var v = sA(), x = Re(v);
              x.__click = () => {
                i()({
                  url: E(s),
                  text: E(o),
                  title: E(a),
                  target: E(l)
                }), h();
              };
              var w = L(x, !0);
              O(x);
              var S = H(x, 2);
              S.__click = h;
              var k = L(S, !0);
              O(S), ne(
                (C, y, A, _) => {
                  Ae(x, "title", C), B(w, y), Ae(S, "title", A), B(k, _);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(m, v);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (p) => f = p,
    () => f
  ), xe({
    get linkData() {
      return t();
    },
    set linkData(p) {
      t(p), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(p) {
      i(p), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(p) {
      r(p), ee();
    }
  });
}
Ot(["change", "click"]);
ve(Dd, { linkData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const y0 = (n, e = {}) => () => {
  if (!n)
    return;
  let t;
  if (n.isActive("link")) {
    n.chain().extendMarkRange("link").run();
    const r = n.state.doc.textBetween(
      n.state.selection.from,
      n.state.selection.to
    ), s = n.getAttributes("link");
    t = {
      url: s.href || "",
      text: r,
      title: s.title || "",
      target: s.target || e.defaultTarget || "_self"
    };
  } else
    t = {
      url: "",
      text: n.state.selection.empty ? "" : n.state.doc.textBetween(n.state.selection.from, n.state.selection.to),
      title: "",
      target: e.defaultTarget || "_self"
    };
  const i = Nt(Dd, {
    target: document.body,
    props: {
      linkData: t,
      onSubmit: (r) => {
        const s = n.chain().focus();
        n.isActive("link") && s.extendMarkRange("link"), s.deleteSelection().insertContent({
          type: "text",
          text: r.text,
          marks: [
            {
              type: "link",
              attrs: {
                href: r.url,
                target: r.target,
                title: r.title
              }
            }
          ]
        }).run();
      },
      onClose: () => {
        at(i);
      }
    }
  });
}, oA = (n) => class extends tn(n) {
  onEditorUpdate() {
    var e;
    this.classList.toggle("is-active", (e = this.tiptap) == null ? void 0 : e.isActive("link"));
  }
};
var aA = Z("<button><!></button>");
function x0(n, e) {
  ye(e, !0);
  const t = e.$$host, { editor: i, options: r, tiptap: s } = t, o = y0(s, r);
  t.addEventListener("click", o);
  let a;
  $e(() => {
    var u;
    return i && (a = new iA({ editor: i }), (u = i.tiptap) == null || u.commands.setInlineLinkShortcutHandler(o)), () => {
      a == null || a.destroy();
    };
  });
  var l = aA(), c = L(l);
  qt(c, () => QE), O(l), St(l, (u, d) => {
    var f;
    return (f = Tn) == null ? void 0 : f(u, d);
  }, () => `${I("Link")} (${Rd("cmd+K")})`), F(n, l), xe();
}
ve(x0, {}, [], [], !0, oA);
const lA = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-external-link">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6" />
    <path d="M11 13l9 -9" />
    <path d="M15 4h5v5" />
</svg>
`, cA = (n) => class extends tn(n) {
};
var uA = Z('<a target="_blank" class="svelte-23fhoy"><span class="svelte-23fhoy"> </span> <!></a>');
const dA = {
  hash: "svelte-23fhoy",
  code: "a.svelte-23fhoy {display:flex;align-items:center;gap:4px;height:100%;padding:0 4px;}a.svelte-23fhoy:hover {background-color:#dee0e2;}a.svelte-23fhoy span:where(.svelte-23fhoy) {max-width:300px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}a.svelte-23fhoy svg {width:16px;height:16px;}"
};
function w0(n, e) {
  ye(e, !0), Ht(n, dA);
  const t = e.$$host, { tiptap: i } = t;
  let r = ce("");
  t.onEditorUpdate = () => {
    q(r, i == null ? void 0 : i.getAttributes("link").href, !0);
  };
  var s = uA(), o = L(s), a = L(o, !0);
  O(o);
  var l = H(o, 2);
  qt(l, () => lA), O(s), ne(() => {
    Ae(s, "href", E(r)), Ae(s, "title", E(r)), B(a, E(r));
  }), F(n, s), xe();
}
ve(w0, {}, [], [], !0, cA);
const k0 = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-pencil">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
    <path d="M13.5 6.5l4 4" />
</svg>
`, fA = (n) => class extends tn(n) {
};
var hA = Z("<button><!></button>");
function S0(n, e) {
  ye(e, !0);
  const t = e.$$host, { tiptap: i } = t;
  t.addEventListener("click", y0(i));
  var r = hA(), s = L(r);
  qt(s, () => k0), O(r), St(r, (o, a) => {
    var l;
    return (l = Tn) == null ? void 0 : l(o, a);
  }, () => I("Edit Link")), F(n, r), xe();
}
ve(S0, {}, [], [], !0, fA);
const pA = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_27)">
        <path d="M56.75 24.88H51.56V15.99C51.56 13.53 49.57 11.54 47.11 11.54H24.87C22.41 11.54 20.42 13.53 20.42 15.99V24.88H15.23C12.77 24.88 10.78 26.87 10.78 29.33V56.01C10.78 58.47 12.77 60.46 15.23 60.46H56.74C59.2 60.46 61.19 58.47 61.19 56.01V29.33C61.19 26.87 59.2 24.88 56.74 24.88H56.75ZM24.88 15.99H47.12V24.88H24.88V15.99Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_27">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`;
var mA = Z("<button><!></button>");
function C0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", () => {
    var s, o;
    (o = (s = t.options).select) == null || o.call(s, { editor: t.editor });
  });
  var i = mA(), r = L(i);
  qt(r, () => pA), O(i), St(i, (s, o) => {
    var a;
    return (a = Tn) == null ? void 0 : a(s, o);
  }, () => I("Insert File")), F(n, i), xe();
}
ve(C0, {}, [], [], !0, tn);
const gA = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_21)">
        <path d="M58.5 18.9V53.1H13.5V18.9H58.5ZM58.5 11.7H13.5C9.52005 11.7 6.30005 14.92 6.30005 18.9V53.1C6.30005 57.08 9.52005 60.3 13.5 60.3H58.5C62.48 60.3 65.7 57.08 65.7 53.1V18.9C65.7 14.92 62.48 11.7 58.5 11.7Z" fill="black"/>
        <path d="M50.4 35.1C53.3823 35.1 55.8 32.6823 55.8 29.7C55.8 26.7177 53.3823 24.3 50.4 24.3C47.4177 24.3 45 26.7177 45 29.7C45 32.6823 47.4177 35.1 50.4 35.1Z" fill="#231F20"/>
        <path d="M56.7 54H50.53L50.44 53.73H50.45L37.54 29.69C37.26 29.07 36.66 28.63 35.97 28.63C35.28 28.63 34.65 29.09 34.37 29.74L25.78 45.73L23.68 41.82C23.53 41.49 23.22 41.26 22.85 41.26C22.48 41.26 22.15 41.5 22.01 41.85L13.51 54.02C13.51 56.99 15.92 59.4 18.9 59.4H56.73C59.71 59.4 62.12 56.99 62.12 54.02L56.72 54H56.7Z" fill="#231F20"/>
    </g>
    <defs>
        <clipPath id="clip0_57_21">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`;
function T0(n, e) {
  var s, o;
  ye(e, !0);
  const t = Q(e, "editor", 7), i = t().tiptap, r = (o = (s = t().options.toolbarOptions) == null ? void 0 : s.image) != null && o.edit ? [["deleteImage"], ["editImage"]] : [["deleteImage"]];
  return Pd(n, {
    get editor() {
      return t();
    },
    targetNodeName: "image",
    targetNodeTagName: "IMG",
    condition: () => !(i.isActive("link") && !i.isActive("link", { class: "mt-asset-link" })) && i.isActive("image"),
    items: r
  }), xe({
    get editor() {
      return t();
    },
    set editor(a) {
      t(a), ee();
    }
  });
}
ve(T0, { editor: {} }, [], [], !0);
var Sr;
class _A {
  constructor({
    editor: e,
    edit: t
  }) {
    Le(this, Sr);
    Oe(this, Sr, Nt(T0, {
      target: e.tiptap.view.dom.getRootNode(),
      props: {
        editor: e,
        edit: t
      }
    }));
  }
  destroy() {
    G(this, Sr) && at(G(this, Sr));
  }
}
Sr = new WeakMap();
var bA = Z("<button><!></button>");
function E0(n, e) {
  ye(e, !0);
  const t = e.$$host, { editor: i, options: r } = t;
  t.addEventListener("click", () => {
    var l, c;
    (c = (l = t.options).select) == null || c.call(l, { editor: t.editor });
  });
  let s;
  $e(() => (i && (s = new _A({ editor: i, edit: r.edit })), () => {
    s == null || s.destroy();
  }));
  var o = bA(), a = L(o);
  qt(a, () => gA), O(o), St(o, (l, c) => {
    var u;
    return (u = Tn) == null ? void 0 : u(l, c);
  }, () => I("Insert Image")), F(n, o), xe();
}
ve(E0, {}, [], [], !0, tn);
const vA = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-trash">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 7l16 0" />
    <path d="M10 11l0 6" />
    <path d="M14 11l0 6" />
    <path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" />
    <path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" />
</svg>
`, yA = (n) => class extends tn(n) {
};
var xA = Z("<button><!></button>");
function A0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", () => {
    var s;
    (s = t.tiptap) == null || s.chain().focus().deleteSelection().run();
  });
  var i = xA(), r = L(i);
  qt(r, () => vA), O(i), St(i, (s, o) => {
    var a;
    return (a = Tn) == null ? void 0 : a(s, o);
  }, () => I("Delete Image")), F(n, i), xe();
}
ve(A0, {}, [], [], !0, yA);
const wA = (n) => class extends tn(n) {
};
var kA = Z("<button><!></button>");
function M0(n, e) {
  ye(e, !0);
  const t = e.$$host, { editor: i, tiptap: r } = t;
  function s() {
    var u;
    if (!r)
      return null;
    const { selection: l } = r.state, c = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ((u = l.node) == null ? void 0 : u.type.name) === "image" ? l.$anchor : Zi((d) => d.type.name === "image")(l)
    );
    return c ? r.view.nodeDOM(c.pos) : null;
  }
  t.addEventListener("click", () => {
    var c, u, d;
    const l = s();
    l && ((d = (u = (c = i == null ? void 0 : i.options.toolbarOptions) == null ? void 0 : c.image) == null ? void 0 : u.edit) == null || d.call(u, { editor: i, element: l }));
  });
  var o = kA(), a = L(o);
  qt(a, () => k0), O(o), St(o, (l, c) => {
    var u;
    return (u = Tn) == null ? void 0 : u(l, c);
  }, () => I("Edit Image")), F(n, o), xe();
}
ve(M0, {}, [], [], !0, wA);
const SA = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_229)">
        <path d="M64.05 22.55C63.27 21.44 62 20.78 60.65 20.78H56.32L54.81 24.93H60.65L50.08 53.98H16.8799L18.6399 49.14H14.22L12.97 52.56C12.51 53.83 12.69 55.25 13.47 56.36C14.25 57.47 15.52 58.13 16.87 58.13H50.07C51.81 58.13 53.37 57.04 53.97 55.4L64.54 26.35C65 25.08 64.82 23.66 64.04 22.55H64.05Z" fill="black"/>
        <path d="M55.1201 18.02L44.5501 47.07H11.3501L21.9201 18.02H55.1201ZM55.1201 13.87H21.9201C20.1801 13.87 18.6201 14.96 18.0201 16.6L7.45005 45.65C6.99005 46.92 7.17005 48.34 7.95005 49.45C8.73005 50.56 10.0001 51.22 11.3501 51.22H44.5501C46.2901 51.22 47.8501 50.13 48.4501 48.49L59.0201 19.44C59.4801 18.17 59.3001 16.75 58.5201 15.64C57.7401 14.53 56.4701 13.87 55.1201 13.87Z" fill="black"/>
        <path d="M43.86 23.55L39.71 35.31H21.23L25.38 23.55H43.86ZM43.86 20.79H25.38C24.21 20.79 23.16 21.53 22.77 22.63L18.62 34.39C18.32 35.24 18.45 36.18 18.97 36.91C19.49 37.64 20.33 38.08 21.23 38.08H39.71C40.88 38.08 41.93 37.34 42.32 36.24L46.47 24.48C46.77 23.63 46.64 22.69 46.12 21.96C45.6 21.23 44.76 20.79 43.86 20.79Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_229">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`, CA = (n) => class extends tn(n) {
  onEditorUpdate() {
    var e;
    this.classList.toggle("is-active", (e = this.editor) == null ? void 0 : e.getStructureMode());
  }
};
var TA = Z("<button><!></button>");
function O0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", () => {
    const s = t.editor;
    s && (s.setStructureMode(!s.getStructureMode()), t.onEditorUpdate());
  });
  var i = TA(), r = L(i);
  qt(r, () => SA), O(i), St(i, (s, o) => {
    var a;
    return (a = Tn) == null ? void 0 : a(s, o);
  }, () => I("Toggle to HTML structure editing mode")), F(n, i), xe();
}
ve(O0, {}, [], [], !0, CA);
const EA = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_206)">
        <path d="M58.4 8.80005H13.6C10.07 8.80005 7.20001 11.67 7.20001 15.2V56.8C7.20001 60.33 10.07 63.2001 13.6 63.2001H58.4C61.93 63.2001 64.8 60.33 64.8 56.8V15.2C64.8 11.67 61.93 8.80005 58.4 8.80005ZM58.4 24.8V37.6H39.2V24.8H58.4ZM32.8 24.8V37.6H13.6V24.8H32.8ZM13.6 56.8V44H32.8V56.8H13.6ZM39.2 56.8V44H58.4V56.8H39.2Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_206">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`;
function AA(n, e) {
  n.key === "Enter" && e(n);
}
var MA = Z('<div role="button" tabindex="0"></div>'), OA = Z('<div class="grid_row svelte-zhz6om"></div>'), NA = Z('<div class="table_insert_panel svelte-zhz6om"><div class="grid_container svelte-zhz6om"></div> <div class="size_indicator svelte-zhz6om"><!></div></div>');
const LA = {
  hash: "svelte-zhz6om",
  code: ".table_insert_panel.svelte-zhz6om {position:absolute;top:0;left:0;background:white;border:1px solid #ccc;border-radius:4px;padding:8px 8px 0 8px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);}.size_indicator.svelte-zhz6om {text-align:center;margin:4px 0;height:20px;font-size:12px;}.grid_container.svelte-zhz6om {display:flex;flex-direction:column;gap:2px;}.grid_row.svelte-zhz6om {display:flex;gap:2px;}.grid_cell.svelte-zhz6om {width:12px;height:12px;border:1px solid #ddd;background:#fff;cursor:pointer;}.grid_cell.selected.svelte-zhz6om {background:#0066cc;border-color:#0066cc;}"
};
function N0(n, e) {
  ye(e, !0), Ht(n, LA);
  const t = Q(e, "onInsert", 7);
  let i = ce(0), r = ce(0);
  const s = 20, o = 20, a = 10, l = 10, c = ta(() => Math.min(s, Math.max(a, E(i) + 1))), u = ta(() => Math.min(o, Math.max(l, E(r) + 1)));
  function d(v, x) {
    q(i, v + 1), q(r, x + 1);
  }
  function f(v) {
    v.stopPropagation(), E(i) && E(r) && t()(E(i), E(r));
  }
  var h = NA(), p = L(h);
  ft(p, 21, () => Array(E(c)), kn, (v, x, w) => {
    var S = OA();
    ft(S, 21, () => Array(E(u)), kn, (k, C, y, A) => {
      var _ = MA();
      let T;
      _.__click = f, _.__keydown = [AA, f], _.__mouseover = () => d(w, y), ne((M) => T = pt(_, 1, "grid_cell svelte-zhz6om", null, T, M), [
        () => ({
          selected: w < E(i) && y < E(r)
        })
      ]), dt("focus", _, () => d(w, y)), F(k, _);
    }), O(S), F(v, S);
  }), O(p);
  var b = H(p, 2), m = L(b);
  {
    var g = (v) => {
      var x = Cn();
      ne(() => B(x, `${E(i) ?? ""} x ${E(r) ?? ""}`)), F(v, x);
    };
    st(m, (v) => {
      E(i) && E(r) && v(g);
    });
  }
  return O(b), O(h), F(n, h), xe({
    get onInsert() {
      return t();
    },
    set onInsert(v) {
      t(v), ee();
    }
  });
}
Ot(["click", "keydown", "mouseover"]);
ve(N0, { onInsert: {} }, [], [], !0);
var RA = Z('<div class="form-group mb-3"><label for="link-url" class="form-label"> </label> <input type="text" id="table-width" class="form-control"></div> <div class="form-group mb-3"><label for="table-height" class="form-label"> </label> <input type="text" id="table-height" class="form-control"></div> <div class="form-group mb-3"><label for="table-cell-spacing" class="form-label"> </label> <input type="text" id="table-cell-spacing" class="form-control"></div> <div class="form-group mb-3"><label for="table-border-width" class="form-label"> </label> <input type="text" id="table-border-width" class="form-control"></div>', 1), IA = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function L0(n, e) {
  ye(e, !0);
  let t = Q(e, "tableData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().width)), o = ce(Fe(t().height)), a = ce(Fe(t().cellSpacing)), l = ce(Fe(t().borderWidth)), c;
  $e(() => {
    c == null || c.focus();
  });
  let u, d;
  return et(
    An(n, {
      $$events: {
        close(...f) {
          var h;
          (h = r()) == null || h.apply(this, f);
        }
      },
      children: (f, h) => {
        Mn(f, {
          get close() {
            return d;
          },
          set close(p) {
            d = p;
          },
          $$slots: {
            title: (p, b) => {
              var m = Cn();
              ne((g) => B(m, g), [() => I("Table Properties")]), F(p, m);
            },
            body: (p, b) => {
              var m = RA(), g = Re(m), v = L(g), x = L(v, !0);
              O(v);
              var w = H(v, 2);
              ht(w), et(w, (J) => c = J, () => c), O(g);
              var S = H(g, 2), k = L(S), C = L(k, !0);
              O(k);
              var y = H(k, 2);
              ht(y), O(S);
              var A = H(S, 2), _ = L(A), T = L(_, !0);
              O(_);
              var M = H(_, 2);
              ht(M), O(A);
              var z = H(A, 2), P = L(z), V = L(P, !0);
              O(P);
              var U = H(P, 2);
              ht(U), O(z), ne(
                (J, re, te, ge) => {
                  B(x, J), B(C, re), B(T, te), B(V, ge);
                },
                [
                  () => I("Width"),
                  () => I("Height"),
                  () => I("Cell Spacing"),
                  () => I("Border Width")
                ]
              ), kt(w, () => E(s), (J) => q(s, J)), kt(y, () => E(o), (J) => q(o, J)), kt(M, () => E(a), (J) => q(a, J)), kt(U, () => E(l), (J) => q(l, J)), F(p, m);
            },
            footer: (p, b) => {
              var m = IA(), g = Re(m);
              g.__click = () => {
                i()({
                  width: E(s),
                  height: E(o),
                  cellSpacing: E(a),
                  borderWidth: E(l)
                }), d();
              };
              var v = L(g, !0);
              O(g);
              var x = H(g, 2);
              x.__click = d;
              var w = L(x, !0);
              O(x), ne(
                (S, k, C, y) => {
                  Ae(g, "title", S), B(v, k), Ae(x, "title", C), B(w, y);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(p, m);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (f) => u = f,
    () => u
  ), xe({
    get tableData() {
      return t();
    },
    set tableData(f) {
      t(f), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(f) {
      i(f), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(f) {
      r(f), ee();
    }
  });
}
Ot(["click"]);
ve(L0, { tableData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const PA = (n) => {
  const { state: e } = n;
  let t = e.selection.$anchor.depth, i = null;
  for (; t > 0; ) {
    const s = e.selection.$anchor.node(t);
    if (s.type.name === "table") {
      i = s;
      break;
    }
    t--;
  }
  const r = document.createElement("div");
  return r.style.cssText = (i == null ? void 0 : i.attrs.style) || "", {
    width: r.style.width || "100%",
    height: r.style.height || "",
    cellSpacing: r.style.borderSpacing || "",
    borderWidth: r.style.borderWidth || ""
  };
}, DA = (n) => {
  const { state: e } = n;
  let t = e.selection.$anchor.depth;
  for (; t > 0; ) {
    if (e.selection.$anchor.node(t).type.name === "table")
      return e.selection.$anchor.before(t);
    t--;
  }
  return null;
};
let Ap;
const $A = (n) => {
  Nt(L0, {
    target: document.body,
    props: {
      tableData: PA(n),
      onSubmit: (e) => {
        const t = DA(n);
        t !== null && (n == null || n.chain().focus().command(({ tr: i }) => {
          const r = i.doc.nodeAt(t);
          if (r) {
            const s = document.createElement("div");
            s.style.cssText = r.attrs.style || "", s.style.width = e.width, s.style.height = e.height, s.style.borderSpacing = e.cellSpacing, s.style.borderWidth = e.borderWidth, i.setNodeMarkup(t, null, {
              ...r.attrs,
              style: s.style.cssText
            });
            const o = pn(n.state);
            o && o.map.map.forEach((a) => {
              const l = o.table.nodeAt(a);
              if (l) {
                const c = document.createElement("div");
                c.style.cssText = l.attrs.style || "", c.style.borderWidth = e.borderWidth, i.setNodeMarkup(o.tableStart + a, null, {
                  ...l.attrs,
                  style: c.style.cssText
                });
              }
            });
          }
          return !0;
        }).run()), at(Ap);
      },
      onClose: () => {
        at(Ap);
      }
    }
  });
};
var BA = Z('<div class="form-group mb-3"><label for="width" class="form-label"> </label> <input type="text" id="width" class="form-control"></div> <div class="form-group mb-3"><label for="width" class="form-label"> </label> <input type="text" id="height" class="form-control"></div> <div class="form-group mb-3"><label for="element" class="form-label"> </label> <select id="element" class="form-control"><option> </option><option> </option></select></div> <div class="form-group mb-3"><label for="scope" class="form-label"> </label> <select id="scope" class="form-control"><option> </option><option> </option><option> </option><option> </option><option> </option></select></div> <div class="form-group mb-3"><label for="horizontalAlign" class="form-label"> </label> <select id="horizontalAlign" class="form-control"><option> </option><option> </option><option> </option><option> </option><option> </option></select></div> <div class="form-group mb-3"><label for="verticalAlign" class="form-label"> </label> <select id="verticalAlign" class="form-control"><option> </option><option> </option><option> </option><option> </option></select></div>', 1), zA = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function R0(n, e) {
  ye(e, !0);
  let t = Q(e, "cellData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().width)), o = ce(Fe(t().height)), a = ce(Fe(t().element)), l = ce(Fe(t().scope)), c = ce(Fe(t().horizontalAlign)), u = ce(Fe(t().verticalAlign)), d;
  $e(() => {
    d == null || d.focus();
  });
  let f, h;
  return et(
    An(n, {
      $$events: {
        close(...p) {
          var b;
          (b = r()) == null || b.apply(this, p);
        }
      },
      children: (p, b) => {
        Mn(p, {
          get close() {
            return h;
          },
          set close(m) {
            h = m;
          },
          $$slots: {
            title: (m, g) => {
              var v = Cn();
              ne((x) => B(v, x), [() => I("Cell Properties")]), F(m, v);
            },
            body: (m, g) => {
              var v = BA(), x = Re(v), w = L(x), S = L(w, !0);
              O(w);
              var k = H(w, 2);
              ht(k), et(k, (it) => d = it, () => d), O(x);
              var C = H(x, 2), y = L(C), A = L(y, !0);
              O(y);
              var _ = H(y, 2);
              ht(_), O(C);
              var T = H(C, 2), M = L(T), z = L(M, !0);
              O(M);
              var P = H(M, 2), V = L(P);
              V.value = (V.__value = "td") == null ? "" : "td";
              var U = L(V, !0);
              O(V);
              var J = H(V);
              J.value = (J.__value = "th") == null ? "" : "th";
              var re = L(J, !0);
              O(J), O(P), O(T);
              var te = H(T, 2), ge = L(te), se = L(ge, !0);
              O(ge);
              var Be = H(ge, 2), fe = L(Be);
              fe.value = ((fe.__value = "") == null, "");
              var Je = L(fe, !0);
              O(fe);
              var we = H(fe);
              we.value = (we.__value = "row") == null ? "" : "row";
              var R = L(we, !0);
              O(we);
              var tt = H(we);
              tt.value = (tt.__value = "col") == null ? "" : "col";
              var he = L(tt, !0);
              O(tt);
              var ct = H(tt);
              ct.value = (ct.__value = "rowgroup") == null ? "" : "rowgroup";
              var Ne = L(ct, !0);
              O(ct);
              var X = H(ct);
              X.value = (X.__value = "colgroup") == null ? "" : "colgroup";
              var Ee = L(X, !0);
              O(X), O(Be), O(te);
              var me = H(te, 2), D = L(me), de = L(D, !0);
              O(D);
              var be = H(D, 2), j = L(be);
              j.value = ((j.__value = "") == null, "");
              var Ft = L(j, !0);
              O(j);
              var ut = H(j);
              ut.value = (ut.__value = "left") == null ? "" : "left";
              var nn = L(ut, !0);
              O(ut);
              var rn = H(ut);
              rn.value = (rn.__value = "center") == null ? "" : "center";
              var er = L(rn, !0);
              O(rn);
              var sn = H(rn);
              sn.value = (sn.__value = "right") == null ? "" : "right";
              var Vn = L(sn, !0);
              O(sn);
              var He = H(sn);
              He.value = (He.__value = "justify") == null ? "" : "justify";
              var Ue = L(He, !0);
              O(He), O(be), O(me);
              var Pe = H(me, 2), Se = L(Pe), Ct = L(Se, !0);
              O(Se);
              var Ti = H(Se, 2), ni = L(Ti);
              ni.value = ((ni.__value = "") == null, "");
              var tr = L(ni, !0);
              O(ni);
              var On = H(ni);
              On.value = (On.__value = "top") == null ? "" : "top";
              var mn = L(On, !0);
              O(On);
              var on = H(On);
              on.value = (on.__value = "middle") == null ? "" : "middle";
              var Xr = L(on, !0);
              O(on);
              var ii = H(on);
              ii.value = (ii.__value = "bottom") == null ? "" : "bottom";
              var Sl = L(ii, !0);
              O(ii), O(Ti), O(Pe), ne(
                (it, nr, Cl, Ei, Tl, El, rt, ri, Al, uo, Yr, fo, ho, Ml, an, ir, po, mo, Zr, go, gn, _o) => {
                  B(S, it), B(A, nr), B(z, Cl), B(U, Ei), B(re, Tl), B(se, El), B(Je, rt), B(R, ri), B(he, Al), B(Ne, uo), B(Ee, Yr), B(de, fo), B(Ft, ho), B(nn, Ml), B(er, an), B(Vn, ir), B(Ue, po), B(Ct, mo), B(tr, Zr), B(mn, go), B(Xr, gn), B(Sl, _o);
                },
                [
                  () => I("Width"),
                  () => I("Height"),
                  () => I("Cell type"),
                  () => I("Cell"),
                  () => I("Header cell"),
                  () => I("Scope"),
                  () => I("None"),
                  () => I("Row"),
                  () => I("Column"),
                  () => I("Row group"),
                  () => I("Column group"),
                  () => I("Horizontal align"),
                  () => I("None"),
                  () => I("HORIZONTAL_ALIGN_LEFT"),
                  () => I("HORIZONTAL_ALIGN_CENTER"),
                  () => I("HORIZONTAL_ALIGN_RIGHT"),
                  () => I("HORIZONTAL_ALIGN_JUSTIFY"),
                  () => I("Vertical align"),
                  () => I("None"),
                  () => I("VERTICAL_ALIGN_TOP"),
                  () => I("VERTICAL_ALIGN_MIDDLE"),
                  () => I("VERTICAL_ALIGN_BOTTOM")
                ]
              ), kt(k, () => E(s), (it) => q(s, it)), kt(_, () => E(o), (it) => q(o, it)), mr(P, () => E(a), (it) => q(a, it)), mr(Be, () => E(l), (it) => q(l, it)), mr(be, () => E(c), (it) => q(c, it)), mr(Ti, () => E(u), (it) => q(u, it)), F(m, v);
            },
            footer: (m, g) => {
              var v = zA(), x = Re(v);
              x.__click = () => {
                i()({
                  width: E(s),
                  height: E(o),
                  element: E(a),
                  scope: E(l),
                  horizontalAlign: E(c),
                  verticalAlign: E(u)
                }), h();
              };
              var w = L(x, !0);
              O(x);
              var S = H(x, 2);
              S.__click = h;
              var k = L(S, !0);
              O(S), ne(
                (C, y, A, _) => {
                  Ae(x, "title", C), B(w, y), Ae(S, "title", A), B(k, _);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(m, v);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (p) => f = p,
    () => f
  ), xe({
    get cellData() {
      return t();
    },
    set cellData(p) {
      t(p), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(p) {
      i(p), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(p) {
      r(p), ee();
    }
  });
}
Ot(["click"]);
ve(R0, { cellData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const HA = (n) => {
  const { state: e } = n;
  let t = e.selection.$anchor.depth, i = null;
  for (; t > 0; ) {
    const s = e.selection.$anchor.node(t);
    if (s.type.name === "tableCell" || s.type.name === "tableHeader") {
      i = s;
      break;
    }
    t--;
  }
  const r = document.createElement("div");
  return r.style.cssText = (i == null ? void 0 : i.attrs.style) || "", {
    width: r.style.width || "",
    height: r.style.height || "",
    element: (i == null ? void 0 : i.type.name) === "tableCell" ? "td" : "th",
    scope: (i == null ? void 0 : i.attrs.scope) || "",
    horizontalAlign: r.style.textAlign || "",
    verticalAlign: r.style.verticalAlign || ""
  };
}, FA = (n) => {
  if (!n)
    return null;
  const { state: e } = n;
  let t = e.selection.$anchor.depth;
  for (; t > 0; ) {
    const i = e.selection.$anchor.node(t);
    if (i.type.name === "tableCell" || i.type.name === "tableHeader")
      return e.selection.$anchor.before(t);
    t--;
  }
  return null;
};
let Mp;
const VA = (n) => {
  Nt(R0, {
    target: document.body,
    props: {
      cellData: HA(n),
      onSubmit: (e) => {
        var i;
        const t = FA(n);
        if (t !== null) {
          const r = (i = n == null ? void 0 : n.state.selection) == null ? void 0 : i.$anchor.node();
          ((r == null ? void 0 : r.type.name) === "tableCell" && e.element === "th" || (r == null ? void 0 : r.type.name) === "tableHeader" && e.element === "td") && (n == null || n.chain().focus().toggleHeaderCell().run()), n == null || n.chain().focus().command(({ tr: s }) => {
            const o = s.doc.nodeAt(t);
            if (o) {
              const a = document.createElement("div");
              a.style.cssText = o.attrs.style || "", a.style.width = e.width, a.style.height = e.height, a.style.textAlign = e.horizontalAlign, a.style.verticalAlign = e.verticalAlign, s.setNodeMarkup(t, null, {
                ...o.attrs,
                scope: e.scope || void 0,
                style: a.style.cssText
              });
            }
            return !0;
          }).run();
        }
        at(Mp);
      },
      onClose: () => {
        at(Mp);
      }
    }
  });
};
var jA = Z('<div class="form-group mb-3"><label for="element" class="form-label"> </label> <select id="element" class="form-control"><option> </option><option> </option></select></div>'), WA = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function UA(n, e) {
  ye(e, !0);
  let t = Q(e, "rowData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().element)), o;
  $e(() => {
    o == null || o.focus();
  });
  let a, l;
  return et(
    An(n, {
      $$events: {
        close(...c) {
          var u;
          (u = r()) == null || u.apply(this, c);
        }
      },
      children: (c, u) => {
        Mn(c, {
          get close() {
            return l;
          },
          set close(d) {
            l = d;
          },
          $$slots: {
            title: (d, f) => {
              var h = Cn();
              ne((p) => B(h, p), [() => I("Row Properties")]), F(d, h);
            },
            body: (d, f) => {
              var h = jA(), p = L(h), b = L(p, !0);
              O(p);
              var m = H(p, 2), g = L(m);
              g.value = (g.__value = "tbody") == null ? "" : "tbody";
              var v = L(g, !0);
              O(g);
              var x = H(g);
              x.value = (x.__value = "thead") == null ? "" : "thead";
              var w = L(x, !0);
              O(x), O(m), et(m, (S) => o = S, () => o), O(h), ne(
                (S, k, C) => {
                  B(b, S), B(v, k), B(w, C);
                },
                [
                  () => I("Row type"),
                  () => I("Row"),
                  () => I("Header row")
                ]
              ), mr(m, () => E(s), (S) => q(s, S)), F(d, h);
            },
            footer: (d, f) => {
              var h = WA(), p = Re(h);
              p.__click = () => {
                i()({ element: E(s) }), l();
              };
              var b = L(p, !0);
              O(p);
              var m = H(p, 2);
              m.__click = l;
              var g = L(m, !0);
              O(m), ne(
                (v, x, w, S) => {
                  Ae(p, "title", v), B(b, x), Ae(m, "title", w), B(g, S);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(d, h);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (c) => a = c,
    () => a
  ), xe({
    get rowData() {
      return t();
    },
    set rowData(c) {
      t(c), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(c) {
      i(c), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(c) {
      r(c), ee();
    }
  });
}
Ot(["click"]);
ve(UA, { rowData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
var KA = Z('<div class="button-menu-item-subgroup svelte-woewg3"><!></div>'), qA = (n, e) => {
  e == null || e.chain().focus().mergeCells().run();
}, GA = (n, e) => {
  e == null || e.chain().focus().splitCell().run();
}, JA = (n, e) => {
  VA(e);
}, XA = Z('<div class="button-menu-item-subgroup svelte-woewg3"><button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button></div>'), YA = (n, e) => {
  e == null || e.chain().focus().addRowBefore().run();
}, ZA = (n, e) => {
  e == null || e.chain().focus().addRowAfter().run();
}, QA = (n, e) => {
  e == null || e.chain().focus().deleteRow().run();
}, eM = Z('<div class="button-menu-item-subgroup svelte-woewg3"><button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button> <!></div>'), tM = (n, e) => {
  e == null || e.chain().focus().addColumnBefore().run();
}, nM = (n, e) => {
  e == null || e.chain().focus().addColumnAfter().run();
}, iM = (n, e) => {
  e == null || e.chain().focus().deleteColumn().run();
}, rM = Z('<div class="button-menu-item-subgroup svelte-woewg3"><button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button></div>'), sM = (n, e) => {
  $A(e);
}, oM = (n, e) => {
  e == null || e.chain().focus().deleteTable().run();
}, aM = Z('<div class="button-menu svelte-woewg3"><div class="button-menu-item-group button-menu-item-group--insert svelte-woewg3" role="menuitem" tabindex="0"><div class="button-menu-item-group-label svelte-woewg3"> </div> <!></div> <div class="button-menu-item-group svelte-woewg3" role="menuitem" tabindex="0"><div class="button-menu-item-group-label svelte-woewg3"> </div> <!></div> <div class="button-menu-item-group svelte-woewg3" role="menuitem" tabindex="0"><div class="button-menu-item-group-label svelte-woewg3"> </div> <!></div> <div class="button-menu-item-group svelte-woewg3" role="menuitem" tabindex="0"><div class="button-menu-item-group-label svelte-woewg3"> </div> <!></div> <div class="button-menu-item-group svelte-woewg3"><button class="button-menu-item svelte-woewg3"> </button> <button class="button-menu-item svelte-woewg3"> </button></div></div>'), lM = Z('<button><!></button> <div class="button-menu-container svelte-woewg3"><!></div>', 1);
const cM = {
  hash: "svelte-woewg3",
  code: '.button-menu-container.svelte-woewg3 {position:relative;z-index:3;}.button-menu.svelte-woewg3 {position:absolute;left:0;top:0;display:flex;flex-direction:column;border-radius:4px;box-shadow:0 0 0 1px #ccc;background:white;}.button-menu-item-group.svelte-woewg3 {position:relative;background:white;&:first-child {border-top-left-radius:4px;border-top-right-radius:4px;}&:hover .button-menu-item-group-label:where(.svelte-woewg3) {background:#dee0e2;}}.button-menu-item-group--insert.svelte-woewg3 {border-bottom:1px solid #ccc;}.button-menu-item-group-label.svelte-woewg3 {font-size:0.85rem;padding:5px 10px;display:flex;align-items:center;justify-content:space-between;&:after {content:">";font-weight:bold;font-size:0.85rem;}}.button-menu-item-subgroup.svelte-woewg3 {position:absolute;left:calc(100% + 1px);top:0;border-radius:4px;.button-menu-item:where(.svelte-woewg3):first-child {border-top-left-radius:4px;border-top-right-radius:4px;}}.button-menu-item.svelte-woewg3 {font-size:0.85rem;border:none;margin:0;display:flex;align-items:center;justify-content:flex-start;padding:5px 10px;width:100%;background:white;box-shadow:0 0 0 1px #ccc;white-space:nowrap;&:last-child {border-bottom-left-radius:4px;border-bottom-right-radius:4px;}&:hover {background:#dee0e2;}}'
};
function I0(n, e) {
  ye(e, !0), Ht(n, cM);
  const t = e.$$host, { tiptap: i } = t;
  t.addEventListener("click", u);
  let r = ce(!1), s = ce(Fe(i == null ? void 0 : i.isActive("table"))), o = ce(!1), a = ce(!1);
  const l = () => {
    if (!i)
      return;
    q(s, i.isActive("table"), !0);
    const x = E(s) ? pn(i.state) : null;
    if (x) {
      const w = /* @__PURE__ */ new Set();
      let S = !1;
      const k = x.map;
      e: for (let C = x.top; C < x.bottom; C++)
        for (let y = x.left; y < x.right; y++) {
          const A = k.map[C * k.width + y], _ = x.table.nodeAt(A);
          if (_ && (w.add(_), S = _.attrs.colspan > 1 || _.attrs.rowspan > 1, S && w.size > 1))
            break e;
        }
      q(a, S, !0), q(o, w.size > 1);
    }
  };
  i == null || i.on("update", l), i == null || i.on("selectionUpdate", l);
  function c(x, w) {
    i == null || i.chain().focus().insertTable({ rows: x, cols: w, withHeaderRow: !1 }).run(), q(r, !1);
  }
  function u(x) {
    i && (x.stopPropagation(), q(r, !E(r)));
  }
  function d() {
    q(r, !1);
  }
  $e(() => (document.addEventListener("click", d), () => {
    document.removeEventListener("click", d);
  }));
  let f = ce(Fe({}));
  $e(() => {
    E(r) || q(f, {}, !0);
  });
  var h = lM(), p = Re(h), b = L(p);
  qt(b, () => EA), O(p), St(p, (x, w) => {
    var S;
    return (S = Tn) == null ? void 0 : S(x, w);
  }, () => I("Table"));
  var m = H(p, 2), g = L(m);
  {
    var v = (x) => {
      var w = aM(), S = L(w), k = L(S), C = L(k, !0);
      O(k);
      var y = H(k, 2);
      {
        var A = (Ne) => {
          var X = KA(), Ee = L(X);
          N0(Ee, { onInsert: c }), O(X), F(Ne, X);
        };
        st(y, (Ne) => {
          E(f).insert && Ne(A);
        });
      }
      O(S);
      var _ = H(S, 2), T = L(_), M = L(T, !0);
      O(T);
      var z = H(T, 2);
      {
        var P = (Ne) => {
          var X = XA(), Ee = L(X);
          Ee.__click = [qA, i];
          var me = L(Ee, !0);
          O(Ee);
          var D = H(Ee, 2);
          D.__click = [GA, i];
          var de = L(D, !0);
          O(D);
          var be = H(D, 2);
          be.__click = [JA, i];
          var j = L(be, !0);
          O(be), O(X), ne(
            (Ft, ut, nn) => {
              Ee.disabled = !(E(s) && E(o)), B(me, Ft), D.disabled = !(E(s) && E(a)), B(de, ut), be.disabled = !E(s), B(j, nn);
            },
            [
              () => I("Merge cells"),
              () => I("Split cell"),
              () => I("Cell properties")
            ]
          ), F(Ne, X);
        };
        st(z, (Ne) => {
          E(f).cell && Ne(P);
        });
      }
      O(_);
      var V = H(_, 2), U = L(V), J = L(U, !0);
      O(U);
      var re = H(U, 2);
      {
        var te = (Ne) => {
          var X = eM(), Ee = L(X);
          Ee.__click = [YA, i];
          var me = L(Ee, !0);
          O(Ee);
          var D = H(Ee, 2);
          D.__click = [ZA, i];
          var de = L(D, !0);
          O(D);
          var be = H(D, 2);
          be.__click = [QA, i];
          var j = L(be, !0);
          O(be);
          var Ft = H(be, 2);
          st(Ft, (ut) => {
          }), O(X), ne(
            (ut, nn, rn) => {
              Ee.disabled = !E(s), B(me, ut), D.disabled = !E(s), B(de, nn), be.disabled = !E(s), B(j, rn);
            },
            [
              () => I("Insert row before"),
              () => I("Insert row after"),
              () => I("Delete row")
            ]
          ), F(Ne, X);
        };
        st(re, (Ne) => {
          E(f).row && Ne(te);
        });
      }
      O(V);
      var ge = H(V, 2), se = L(ge), Be = L(se, !0);
      O(se);
      var fe = H(se, 2);
      {
        var Je = (Ne) => {
          var X = rM(), Ee = L(X);
          Ee.__click = [tM, i];
          var me = L(Ee, !0);
          O(Ee);
          var D = H(Ee, 2);
          D.__click = [nM, i];
          var de = L(D, !0);
          O(D);
          var be = H(D, 2);
          be.__click = [iM, i];
          var j = L(be, !0);
          O(be), O(X), ne(
            (Ft, ut, nn) => {
              Ee.disabled = !E(s), B(me, Ft), D.disabled = !E(s), B(de, ut), be.disabled = !E(s), B(j, nn);
            },
            [
              () => I("Insert column before"),
              () => I("Insert column after"),
              () => I("Delete column")
            ]
          ), F(Ne, X);
        };
        st(fe, (Ne) => {
          E(f).col && Ne(Je);
        });
      }
      O(ge);
      var we = H(ge, 2), R = L(we);
      R.__click = [sM, i];
      var tt = L(R, !0);
      O(R);
      var he = H(R, 2);
      he.__click = [oM, i];
      var ct = L(he, !0);
      O(he), O(we), O(w), ne(
        (Ne, X, Ee, me, D, de) => {
          B(C, Ne), B(M, X), B(J, Ee), B(Be, me), R.disabled = !E(s), B(tt, D), he.disabled = !E(s), B(ct, de);
        },
        [
          () => I("Insert table"),
          () => I("Cell"),
          () => I("Row"),
          () => I("Column"),
          () => I("Table properties"),
          () => I("Delete table")
        ]
      ), dt("mouseenter", S, () => E(f).insert = !0), dt("mouseleave", S, () => E(f).insert = !1), dt("mouseenter", _, () => E(f).cell = !0), dt("mouseleave", _, () => E(f).cell = !1), dt("mouseenter", V, () => E(f).row = !0), dt("mouseleave", V, () => E(f).row = !1), dt("mouseenter", ge, () => E(f).col = !0), dt("mouseleave", ge, () => E(f).col = !1), F(x, w);
    };
    st(g, (x) => {
      E(r) && x(v);
    });
  }
  O(m), F(n, h), xe();
}
Ot(["click"]);
ve(I0, {}, [], [], !0, tn);
function uM(n, e, t) {
  e && (n.stopPropagation(), q(t, !E(t)));
}
var dM = (n, e, t) => e(E(t).value), fM = Z("<button><div> </div></button>"), hM = Z('<div class="options svelte-osezha"></div>'), pM = Z('<div class="dropdown svelte-osezha"><button class="selected svelte-osezha"> <span class="arrow svelte-osezha"></span></button> <!></div>');
const mM = {
  hash: "svelte-osezha",
  code: ".dropdown.svelte-osezha {position:relative;width:150px;}.selected.svelte-osezha {width:100%;padding:4px 8px;border:1px solid #ccc;border-radius:4px;background-color:white;font-size:14px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;}.arrow.svelte-osezha {width:6px;height:6px;border-right:1px solid #666;border-bottom:1px solid #666;transform:rotate(45deg);margin-left:4px;position:relative;top:-2px;}.options.svelte-osezha {position:absolute;top:100%;left:0;right:0;background:white;border:1px solid #ccc;border-radius:4px;margin-top:4px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);z-index:1000;}.option.svelte-osezha {display:block;width:100%;text-align:left;border:none;background:white;padding:8px;cursor:pointer;}.option.svelte-osezha:hover {background-color:#f5f5f5;}.option.active.svelte-osezha {background-color:#e0e0e0;}.h1.svelte-osezha {font-size:1.8em;font-weight:bold;}.h2.svelte-osezha {font-size:1.5em;font-weight:bold;}.h3.svelte-osezha {font-size:1.3em;font-weight:bold;}.h4.svelte-osezha {font-size:1.2em;font-weight:bold;}.h5.svelte-osezha {font-size:1.1em;font-weight:bold;}.h6.svelte-osezha {font-size:1em;font-weight:bold;}.paragraph.svelte-osezha {font-size:1em;}.pre.svelte-osezha {font-family:monospace;}"
};
function P0(n, e) {
  ye(e, !0), Ht(n, mM);
  const t = [
    { value: "paragraph", label: I("Paragraph") },
    { value: "h1", label: I("Heading 1") },
    { value: "h2", label: I("Heading 2") },
    { value: "h3", label: I("Heading 3") },
    { value: "h4", label: I("Heading 4") },
    { value: "h5", label: I("Heading 5") },
    { value: "h6", label: I("Heading 6") },
    { value: "pre", label: I("Preformatted") }
  ], i = e.$$host, { options: r, tiptap: s } = i;
  let o = ce(!1);
  const l = (r.blocks ?? t).map((x) => typeof x == "string" ? t.find((w) => w.value === x) : x).filter((x) => x !== void 0);
  let c = ce(Fe(l[0].value));
  i.onEditorUpdate = () => {
    if (!s)
      return;
    const { $head: x } = s.state.selection, w = x.parent;
    w.type.name === "heading" ? q(c, `h${w.attrs.level}`) : q(c, w.type.name, !0), l.some((S) => S.value === E(c)) || q(c, l[0].value, !0);
  };
  function u(x) {
    if (x === "paragraph" || x === "pre")
      s == null || s.chain().focus().setNode(x).run();
    else if (x.match(/^h[1-6]$/)) {
      const w = parseInt(x.substring(1));
      s == null || s.chain().focus().setHeading({ level: w }).run();
    }
    q(c, x, !0), q(o, !1);
  }
  function d() {
    q(o, !1);
  }
  let f, h = ce(!1);
  $e(() => {
    if (!E(h))
      return q(h, !0), document.addEventListener("click", d), () => {
        document.removeEventListener("click", d);
      };
  });
  var p = pM(), b = L(p);
  b.__click = [uM, s, o];
  var m = L(b);
  Yp(), O(b);
  var g = H(b, 2);
  {
    var v = (x) => {
      var w = hM();
      ft(w, 21, () => l, (S) => S.value, (S, k) => {
        var C = fM();
        let y;
        C.__click = [dM, u, k];
        var A = L(C), _ = L(A, !0);
        O(A), O(C), ne(
          (T) => {
            y = pt(C, 1, "option svelte-osezha", null, y, T), pt(A, 1, i0(E(k).value), "svelte-osezha"), B(_, E(k).label);
          },
          [
            () => ({
              active: E(c) === E(k).value
            })
          ]
        ), F(S, C);
      }), O(w), F(x, w);
    };
    st(g, (x) => {
      E(o) && x(v);
    });
  }
  O(p), et(p, (x) => f = x, () => f), ne((x) => B(m, `${x ?? ""} `), [
    () => {
      var x;
      return (x = l.find((w) => w.value === E(c))) == null ? void 0 : x.label;
    }
  ]), F(n, p), xe();
}
Ot(["click"]);
ve(P0, {}, [], [], !0, tn);
const gM = `<svg width="24" height="24"
    xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" d="M10.384 11.53h3.18l-1.547-4.504h-.034l-1.599 4.504zM10.642 4h2.768L18 16.275h-2.802l-.929-2.733H9.68l-.963 2.733H6L10.642 4z" />
    <rect x="4" y="18" width="16" height="3" rx=".5" fill="currentColor"/>
</svg>
`;
var _M = (n, e, t) => {
  n.stopPropagation(), e()(t);
}, bM = (n, e, t) => e(n, t), vM = Z('<div class="color-item svelte-1bm8p55" role="button" tabindex="0"></div>'), yM = Z('<div class="color-panel svelte-1bm8p55"></div>');
const xM = {
  hash: "svelte-1bm8p55",
  code: ".color-panel.svelte-1bm8p55 {position:absolute;top:0;left:0;display:grid;grid-template-columns:repeat(6, 1fr);gap:4px;padding:8px;background:white;border:1px solid #ddd;border-radius:4px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);width:188px;z-index:1000;}.color-item.svelte-1bm8p55 {width:24px;height:24px;border-radius:4px;cursor:pointer;border:1px solid #ddd;}.color-item.svelte-1bm8p55:hover {transform:scale(1.1);transition:transform 0.2s;}"
};
function $d(n, e) {
  ye(e, !0), Ht(n, xM);
  const t = Q(e, "colors", 7), i = Q(e, "onSelect", 7);
  function r(o, a) {
    o.key === "Enter" && (o.stopPropagation(), i()(a));
  }
  var s = yM();
  return ft(s, 20, t, (o) => o, (o, a) => {
    var l = vM();
    l.__click = [_M, i, a], l.__keydown = [bM, r, a], ne(() => {
      qs(l, `background-color: ${a ?? ""}`), Ae(l, "aria-label", a);
    }), F(o, l);
  }), O(s), F(n, s), xe({
    get colors() {
      return t();
    },
    set colors(o) {
      t(o), ee();
    },
    get onSelect() {
      return i();
    },
    set onSelect(o) {
      i(o), ee();
    }
  });
}
Ot(["click", "keydown"]);
ve($d, { colors: {}, onSelect: {} }, [], [], !0);
var wM = Z('<button><!></button> <div class="color-panel-container svelte-gqoyg9"><!></div>', 1);
const kM = {
  hash: "svelte-gqoyg9",
  code: ".color-panel-container.svelte-gqoyg9 {position:relative;}"
};
function D0(n, e) {
  ye(e, !0), Ht(n, kM);
  const t = e.$$host;
  t.addEventListener("click", c);
  const { options: i, tiptap: r } = t;
  let s = ce(!1);
  const o = i.presetColors ?? [
    "#000000",
    "#002B76",
    "#1B4F2A",
    "#783F04",
    "#700000",
    "#351C75",
    "#6B6B6B",
    "#1155CC",
    "#38761D",
    "#B45F06",
    "#AC0000",
    "#674EA7",
    "#999999",
    "#4A86E8",
    "#6AA84F",
    "#E69138",
    "#DC3D3D",
    "#8E7CC3",
    "#D9D9D9",
    "#A4C2F4",
    "#B6D7A8",
    "#F9CB9C",
    "#EA9999",
    "#B4A7D6",
    "#F3F3F3",
    "#CFE2F3",
    "#D9EAD3",
    "#FFE6C4",
    "#F4CCCC",
    "#D9D2E9",
    "#FFFFFF",
    "#EAF1FB",
    "#EBF5EB",
    "#FFF8E1",
    "#FDEBEE",
    "#F2EFF9"
  ];
  let a = ce("#000000");
  t.onEditorUpdate = () => {
    q(a, (r == null ? void 0 : r.getAttributes("textStyle").color) ?? "#000000", !0);
  };
  function l(v) {
    q(a, v, !0), r == null || r.chain().focus().setColor(v).run(), q(s, !1);
  }
  function c(v) {
    r && (v.stopPropagation(), q(s, !E(s)));
  }
  function u() {
    q(s, !1);
  }
  $e(() => (document.addEventListener("click", u), () => {
    document.removeEventListener("click", u);
  }));
  var d = wM(), f = Re(d);
  let h;
  var p = L(f);
  qt(p, () => gM.replace(/fill="currentColor"/g, `fill="${E(a)}"`)), O(f), St(f, (v, x) => {
    var w;
    return (w = Tn) == null ? void 0 : w(v, x);
  }, () => I("Text Color"));
  var b = H(f, 2), m = L(b);
  {
    var g = (v) => {
      $d(v, { colors: o, onSelect: l });
    };
    st(m, (v) => {
      E(s) && v(g);
    });
  }
  O(b), ne((v) => h = pt(f, 1, "", null, h, v), [
    () => ({ "tooltip-disabled": E(s) })
  ]), F(n, d), xe();
}
ve(D0, {}, [], [], !0, tn);
const SM = `<?xml version="1.0" encoding="UTF-8"?>
<svg id="b"
    xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 72 72">
    <!-- Generator: Adobe Illustrator 29.3.1, SVG Export Plug-In . SVG Version: 2.1.0 Build 151)  -->
    <g id="c">
        <g id="d">
            <rect x="9" y="54.8" width="54" height="10.2" rx=".5" ry=".5" fill="rgba(0,0,0,0)"/>
            <path class="st1" d="M62.3,15.6l-10.1-9.7c-.5-.5-1.1-.7-1.7-.7h0c-.6,0-1.2.2-1.7.7l-28,26.7c-.5.4-.7,1.1-.7,1.6s.2,1.2.7,1.7l.9.8-12.5,11.9h16.8l4.2-3.9.9.8c.5.5,1.1.7,1.7.7.6,0,1.3-.2,1.7-.7l28-26.7c.5-.4.7-1.1.7-1.6s-.2-1.2-.7-1.7h0ZM45.7,28.5l-7.1-6.8,11.8-11.3,7.1,6.8-11.8,11.3Z"/>
        </g>
    </g>
</svg>
`;
var CM = Z('<button><!></button> <div class="color-panel-container svelte-gqoyg9"><!></div>', 1);
const TM = {
  hash: "svelte-gqoyg9",
  code: ".color-panel-container.svelte-gqoyg9 {position:relative;}"
};
function $0(n, e) {
  ye(e, !0), Ht(n, TM);
  const t = e.$$host;
  t.addEventListener("click", u);
  const { options: i, tiptap: r } = t;
  let s = ce(!1);
  const o = i.presetColors ?? [
    "#000000",
    "#002B76",
    "#1B4F2A",
    "#783F04",
    "#700000",
    "#351C75",
    "#6B6B6B",
    "#1155CC",
    "#38761D",
    "#B45F06",
    "#AC0000",
    "#674EA7",
    "#999999",
    "#4A86E8",
    "#6AA84F",
    "#E69138",
    "#DC3D3D",
    "#8E7CC3",
    "#D9D9D9",
    "#A4C2F4",
    "#B6D7A8",
    "#F9CB9C",
    "#EA9999",
    "#B4A7D6",
    "#F3F3F3",
    "#CFE2F3",
    "#D9EAD3",
    "#FFE6C4",
    "#F4CCCC",
    "#D9D2E9",
    "#FFFFFF",
    "#EAF1FB",
    "#EBF5EB",
    "#FFF8E1",
    "#FDEBEE",
    "#F2EFF9"
  ], a = "rgba(0,0,0,0)";
  let l = ce(a);
  t.onEditorUpdate = () => {
    q(l, (r == null ? void 0 : r.getAttributes("textStyle").backgroundColor) ?? a, !0);
  };
  function c(x) {
    q(l, x, !0), r == null || r.chain().focus().setBackgroundColor(x).run(), q(s, !1);
  }
  function u(x) {
    r && (x.stopPropagation(), q(s, !E(s)));
  }
  function d() {
    q(s, !1);
  }
  $e(() => (document.addEventListener("click", d), () => {
    document.removeEventListener("click", d);
  }));
  var f = CM(), h = Re(f);
  let p;
  var b = L(h);
  qt(b, () => SM.replace(/fill="rgba\(0,0,0,0\)"/g, `fill="${E(l)}"`)), O(h), St(h, (x, w) => {
    var S;
    return (S = Tn) == null ? void 0 : S(x, w);
  }, () => I("Highlight Color"));
  var m = H(h, 2), g = L(m);
  {
    var v = (x) => {
      $d(x, { colors: o, onSelect: c });
    };
    st(g, (x) => {
      E(s) && x(v);
    });
  }
  O(m), ne((x) => p = pt(h, 1, "", null, p, x), [
    () => ({ "tooltip-disabled": E(s) })
  ]), F(n, f), xe();
}
ve($0, {}, [], [], !0, tn);
const EM = `<svg width="72" height="72" viewBox="0 0 72 72" fill="none"
    xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#clip0_57_211)">
        <path d="M48 32.8H24V36H48V32.8Z" fill="black"/>
        <path d="M48 40.8H24V44H48V40.8Z" fill="black"/>
        <path d="M48 48.8H24V52H48V48.8Z" fill="black"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M51.2 15.2H47.2V12.8H41.6C41.6 9.71001 39.09 7.20001 36 7.20001C32.91 7.20001 30.4 9.71001 30.4 12.8H24.8V15.2H20.8C17.27 15.2 14.4 18.07 14.4 21.6V58.4C14.4 61.93 17.27 64.8 20.8 64.8H51.2C54.73 64.8 57.6 61.93 57.6 58.4V21.6C57.6 18.07 54.73 15.2 51.2 15.2ZM52.8 58.4C52.8 59.28 52.08 60 51.2 60H20.8C19.92 60 19.2 59.28 19.2 58.4V21.6C19.2 20.72 19.92 20 20.8 20H24.8V22.4H47.2V20H51.2C52.08 20 52.8 20.72 52.8 21.6V58.4Z" fill="black"/>
    </g>
    <defs>
        <clipPath id="clip0_57_211">
            <rect width="72" height="72" fill="white"/>
        </clipPath>
    </defs>
</svg>
`;
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */
const {
  entries: B0,
  setPrototypeOf: Op,
  isFrozen: AM,
  getPrototypeOf: MM,
  getOwnPropertyDescriptor: OM
} = Object;
let {
  freeze: Bt,
  seal: hn,
  create: z0
} = Object, {
  apply: xu,
  construct: wu
} = typeof Reflect < "u" && Reflect;
Bt || (Bt = function(e) {
  return e;
});
hn || (hn = function(e) {
  return e;
});
xu || (xu = function(e, t, i) {
  return e.apply(t, i);
});
wu || (wu = function(e, t) {
  return new e(...t);
});
const Vo = zt(Array.prototype.forEach), NM = zt(Array.prototype.lastIndexOf), Np = zt(Array.prototype.pop), cs = zt(Array.prototype.push), LM = zt(Array.prototype.splice), Zo = zt(String.prototype.toLowerCase), Cc = zt(String.prototype.toString), Lp = zt(String.prototype.match), us = zt(String.prototype.replace), RM = zt(String.prototype.indexOf), IM = zt(String.prototype.trim), bn = zt(Object.prototype.hasOwnProperty), It = zt(RegExp.prototype.test), ds = PM(TypeError);
function zt(n) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      i[r - 1] = arguments[r];
    return xu(n, e, i);
  };
}
function PM(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return wu(n, t);
  };
}
function Ce(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Zo;
  Op && Op(n, null);
  let i = e.length;
  for (; i--; ) {
    let r = e[i];
    if (typeof r == "string") {
      const s = t(r);
      s !== r && (AM(e) || (e[i] = s), r = s);
    }
    n[r] = !0;
  }
  return n;
}
function DM(n) {
  for (let e = 0; e < n.length; e++)
    bn(n, e) || (n[e] = null);
  return n;
}
function Mi(n) {
  const e = z0(null);
  for (const [t, i] of B0(n))
    bn(n, t) && (Array.isArray(i) ? e[t] = DM(i) : i && typeof i == "object" && i.constructor === Object ? e[t] = Mi(i) : e[t] = i);
  return e;
}
function fs(n, e) {
  for (; n !== null; ) {
    const i = OM(n, e);
    if (i) {
      if (i.get)
        return zt(i.get);
      if (typeof i.value == "function")
        return zt(i.value);
    }
    n = MM(n);
  }
  function t() {
    return null;
  }
  return t;
}
const Rp = Bt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Tc = Bt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Ec = Bt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), $M = Bt(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Ac = Bt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), BM = Bt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Ip = Bt(["#text"]), Pp = Bt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), Mc = Bt(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Dp = Bt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), jo = Bt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), zM = hn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), HM = hn(/<%[\w\W]*|[\w\W]*%>/gm), FM = hn(/\$\{[\w\W]*/gm), VM = hn(/^data-[\-\w.\u00B7-\uFFFF]+$/), jM = hn(/^aria-[\-\w]+$/), H0 = hn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), WM = hn(/^(?:\w+script|data):/i), UM = hn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), F0 = hn(/^html$/i), KM = hn(/^[a-z][.\w]*(-[.\w]+)+$/i);
var $p = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: jM,
  ATTR_WHITESPACE: UM,
  CUSTOM_ELEMENT: KM,
  DATA_ATTR: VM,
  DOCTYPE_NAME: F0,
  ERB_EXPR: HM,
  IS_ALLOWED_URI: H0,
  IS_SCRIPT_OR_DATA: WM,
  MUSTACHE_EXPR: zM,
  TMPLIT_EXPR: FM
});
const hs = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, qM = function() {
  return typeof window > "u" ? null : window;
}, GM = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const r = "data-tt-policy-suffix";
  t && t.hasAttribute(r) && (i = t.getAttribute(r));
  const s = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, Bp = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function V0() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : qM();
  const e = (le) => V0(le);
  if (e.version = "3.2.4", e.removed = [], !n || !n.document || n.document.nodeType !== hs.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const i = t, r = i.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: f,
    trustedTypes: h
  } = n, p = l.prototype, b = fs(p, "cloneNode"), m = fs(p, "remove"), g = fs(p, "nextSibling"), v = fs(p, "childNodes"), x = fs(p, "parentNode");
  if (typeof o == "function") {
    const le = t.createElement("template");
    le.content && le.content.ownerDocument && (t = le.content.ownerDocument);
  }
  let w, S = "";
  const {
    implementation: k,
    createNodeIterator: C,
    createDocumentFragment: y,
    getElementsByTagName: A
  } = t, {
    importNode: _
  } = i;
  let T = Bp();
  e.isSupported = typeof B0 == "function" && typeof x == "function" && k && k.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: M,
    ERB_EXPR: z,
    TMPLIT_EXPR: P,
    DATA_ATTR: V,
    ARIA_ATTR: U,
    IS_SCRIPT_OR_DATA: J,
    ATTR_WHITESPACE: re,
    CUSTOM_ELEMENT: te
  } = $p;
  let {
    IS_ALLOWED_URI: ge
  } = $p, se = null;
  const Be = Ce({}, [...Rp, ...Tc, ...Ec, ...Ac, ...Ip]);
  let fe = null;
  const Je = Ce({}, [...Pp, ...Mc, ...Dp, ...jo]);
  let we = Object.seal(z0(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), R = null, tt = null, he = !0, ct = !0, Ne = !1, X = !0, Ee = !1, me = !0, D = !1, de = !1, be = !1, j = !1, Ft = !1, ut = !1, nn = !0, rn = !1;
  const er = "user-content-";
  let sn = !0, Vn = !1, He = {}, Ue = null;
  const Pe = Ce({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Se = null;
  const Ct = Ce({}, ["audio", "video", "img", "source", "image", "track"]);
  let Ti = null;
  const ni = Ce({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), tr = "http://www.w3.org/1998/Math/MathML", On = "http://www.w3.org/2000/svg", mn = "http://www.w3.org/1999/xhtml";
  let on = mn, Xr = !1, ii = null;
  const Sl = Ce({}, [tr, On, mn], Cc);
  let it = Ce({}, ["mi", "mo", "mn", "ms", "mtext"]), nr = Ce({}, ["annotation-xml"]);
  const Cl = Ce({}, ["title", "style", "font", "a", "script"]);
  let Ei = null;
  const Tl = ["application/xhtml+xml", "text/html"], El = "text/html";
  let rt = null, ri = null;
  const Al = t.createElement("form"), uo = function(N) {
    return N instanceof RegExp || N instanceof Function;
  }, Yr = function() {
    let N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ri && ri === N)) {
      if ((!N || typeof N != "object") && (N = {}), N = Mi(N), Ei = // eslint-disable-next-line unicorn/prefer-includes
      Tl.indexOf(N.PARSER_MEDIA_TYPE) === -1 ? El : N.PARSER_MEDIA_TYPE, rt = Ei === "application/xhtml+xml" ? Cc : Zo, se = bn(N, "ALLOWED_TAGS") ? Ce({}, N.ALLOWED_TAGS, rt) : Be, fe = bn(N, "ALLOWED_ATTR") ? Ce({}, N.ALLOWED_ATTR, rt) : Je, ii = bn(N, "ALLOWED_NAMESPACES") ? Ce({}, N.ALLOWED_NAMESPACES, Cc) : Sl, Ti = bn(N, "ADD_URI_SAFE_ATTR") ? Ce(Mi(ni), N.ADD_URI_SAFE_ATTR, rt) : ni, Se = bn(N, "ADD_DATA_URI_TAGS") ? Ce(Mi(Ct), N.ADD_DATA_URI_TAGS, rt) : Ct, Ue = bn(N, "FORBID_CONTENTS") ? Ce({}, N.FORBID_CONTENTS, rt) : Pe, R = bn(N, "FORBID_TAGS") ? Ce({}, N.FORBID_TAGS, rt) : {}, tt = bn(N, "FORBID_ATTR") ? Ce({}, N.FORBID_ATTR, rt) : {}, He = bn(N, "USE_PROFILES") ? N.USE_PROFILES : !1, he = N.ALLOW_ARIA_ATTR !== !1, ct = N.ALLOW_DATA_ATTR !== !1, Ne = N.ALLOW_UNKNOWN_PROTOCOLS || !1, X = N.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ee = N.SAFE_FOR_TEMPLATES || !1, me = N.SAFE_FOR_XML !== !1, D = N.WHOLE_DOCUMENT || !1, j = N.RETURN_DOM || !1, Ft = N.RETURN_DOM_FRAGMENT || !1, ut = N.RETURN_TRUSTED_TYPE || !1, be = N.FORCE_BODY || !1, nn = N.SANITIZE_DOM !== !1, rn = N.SANITIZE_NAMED_PROPS || !1, sn = N.KEEP_CONTENT !== !1, Vn = N.IN_PLACE || !1, ge = N.ALLOWED_URI_REGEXP || H0, on = N.NAMESPACE || mn, it = N.MATHML_TEXT_INTEGRATION_POINTS || it, nr = N.HTML_INTEGRATION_POINTS || nr, we = N.CUSTOM_ELEMENT_HANDLING || {}, N.CUSTOM_ELEMENT_HANDLING && uo(N.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (we.tagNameCheck = N.CUSTOM_ELEMENT_HANDLING.tagNameCheck), N.CUSTOM_ELEMENT_HANDLING && uo(N.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (we.attributeNameCheck = N.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), N.CUSTOM_ELEMENT_HANDLING && typeof N.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (we.allowCustomizedBuiltInElements = N.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ee && (ct = !1), Ft && (j = !0), He && (se = Ce({}, Ip), fe = [], He.html === !0 && (Ce(se, Rp), Ce(fe, Pp)), He.svg === !0 && (Ce(se, Tc), Ce(fe, Mc), Ce(fe, jo)), He.svgFilters === !0 && (Ce(se, Ec), Ce(fe, Mc), Ce(fe, jo)), He.mathMl === !0 && (Ce(se, Ac), Ce(fe, Dp), Ce(fe, jo))), N.ADD_TAGS && (se === Be && (se = Mi(se)), Ce(se, N.ADD_TAGS, rt)), N.ADD_ATTR && (fe === Je && (fe = Mi(fe)), Ce(fe, N.ADD_ATTR, rt)), N.ADD_URI_SAFE_ATTR && Ce(Ti, N.ADD_URI_SAFE_ATTR, rt), N.FORBID_CONTENTS && (Ue === Pe && (Ue = Mi(Ue)), Ce(Ue, N.FORBID_CONTENTS, rt)), sn && (se["#text"] = !0), D && Ce(se, ["html", "head", "body"]), se.table && (Ce(se, ["tbody"]), delete R.tbody), N.TRUSTED_TYPES_POLICY) {
        if (typeof N.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw ds('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof N.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw ds('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        w = N.TRUSTED_TYPES_POLICY, S = w.createHTML("");
      } else
        w === void 0 && (w = GM(h, r)), w !== null && typeof S == "string" && (S = w.createHTML(""));
      Bt && Bt(N), ri = N;
    }
  }, fo = Ce({}, [...Tc, ...Ec, ...$M]), ho = Ce({}, [...Ac, ...BM]), Ml = function(N) {
    let K = x(N);
    (!K || !K.tagName) && (K = {
      namespaceURI: on,
      tagName: "template"
    });
    const ie = Zo(N.tagName), qe = Zo(K.tagName);
    return ii[N.namespaceURI] ? N.namespaceURI === On ? K.namespaceURI === mn ? ie === "svg" : K.namespaceURI === tr ? ie === "svg" && (qe === "annotation-xml" || it[qe]) : !!fo[ie] : N.namespaceURI === tr ? K.namespaceURI === mn ? ie === "math" : K.namespaceURI === On ? ie === "math" && nr[qe] : !!ho[ie] : N.namespaceURI === mn ? K.namespaceURI === On && !nr[qe] || K.namespaceURI === tr && !it[qe] ? !1 : !ho[ie] && (Cl[ie] || !fo[ie]) : !!(Ei === "application/xhtml+xml" && ii[N.namespaceURI]) : !1;
  }, an = function(N) {
    cs(e.removed, {
      element: N
    });
    try {
      x(N).removeChild(N);
    } catch {
      m(N);
    }
  }, ir = function(N, K) {
    try {
      cs(e.removed, {
        attribute: K.getAttributeNode(N),
        from: K
      });
    } catch {
      cs(e.removed, {
        attribute: null,
        from: K
      });
    }
    if (K.removeAttribute(N), N === "is")
      if (j || Ft)
        try {
          an(K);
        } catch {
        }
      else
        try {
          K.setAttribute(N, "");
        } catch {
        }
  }, po = function(N) {
    let K = null, ie = null;
    if (be)
      N = "<remove></remove>" + N;
    else {
      const vt = Lp(N, /^[\r\n\t ]+/);
      ie = vt && vt[0];
    }
    Ei === "application/xhtml+xml" && on === mn && (N = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + N + "</body></html>");
    const qe = w ? w.createHTML(N) : N;
    if (on === mn)
      try {
        K = new f().parseFromString(qe, Ei);
      } catch {
      }
    if (!K || !K.documentElement) {
      K = k.createDocument(on, "template", null);
      try {
        K.documentElement.innerHTML = Xr ? S : qe;
      } catch {
      }
    }
    const Tt = K.body || K.documentElement;
    return N && ie && Tt.insertBefore(t.createTextNode(ie), Tt.childNodes[0] || null), on === mn ? A.call(K, D ? "html" : "body")[0] : D ? K.documentElement : Tt;
  }, mo = function(N) {
    return C.call(
      N.ownerDocument || N,
      N,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Zr = function(N) {
    return N instanceof d && (typeof N.nodeName != "string" || typeof N.textContent != "string" || typeof N.removeChild != "function" || !(N.attributes instanceof u) || typeof N.removeAttribute != "function" || typeof N.setAttribute != "function" || typeof N.namespaceURI != "string" || typeof N.insertBefore != "function" || typeof N.hasChildNodes != "function");
  }, go = function(N) {
    return typeof a == "function" && N instanceof a;
  };
  function gn(le, N, K) {
    Vo(le, (ie) => {
      ie.call(e, N, K, ri);
    });
  }
  const _o = function(N) {
    let K = null;
    if (gn(T.beforeSanitizeElements, N, null), Zr(N))
      return an(N), !0;
    const ie = rt(N.nodeName);
    if (gn(T.uponSanitizeElement, N, {
      tagName: ie,
      allowedTags: se
    }), N.hasChildNodes() && !go(N.firstElementChild) && It(/<[/\w]/g, N.innerHTML) && It(/<[/\w]/g, N.textContent) || N.nodeType === hs.progressingInstruction || me && N.nodeType === hs.comment && It(/<[/\w]/g, N.data))
      return an(N), !0;
    if (!se[ie] || R[ie]) {
      if (!R[ie] && zd(ie) && (we.tagNameCheck instanceof RegExp && It(we.tagNameCheck, ie) || we.tagNameCheck instanceof Function && we.tagNameCheck(ie)))
        return !1;
      if (sn && !Ue[ie]) {
        const qe = x(N) || N.parentNode, Tt = v(N) || N.childNodes;
        if (Tt && qe) {
          const vt = Tt.length;
          for (let Vt = vt - 1; Vt >= 0; --Vt) {
            const Nn = b(Tt[Vt], !0);
            Nn.__removalCount = (N.__removalCount || 0) + 1, qe.insertBefore(Nn, g(N));
          }
        }
      }
      return an(N), !0;
    }
    return N instanceof l && !Ml(N) || (ie === "noscript" || ie === "noembed" || ie === "noframes") && It(/<\/no(script|embed|frames)/i, N.innerHTML) ? (an(N), !0) : (Ee && N.nodeType === hs.text && (K = N.textContent, Vo([M, z, P], (qe) => {
      K = us(K, qe, " ");
    }), N.textContent !== K && (cs(e.removed, {
      element: N.cloneNode()
    }), N.textContent = K)), gn(T.afterSanitizeElements, N, null), !1);
  }, Bd = function(N, K, ie) {
    if (nn && (K === "id" || K === "name") && (ie in t || ie in Al))
      return !1;
    if (!(ct && !tt[K] && It(V, K))) {
      if (!(he && It(U, K))) {
        if (!fe[K] || tt[K]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(zd(N) && (we.tagNameCheck instanceof RegExp && It(we.tagNameCheck, N) || we.tagNameCheck instanceof Function && we.tagNameCheck(N)) && (we.attributeNameCheck instanceof RegExp && It(we.attributeNameCheck, K) || we.attributeNameCheck instanceof Function && we.attributeNameCheck(K)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            K === "is" && we.allowCustomizedBuiltInElements && (we.tagNameCheck instanceof RegExp && It(we.tagNameCheck, ie) || we.tagNameCheck instanceof Function && we.tagNameCheck(ie)))
          ) return !1;
        } else if (!Ti[K]) {
          if (!It(ge, us(ie, re, ""))) {
            if (!((K === "src" || K === "xlink:href" || K === "href") && N !== "script" && RM(ie, "data:") === 0 && Se[N])) {
              if (!(Ne && !It(J, us(ie, re, "")))) {
                if (ie)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, zd = function(N) {
    return N !== "annotation-xml" && Lp(N, te);
  }, Hd = function(N) {
    gn(T.beforeSanitizeAttributes, N, null);
    const {
      attributes: K
    } = N;
    if (!K || Zr(N))
      return;
    const ie = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: fe,
      forceKeepAttr: void 0
    };
    let qe = K.length;
    for (; qe--; ) {
      const Tt = K[qe], {
        name: vt,
        namespaceURI: Vt,
        value: Nn
      } = Tt, Qr = rt(vt);
      let Rt = vt === "value" ? Nn : IM(Nn);
      if (ie.attrName = Qr, ie.attrValue = Rt, ie.keepAttr = !0, ie.forceKeepAttr = void 0, gn(T.uponSanitizeAttribute, N, ie), Rt = ie.attrValue, rn && (Qr === "id" || Qr === "name") && (ir(vt, N), Rt = er + Rt), me && It(/((--!?|])>)|<\/(style|title)/i, Rt)) {
        ir(vt, N);
        continue;
      }
      if (ie.forceKeepAttr || (ir(vt, N), !ie.keepAttr))
        continue;
      if (!X && It(/\/>/i, Rt)) {
        ir(vt, N);
        continue;
      }
      Ee && Vo([M, z, P], (Vd) => {
        Rt = us(Rt, Vd, " ");
      });
      const Fd = rt(N.nodeName);
      if (Bd(Fd, Qr, Rt)) {
        if (w && typeof h == "object" && typeof h.getAttributeType == "function" && !Vt)
          switch (h.getAttributeType(Fd, Qr)) {
            case "TrustedHTML": {
              Rt = w.createHTML(Rt);
              break;
            }
            case "TrustedScriptURL": {
              Rt = w.createScriptURL(Rt);
              break;
            }
          }
        try {
          Vt ? N.setAttributeNS(Vt, vt, Rt) : N.setAttribute(vt, Rt), Zr(N) ? an(N) : Np(e.removed);
        } catch {
        }
      }
    }
    gn(T.afterSanitizeAttributes, N, null);
  }, sb = function le(N) {
    let K = null;
    const ie = mo(N);
    for (gn(T.beforeSanitizeShadowDOM, N, null); K = ie.nextNode(); )
      gn(T.uponSanitizeShadowNode, K, null), _o(K), Hd(K), K.content instanceof s && le(K.content);
    gn(T.afterSanitizeShadowDOM, N, null);
  };
  return e.sanitize = function(le) {
    let N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, K = null, ie = null, qe = null, Tt = null;
    if (Xr = !le, Xr && (le = "<!-->"), typeof le != "string" && !go(le))
      if (typeof le.toString == "function") {
        if (le = le.toString(), typeof le != "string")
          throw ds("dirty is not a string, aborting");
      } else
        throw ds("toString is not a function");
    if (!e.isSupported)
      return le;
    if (de || Yr(N), e.removed = [], typeof le == "string" && (Vn = !1), Vn) {
      if (le.nodeName) {
        const Nn = rt(le.nodeName);
        if (!se[Nn] || R[Nn])
          throw ds("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (le instanceof a)
      K = po("<!---->"), ie = K.ownerDocument.importNode(le, !0), ie.nodeType === hs.element && ie.nodeName === "BODY" || ie.nodeName === "HTML" ? K = ie : K.appendChild(ie);
    else {
      if (!j && !Ee && !D && // eslint-disable-next-line unicorn/prefer-includes
      le.indexOf("<") === -1)
        return w && ut ? w.createHTML(le) : le;
      if (K = po(le), !K)
        return j ? null : ut ? S : "";
    }
    K && be && an(K.firstChild);
    const vt = mo(Vn ? le : K);
    for (; qe = vt.nextNode(); )
      _o(qe), Hd(qe), qe.content instanceof s && sb(qe.content);
    if (Vn)
      return le;
    if (j) {
      if (Ft)
        for (Tt = y.call(K.ownerDocument); K.firstChild; )
          Tt.appendChild(K.firstChild);
      else
        Tt = K;
      return (fe.shadowroot || fe.shadowrootmode) && (Tt = _.call(i, Tt, !0)), Tt;
    }
    let Vt = D ? K.outerHTML : K.innerHTML;
    return D && se["!doctype"] && K.ownerDocument && K.ownerDocument.doctype && K.ownerDocument.doctype.name && It(F0, K.ownerDocument.doctype.name) && (Vt = "<!DOCTYPE " + K.ownerDocument.doctype.name + `>
` + Vt), Ee && Vo([M, z, P], (Nn) => {
      Vt = us(Vt, Nn, " ");
    }), w && ut ? w.createHTML(Vt) : Vt;
  }, e.setConfig = function() {
    let le = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Yr(le), de = !0;
  }, e.clearConfig = function() {
    ri = null, de = !1;
  }, e.isValidAttribute = function(le, N, K) {
    ri || Yr({});
    const ie = rt(le), qe = rt(N);
    return Bd(ie, qe, K);
  }, e.addHook = function(le, N) {
    typeof N == "function" && cs(T[le], N);
  }, e.removeHook = function(le, N) {
    if (N !== void 0) {
      const K = NM(T[le], N);
      return K === -1 ? void 0 : LM(T[le], K, 1)[0];
    }
    return Np(T[le]);
  }, e.removeHooks = function(le) {
    T[le] = [];
  }, e.removeAllHooks = function() {
    T = Bp();
  }, e;
}
var JM = V0();
function XM(n, e, t) {
  const i = n.target;
  q(e, ""), t(i.value);
}
var YM = Z("<option> </option>"), ZM = Z('<label for="boilerplate_text"> </label> <div id="boilerplate_text" class="form-control"><!></div>', 1), QM = Z('<div class="form-group mb-3"><label for="boilerplate_title"> </label> <select id="boilerplate_title" class="form-control"></select> <div class="form-text"> </div></div> <div class="form-group mb-3"><!></div>', 1), eO = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function j0(n, e) {
  ye(e, !0);
  const t = JM(window);
  let i = Q(e, "boilerplates", 7), r = Q(e, "onSubmit", 7), s = Q(e, "onClose", 7), o = ce(""), a = ce("");
  async function l(u) {
    var d;
    q(a, ((d = i().find((f) => f.url === u)) == null ? void 0 : d.description) || "", !0), q(o, await (await fetch(u)).text(), !0);
  }
  u0(() => {
    i().length > 0 && l(i()[0].url);
  });
  let c;
  return An(n, {
    size: "lg",
    $$events: {
      close(...u) {
        var d;
        (d = s()) == null || d.apply(this, u);
      }
    },
    children: (u, d) => {
      Mn(u, {
        get close() {
          return c;
        },
        set close(f) {
          c = f;
        },
        $$slots: {
          title: (f, h) => {
            var p = Cn();
            ne((b) => B(p, b), [() => I("Insert Boilerplate")]), F(f, p);
          },
          body: (f, h) => {
            var p = QM(), b = Re(p), m = L(b), g = L(m, !0);
            O(m);
            var v = H(m, 2);
            v.__change = [
              XM,
              o,
              l
            ], ft(v, 21, i, (y) => y.url, (y, A) => {
              var _ = YM(), T = {}, M = L(_, !0);
              O(_), ne(() => {
                T !== (T = E(A).url) && (_.value = (_.__value = E(A).url) == null ? "" : E(A).url), B(M, E(A).title);
              }), F(y, _);
            }), O(v);
            var x = H(v, 2), w = L(x, !0);
            O(x), O(b);
            var S = H(b, 2), k = L(S);
            {
              var C = (y) => {
                var A = ZM(), _ = Re(A), T = L(_, !0);
                O(_);
                var M = H(_, 2), z = L(M);
                qt(z, () => t.sanitize(E(o))), O(M), ne((P) => B(T, P), [() => I("Text")]), F(y, A);
              };
              st(k, (y) => {
                E(o) && y(C);
              });
            }
            O(S), ne(
              (y) => {
                B(g, y), B(w, E(a));
              },
              [() => I("Boilerplate")]
            ), F(f, p);
          },
          footer: (f, h) => {
            var p = eO(), b = Re(p);
            b.__click = () => {
              r()(E(o)), c();
            };
            var m = L(b, !0);
            O(b);
            var g = H(b, 2);
            g.__click = c;
            var v = L(g, !0);
            O(g), ne(
              (x, w, S, k) => {
                Ae(b, "title", x), B(m, w), Ae(g, "title", S), B(v, k);
              },
              [
                () => I("Insert (s)"),
                () => I("Insert"),
                () => I("Cancel (x)"),
                () => I("Cancel")
              ]
            ), F(f, p);
          }
        }
      });
    },
    $$slots: { default: !0 }
  }), xe({
    get boilerplates() {
      return i();
    },
    set boilerplates(u) {
      i(u), ee();
    },
    get onSubmit() {
      return r();
    },
    set onSubmit(u) {
      r(u), ee();
    },
    get onClose() {
      return s();
    },
    set onClose(u) {
      s(u), ee();
    }
  });
}
Ot(["change", "click"]);
ve(j0, { boilerplates: {}, onSubmit: {}, onClose: {} }, [], [], !0);
var tO = Z("<button><!></button>");
function W0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", () => {
    const s = Nt(j0, {
      target: document.body,
      props: {
        boilerplates: t.options.boilerplates,
        onSubmit: (o) => {
          var a;
          (a = t.tiptap) == null || a.chain().focus().insertContent(o).run();
        },
        onClose: () => {
          at(s);
        }
      }
    });
  });
  var i = tO(), r = L(i);
  qt(r, () => EM), O(i), St(i, (s, o) => {
    var a;
    return (a = Tn) == null ? void 0 : a(s, o);
  }, () => I("Insert Boilerplate")), F(n, i), xe();
}
ve(W0, {}, [], [], !0, tn);
const nO = {
  bold: RE,
  italic: IE,
  underline: PE,
  strike: DE,
  bulletList: BE,
  orderedList: zE,
  horizontalRule: JE,
  blockquote: HE,
  unlink: $E,
  insertHtml: XE,
  source: YE,
  undo: FE,
  redo: VE,
  removeFormat: jE,
  alignLeft: WE,
  alignCenter: UE,
  alignRight: KE,
  indent: qE,
  outdent: GE,
  fullScreen: ZE,
  // @ts-ignore
  link: x0.element,
  // @ts-ignore
  file: C0.element,
  // @ts-ignore
  image: E0.element,
  // @ts-ignore
  structure: O0.element,
  // @ts-ignore
  table: I0.element,
  // @ts-ignore
  block: P0.element,
  // @ts-ignore
  foregroundColor: D0.element,
  // @ts-ignore
  backgroundColor: $0.element,
  // @ts-ignore
  boilerplate: W0.element,
  // for context toolbar
  // @ts-ignore
  previewLink: w0.element,
  // @ts-ignore
  editLink: S0.element,
  // @ts-ignore
  deleteImage: A0.element,
  // @ts-ignore
  editImage: M0.element
}, iO = {
  paragraph: "p",
  heading: "h1",
  bulletList: "ul",
  orderedList: "ol",
  listItem: "li",
  blockquote: "blockquote",
  horizontalRule: "hr",
  table: "table",
  tableRow: "tr",
  tableCell: "td",
  tableHeader: "th",
  hardBreak: "br",
  text: "",
  textBlock: ""
}, rO = (n) => iO[n] ?? n;
class sO extends Zb {
  onEditorUpdate() {
    if (!this.tiptap)
      return;
    const { selection: e } = this.tiptap.state, t = e.$head, i = [];
    for (let r = 1; r <= t.depth; r++) {
      const s = t.node(r);
      let o = rO(s.type.name);
      if (!o)
        continue;
      const a = s.attrs.textAlign;
      a && (o += `[align=${a}]`), i.push(o);
    }
    this.shadowRoot.textContent = i.join(" > ");
  }
}
const oO = {
  path: sO
}, U0 = document.createElement("style");
U0.textContent = Qb;
const co = (n) => class extends _0(n) {
  constructor() {
    super(...arguments);
    _n(this, "content");
  }
  connectedCallback() {
    super.connectedCallback(), this.shadowRoot.appendChild(U0.cloneNode(!0));
  }
  onEditorSetPasteContent(t) {
    this.content = t;
  }
  isEditorItemAvailable() {
    return !0;
  }
  insertContent(t) {
    return Ir.prototype.insertContent.bind(this)(t);
  }
  onEditorPaste() {
  }
};
function aO(n, e) {
  E(e).every((i) => i.checked) ? E(e).forEach((i) => i.checked = !1) : E(e).forEach((i) => i.checked = !0);
}
function lO(n, e) {
  E(e).every((i) => i.checked) ? E(e).forEach((i) => i.checked = !1) : E(e).forEach((i) => i.checked = !0);
}
var cO = Z('<li><label><input type="checkbox"> </label></li>'), uO = Z('<h4 class="svelte-ecdfcs"> </h4> <div class="help-text svelte-ecdfcs"> </div> <ul class="svelte-ecdfcs"></ul> <div class="mt-checkbox-all svelte-ecdfcs"><label><input type="checkbox" name="all"> </label></div>', 1), dO = Z('<li><label><input type="checkbox"> </label></li>'), fO = Z('<h4 class="svelte-ecdfcs"> </h4> <div class="help-text svelte-ecdfcs"> </div> <ul class="svelte-ecdfcs"></ul> <div class="mt-checkbox-all svelte-ecdfcs"><label><input type="checkbox" name="all"> </label></div>', 1), hO = Z('<div class="html-modal-modal-content svelte-ecdfcs"><!> <!></div>'), pO = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
const mO = {
  hash: "svelte-ecdfcs",
  code: ".mt-checkbox-all.svelte-ecdfcs {margin-top:0.5rem;}.help-text.svelte-ecdfcs {margin-bottom:0.5rem;font-size:0.8rem;color:#666;}h4.svelte-ecdfcs {font-weight:bold;margin-top:1.5rem;}h4.svelte-ecdfcs:first-child {margin-top:0;}ul.svelte-ecdfcs {list-style:none;padding:0;}.html-modal-modal-content.svelte-ecdfcs {overflow-y:auto;max-height:580px;}"
};
function K0(n, e) {
  ye(e, !0), Ht(n, mO);
  let t = Q(e, "htmlDocument", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7);
  const s = ce(Fe([]));
  t().body.querySelectorAll("*").forEach((c) => {
    const u = c.dataset;
    for (const d in u)
      E(s).find((f) => f.name === d) || E(s).push({ name: d, checked: !1 });
  });
  const o = ce(Fe([]));
  t().body.querySelectorAll("[style]").forEach((c) => {
    const u = c.getAttribute("style");
    if (!u) return;
    u.split(";").map((f) => f.trim()).filter((f) => f).map((f) => {
      const [h] = f.split(":");
      return h.trim();
    }).forEach((f) => {
      E(o).find((h) => h.name === f) || E(o).push({ name: f, checked: !0 });
    });
  });
  let a, l;
  return et(
    An(n, {
      $$events: {
        close(...c) {
          var u;
          (u = r()) == null || u.apply(this, c);
        }
      },
      children: (c, u) => {
        Mn(c, {
          get close() {
            return l;
          },
          set close(d) {
            l = d;
          },
          $$slots: {
            title: (d, f) => {
              var h = Cn();
              ne((p) => B(h, p), [() => I("Paste as HTML")]), F(d, h);
            },
            body: (d, f) => {
              var h = hO(), p = L(h);
              {
                var b = (v) => {
                  var x = uO(), w = Re(x), S = L(w, !0);
                  O(w);
                  var k = H(w, 2), C = L(k, !0);
                  O(k);
                  var y = H(k, 2);
                  ft(y, 21, () => E(s), (z) => z.name, (z, P, V) => {
                    var U = cO(), J = L(U), re = L(J);
                    ht(re);
                    var te = H(re);
                    O(J), O(U), ne(() => {
                      Ae(re, "name", E(P).name), B(te, ` data-${E(P).name ?? ""}`);
                    }), xp(re, () => E(P).checked, (ge) => E(P).checked = ge), F(z, U);
                  }), O(y);
                  var A = H(y, 2), _ = L(A), T = L(_);
                  ht(T), T.__change = [lO, s];
                  var M = H(T);
                  O(_), O(A), ne(
                    (z, P, V, U) => {
                      B(S, z), B(C, P), bp(T, V), B(M, ` ${U ?? ""}`);
                    },
                    [
                      () => I("Data attributes"),
                      () => I("Select the data attributes you want to keep in the pasted HTML. Unselected attributes will be removed."),
                      () => E(s).every((z) => z.checked),
                      () => I("Select All")
                    ]
                  ), F(v, x);
                };
                st(p, (v) => {
                  E(s).length > 0 && v(b);
                });
              }
              var m = H(p, 2);
              {
                var g = (v) => {
                  var x = fO(), w = Re(x), S = L(w, !0);
                  O(w);
                  var k = H(w, 2), C = L(k, !0);
                  O(k);
                  var y = H(k, 2);
                  ft(y, 21, () => E(o), (z) => z.name, (z, P, V) => {
                    var U = dO(), J = L(U), re = L(J);
                    ht(re);
                    var te = H(re);
                    O(J), O(U), ne(() => {
                      Ae(re, "name", E(P).name), B(te, ` ${E(P).name ?? ""}`);
                    }), xp(re, () => E(P).checked, (ge) => E(P).checked = ge), F(z, U);
                  }), O(y);
                  var A = H(y, 2), _ = L(A), T = L(_);
                  ht(T), T.__change = [aO, o];
                  var M = H(T);
                  O(_), O(A), ne(
                    (z, P, V, U) => {
                      B(S, z), B(C, P), bp(T, V), B(M, ` ${U ?? ""}`);
                    },
                    [
                      () => I("Properties for style attributes"),
                      () => I("Select the properties you want to keep in the pasted HTML. Unselected properties will be removed."),
                      () => E(o).every((z) => z.checked),
                      () => I("Select All")
                    ]
                  ), F(v, x);
                };
                st(m, (v) => {
                  E(o).length > 0 && v(g);
                });
              }
              O(h), F(d, h);
            },
            footer: (d, f) => {
              var h = pO(), p = Re(h);
              p.__click = () => {
                const v = E(o).filter((S) => !S.checked).map((S) => S.name), x = t().cloneNode(!0);
                x.querySelectorAll("[style]").forEach((S) => {
                  const k = S.style;
                  for (let C = k.length - 1; C >= 0; C--) {
                    const y = k[C];
                    v.includes(y) && k.removeProperty(y);
                  }
                });
                const w = E(s).filter((S) => !S.checked).map((S) => S.name);
                x.body.querySelectorAll("*").forEach((S) => {
                  const k = S.dataset;
                  for (const C in k)
                    w.includes(C) && delete S.dataset[C];
                }), i()(x), l();
              };
              var b = L(p, !0);
              O(p);
              var m = H(p, 2);
              m.__click = l;
              var g = L(m, !0);
              O(m), ne(
                (v, x, w, S) => {
                  Ae(p, "title", v), B(b, x), Ae(m, "title", w), B(g, S);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(d, h);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (c) => a = c,
    () => a
  ), xe({
    get htmlDocument() {
      return t();
    },
    set htmlDocument(c) {
      t(c), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(c) {
      i(c), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(c) {
      r(c), ee();
    }
  });
}
Ot(["change", "click"]);
ve(K0, { htmlDocument: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const gO = (n) => class extends co(n) {
  isEditorItemAvailable() {
    var e;
    return !!((e = this.content) != null && e.htmlDocument);
  }
};
var _O = Z("<button> </button>");
function q0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", o);
  const { tiptap: i } = t;
  let r = null;
  const s = (u = null) => {
    var d;
    i && (u ?? (u = (d = t.content) == null ? void 0 : d.htmlDocument), t.insertContent(_r((u == null ? void 0 : u.body.innerHTML) ?? "")), a());
  };
  t.onEditorPaste = s;
  function o(u) {
    i && (u.stopPropagation(), r ? a() : r = Nt(K0, {
      target: document.body,
      props: {
        htmlDocument: t.content.htmlDocument,
        onSubmit: s,
        onClose: () => {
          a();
        }
      }
    }));
  }
  function a() {
    r && (at(r), r = null);
  }
  $e(() => a);
  var l = _O(), c = L(l, !0);
  O(l), ne((u) => B(c, u), [() => `${I("Paste as HTML")}...`]), F(n, l), xe();
}
ve(q0, {}, [], [], !0, gO);
const bO = (n) => class extends co(n) {
  isEditorItemAvailable() {
    var e;
    return /^https?:\/\/[^\s]+(\s*)?$/.test(((e = this.content) == null ? void 0 : e.plainText) ?? "");
  }
};
var vO = Z("<button> </button>");
function G0(n, e) {
  ye(e, !0);
  const t = e.$$host, { editor: i, tiptap: r } = t;
  let s = null;
  const o = (d = void 0) => {
    var p, b;
    const f = t.content;
    if (!f || !r)
      return;
    d ?? (d = {
      url: f.plainText,
      text: f.plainText,
      title: "",
      target: ((b = (p = i == null ? void 0 : i.options.toolbarOptions) == null ? void 0 : p.link) == null ? void 0 : b.defaultTarget) || "_self"
    });
    const h = document.createElement("a");
    h.href = d.url, d.title && (h.title = d.title), h.target = d.target, h.textContent = d.text, t.insertContent(h.outerHTML), l();
  };
  t.onEditorPaste = o;
  const a = (d) => {
    var f, h;
    r && (d.stopPropagation(), s ? l() : s = Nt(Dd, {
      target: document.body,
      props: {
        linkData: {
          url: t.content.plainText,
          text: t.content.plainText,
          title: "",
          target: ((h = (f = i == null ? void 0 : i.options.toolbarOptions) == null ? void 0 : f.link) == null ? void 0 : h.defaultTarget) || "_self"
        },
        onSubmit: o,
        onClose: () => {
          l();
        }
      }
    }));
  };
  t.addEventListener("click", a);
  const l = () => {
    s && (at(s), s = null);
  };
  $e(() => l);
  var c = vO(), u = L(c, !0);
  O(c), ne((d) => B(u, d), [() => I("Paste as link")]), F(n, c), xe();
}
ve(G0, {}, [], [], !0, bO);
const Oc = {}, kl = async ({
  embedData: n,
  tiptap: e,
  editor: t
}) => {
  var i;
  return e && t ? await (Oc[i = `${n.url}-${n.maxwidth}-${n.maxheight}`] || (Oc[i] = e.commands.getEmbedObject(n))).catch((r) => (t.notify({
    level: "error",
    message: I("Failed to get embed object: ", r.toString())
  }), {
    html: "",
    inline: void 0
  })) : {
    html: "",
    inline: void 0
  };
};
var yO = Z('<div class="form-group mb-3"><label for="embed-url" class="form-label"> </label> <input type="url" id="embed-url" class="form-control"></div> <div class="form-group mb-3"><label for="embed-maxwidth" class="form-label"> </label> <input type="number" id="embed-maxwidth" class="form-control"></div> <div class="form-group mb-3"><label for="embed-maxheight" class="form-label"> </label> <input type="number" id="embed-maxheight" class="form-control"></div>', 1), xO = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function J0(n, e) {
  ye(e, !0);
  let t = Q(e, "embedData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().url)), o = ce(Fe(t().maxwidth)), a = ce(Fe(t().maxheight)), l;
  $e(() => {
    l == null || l.focus();
  });
  let c, u;
  return et(
    An(n, {
      $$events: {
        close(...d) {
          var f;
          (f = r()) == null || f.apply(this, d);
        }
      },
      children: (d, f) => {
        Mn(d, {
          get close() {
            return u;
          },
          set close(h) {
            u = h;
          },
          $$slots: {
            title: (h, p) => {
              var b = Cn();
              ne((m) => B(b, m), [() => I("oEmbed")]), F(h, b);
            },
            body: (h, p) => {
              var b = yO(), m = Re(b), g = L(m), v = L(g, !0);
              O(g);
              var x = H(g, 2);
              ht(x), et(x, (M) => l = M, () => l), O(m);
              var w = H(m, 2), S = L(w), k = L(S, !0);
              O(S);
              var C = H(S, 2);
              ht(C), O(w);
              var y = H(w, 2), A = L(y), _ = L(A, !0);
              O(A);
              var T = H(A, 2);
              ht(T), O(y), ne(
                (M, z, P) => {
                  B(v, M), B(k, z), B(_, P);
                },
                [
                  () => I("URL"),
                  () => I("Width"),
                  () => I("Height")
                ]
              ), kt(x, () => E(s), (M) => q(s, M)), kt(C, () => E(o), (M) => q(o, M)), kt(T, () => E(a), (M) => q(a, M)), F(h, b);
            },
            footer: (h, p) => {
              var b = xO(), m = Re(b);
              m.__click = () => {
                i()({
                  url: E(s),
                  maxwidth: E(o),
                  maxheight: E(a)
                }), u();
              };
              var g = L(m, !0);
              O(m);
              var v = H(m, 2);
              v.__click = u;
              var x = L(v, !0);
              O(v), ne(
                (w, S, k, C) => {
                  Ae(m, "title", w), B(g, S), Ae(v, "title", k), B(x, C);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(h, b);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (d) => c = d,
    () => c
  ), xe({
    get embedData() {
      return t();
    },
    set embedData(d) {
      t(d), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(d) {
      i(d), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(d) {
      r(d), ee();
    }
  });
}
Ot(["click"]);
ve(J0, { embedData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
const wO = (n) => class extends co(n) {
  async isEditorItemAvailable() {
    var r, s;
    const e = ((r = this.content) == null ? void 0 : r.plainText) || "";
    if (!/^https?:\/\/[^\s]+(\s*)?$/.test(e))
      return !1;
    const t = await kl({
      embedData: { url: e, maxwidth: 0, maxheight: 0 },
      tiptap: this.tiptap,
      editor: this.editor
    });
    if (!(t != null && t.html))
      return !1;
    const i = (s = this.content) == null ? void 0 : s.targetDomNode;
    return i instanceof HTMLElement && (i == null ? void 0 : i.tagName) === "P" && i.childNodes.length === 0 ? Ir.Priority.High : Ir.Priority.Default;
  }
};
var kO = Z("<button> </button>");
function X0(n, e) {
  ye(e, !0);
  const t = e.$$host;
  t.addEventListener("click", a);
  const { editor: i, tiptap: r } = t;
  let s = null;
  const o = async (d = void 0) => {
    var p, b;
    const f = t.content;
    if (!f || !r)
      return;
    d ?? (d = {
      url: f.plainText,
      maxwidth: 0,
      maxheight: 0
    });
    const h = await kl({ embedData: d, tiptap: t.tiptap, editor: i });
    h.html && ((p = t.content) == null || p.transaction(() => {
      r.chain().undo().focus().run(), r.commands.insertEmbedObject(h.html);
    }), (b = t.parentElement) == null || b.dispatchEvent(new Event("paste-menu-item-applied")), l());
  };
  t.onEditorPaste = o;
  function a(d) {
    r && (d.stopPropagation(), s ? l() : s = Nt(J0, {
      target: document.body,
      props: {
        embedData: { url: t.content.plainText },
        onSubmit: o,
        onClose: () => {
          l();
        }
      }
    }));
  }
  function l() {
    s && (at(s), s = null);
  }
  $e(() => l);
  var c = kO(), u = L(c, !0);
  O(c), ne((d) => B(u, d), [() => I("Embed object")]), F(n, c), xe();
}
ve(X0, {}, [], [], !0, wO);
const SO = (n) => class extends co(n) {
  async isEditorItemAvailable() {
    var i;
    const e = ((i = this.content) == null ? void 0 : i.plainText) || "";
    return /^https?:\/\/[^\s]+(\s*)?$/.test(e) ? !!(await kl({
      embedData: { url: e, maxwidth: 0, maxheight: 0 },
      tiptap: this.tiptap,
      editor: this.editor
    })).inline : !1;
  }
};
var CO = Z("<button> </button>");
function Y0(n, e) {
  ye(e, !0);
  const t = e.$$host, i = () => {
    const o = t.content;
    o && kl({
      embedData: {
        url: o.plainText,
        maxwidth: 0,
        maxheight: 0
      },
      tiptap: t.tiptap,
      editor: t.editor
    }).then((a) => {
      const l = a.inline;
      l && t.insertContent(l);
    });
  };
  t.onEditorPaste = i, t.addEventListener("click", i);
  var r = CO(), s = L(r, !0);
  O(r), ne((o) => B(s, o), [() => I("Embed inline")]), F(n, r), xe();
}
ve(Y0, {}, [], [], !0, SO);
const TO = (n) => class extends co(n) {
  isEditorItemAvailable() {
    var e, t, i;
    return (e = this.tiptap) != null && e.commands.isMarkdownConversionAvailable() && (((t = this.content) == null ? void 0 : t.plainText) ?? "").split(`
`).some((r) => r.startsWith("#") || r.startsWith("```") || /^=+$/.test(r) || /^-+$/.test(r)) ? (i = this.content) != null && i.htmlDocument ? Ir.Priority.Default : Ir.Priority.High : !1;
  }
};
var EO = Z("<button> </button>");
function Z0(n, e) {
  ye(e, !0);
  const t = e.$$host, i = async () => {
    var o, a, l;
    t.insertContent(((l = await ((a = t.tiptap) == null ? void 0 : a.commands.markdownToHtml({ content: ((o = t.content) == null ? void 0 : o.plainText) ?? "" }))) == null ? void 0 : l.content) ?? "");
  };
  t.onEditorPaste = i, t.addEventListener("click", i);
  var r = EO(), s = L(r, !0);
  O(r), ne((o) => B(s, o), [() => I("Convert from Markdown")]), F(n, r), xe();
}
ve(Z0, {}, [], [], !0, TO);
class AO extends Ir {
  constructor() {
    super();
    const e = document.createElement("button");
    e.textContent = I("Paste as text"), this.shadowRoot.appendChild(e);
  }
  onEditorPaste() {
    var t;
    const e = document.createElement("div");
    e.textContent = ((t = this.content) == null ? void 0 : t.plainText) ?? "", this.insertContent(e.innerHTML.replace(/\n/g, "<br>"));
  }
  connectedCallback() {
    this.addEventListener("click", () => {
      this.onEditorPaste();
    });
  }
}
const MO = {
  text: AO,
  // @ts-ignore
  html: q0.element,
  // @ts-ignore
  link: G0.element,
  // @ts-ignore
  embed: X0.element,
  // @ts-ignore
  embedInline: Y0.element,
  // @ts-ignore
  markdown: Z0.element
}, OO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-1">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M19 18v-8l-2 2" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, NO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-2">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M17 12a2 2 0 1 1 4 0c0 .591 -.417 1.318 -.816 1.858l-3.184 4.143l4 0" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, LO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-3">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M19 14a2 2 0 1 0 -2 -2" />
    <path d="M17 16a2 2 0 1 0 2 -2" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, RO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-4">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M20 18v-8l-4 6h5" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, IO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-5">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M17 18h2a2 2 0 1 0 0 -4h-2v-4h4" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, PO = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-h-6">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M19 14a2 2 0 1 0 0 4a2 2 0 0 0 0 -4z" />
    <path d="M21 12a2 2 0 1 0 -4 0v4" />
    <path d="M4 6v12" />
    <path d="M12 6v12" />
    <path d="M11 18h2" />
    <path d="M3 18h2" />
    <path d="M4 12h8" />
    <path d="M3 6h2" />
    <path d="M11 6h2" />
</svg>
`, DO = {
  1: OO,
  2: NO,
  3: LO,
  4: RO,
  5: IO,
  6: PO
};
class $O extends e1 {
  connectedCallback() {
    const e = this.dataset.mtRichTextEditorPanelItemVariant;
    if (!e)
      return;
    this.aliases = [`h${e}`, `heading${e}`];
    const t = document.createElement("button"), i = document.createElement("span");
    i.classList.add("icon"), i.innerHTML = DO[e];
    const r = document.createElement("span");
    r.textContent = I(`Heading ${e}`), t.appendChild(i), t.appendChild(r), this.shadowRoot.appendChild(t), this.addEventListener("click", () => {
      this.insertContent(`<h${e}></h${e}>`);
    });
  }
}
const BO = {
  heading: $O
}, zO = {
  toolbar: nO,
  statusbar: oO,
  "paste-menu": MO,
  "quick-action": BO
}, Jr = (n, e) => {
  const t = e.toLowerCase();
  if (t.includes("-") && window.customElements.get(t))
    return t;
  const i = `mt-rich-text-editor-${n}-item-${t}`;
  let r = window.customElements.get(i);
  if (!r) {
    if (r = zO[n][e], !r) {
      console.error(`Item for ${e} is not found`);
      return;
    }
    window.customElements.define(i, r);
  }
  return i;
};
var HO = Z("<div></div>"), FO = Z('<div class="toolbar-side svelte-r5ystd"></div>'), VO = Z('<div class="toolbar-row svelte-r5ystd"></div>'), jO = Z("<div></div>");
const WO = {
  hash: "svelte-r5ystd",
  code: `.toolbar.svelte-r5ystd {display:flex;flex-wrap:wrap;flex-direction:column;}.toolbar-row.svelte-r5ystd {display:flex;justify-content:space-between;border-bottom:1px solid #ccc;}.toolbar-row.svelte-r5ystd:last-child {border-bottom:none;}.toolbar-side.svelte-r5ystd {display:flex;flex-wrap:wrap;}.toolbar-group.svelte-r5ystd {padding:0 4px;}.toolbar-group.svelte-r5ystd:not(:last-child) {border-right:1px solid #ccc;white-space:nowrap;}.toolbar-item.svelte-r5ystd {display:inline-flex;align-items:center;justify-content:center;margin:2px 0 3px;height:34px;}.toolbar-item.is-active.svelte-r5ystd {background:#dee0e2;}

  /**
   * Inline
   */.toolbar--inline.svelte-r5ystd {position:absolute;display:none;z-index:1;border:1px solid #ccc;border-radius:4px;background:#fff;}.toolbar--inline.svelte-r5ystd::before {content:"";position:absolute;z-index:-1;top:50%;left:-8px;width:14px;height:14px;background:#fff;transform:translateY(-50%) rotate(45deg);border-left:1px solid #ccc;border-bottom:1px solid #ccc;box-shadow:-1px 1px 2px rgba(0, 0, 0, 0.03);}.toolbar--inline.svelte-r5ystd:not([data-is-new-line])::before {content:"";position:absolute;z-index:-1;top:-8px;left:20px;width:14px;height:14px;background:#fff;transform:translateX(-50%) rotate(45deg);border-left:1px solid #ccc;border-top:1px solid #ccc;border-bottom:none;box-shadow:-1px -1px 2px rgba(0, 0, 0, 0.03);}`
};
function Q0(n, e) {
  ye(e, !0), Ht(n, WO);
  const t = Q(e, "editor", 7), i = Q(e, "toolbar", 7), r = Q(e, "options", 7), s = Q(e, "inline", 7);
  let o = null;
  const a = {}, l = i().map((f) => f.map((h) => (h || []).map((p) => (p || []).map((b) => ({
    name: b,
    elementName: Jr("toolbar", b),
    options: r()[b] ?? {}
  })).filter((b) => b.elementName && b.options !== !1)).filter((p) => p.length > 0))).filter((f) => f.length > 0);
  function c() {
    for (const f in a)
      "onEditorUpdate" in a[f] && a[f].onEditorUpdate();
  }
  if (t().tiptap.on("selectionUpdate", c), t().tiptap.on("update", c), $e(() => {
    c();
  }), s()) {
    const f = d0(
      () => {
        if (!o)
          return;
        let h = !1, p = !1;
        if (t().tiptap.state.selection.empty) {
          const v = t().tiptap.state.selection.$head.parent;
          h = v.type.name === "paragraph" && v.content.size === 0, p = !0;
        } else
          h = !0;
        if (!h) {
          o.style.display = "", o.style.transition = "";
          return;
        }
        o.style.display === "" && (o.style.display = "block", setTimeout(
          () => {
            o && (o.style.transition = "left 0.2s ease-in-out");
          },
          100
        ));
        const b = t().tiptap.view.dom.getBoundingClientRect(), { selection: m } = t().tiptap.view.state, g = t().tiptap.view.coordsAtPos(m.$to.pos);
        if (p)
          o.style.top = `${g.bottom - b.top - 30}px`, o.style.left = `${g.left - b.left + 20}px`, o.setAttribute("data-is-new-line", "true");
        else {
          const v = t().tiptap.view.coordsAtPos(m.$from.pos), x = v.left < g.left ? v : g;
          o.style.top = `${x.bottom - b.top + 15}px`, o.style.left = `${x.left - b.left}px`, o.removeAttribute("data-is-new-line");
        }
      },
      50
    );
    t().tiptap.on("selectionUpdate", f), f();
  }
  function u(f, h) {
    return a[h] = f, "onEditorInit" in f && f.onEditorInit(t(), (r()[h] || void 0) ?? {}), {
      destroy() {
        delete a[h];
      }
    };
  }
  var d = jO();
  return ft(d, 21, () => l, kn, (f, h) => {
    var p = VO();
    ft(p, 21, () => E(h), kn, (b, m) => {
      var g = FO();
      ft(g, 21, () => E(m), kn, (v, x) => {
        var w = HO();
        ft(w, 21, () => E(x), kn, (S, k) => {
          var C = wi(), y = Re(C);
          Gr(y, () => E(k).elementName, !1, (A, _) => {
            St(A, (T, M) => u == null ? void 0 : u(T, M), () => E(k).name), pt(A, 0, "toolbar-item svelte-r5ystd");
          }), F(S, C);
        }), O(w), ne(() => pt(w, 1, `toolbar-group ${E(x).length === 1 ? `toolbar-group--${E(x)[0].name}` : ""}`, "svelte-r5ystd")), F(v, w);
      }), O(g), F(b, g);
    }), O(p), F(f, p);
  }), O(d), et(d, (f) => o = f, () => o), ne(() => pt(d, 1, `toolbar ${(s() ? "toolbar--inline" : "") ?? ""}`, "svelte-r5ystd")), F(n, d), xe({
    get editor() {
      return t();
    },
    set editor(f) {
      t(f), ee();
    },
    get toolbar() {
      return i();
    },
    set toolbar(f) {
      i(f), ee();
    },
    get options() {
      return r();
    },
    set options(f) {
      r(f), ee();
    },
    get inline() {
      return s();
    },
    set inline(f) {
      s(f), ee();
    }
  });
}
ve(
  Q0,
  {
    editor: {},
    toolbar: {},
    options: {},
    inline: {}
  },
  [],
  [],
  !0
);
var Cr;
class UO {
  constructor({ target: e, editor: t, toolbar: i, options: r, inline: s }) {
    Le(this, Cr);
    !i || i.length === 0 || Oe(this, Cr, Nt(Q0, {
      target: e,
      props: {
        editor: t,
        toolbar: i,
        inline: s,
        options: r
      }
    }));
  }
  destroy() {
    G(this, Cr) && at(G(this, Cr));
  }
}
Cr = new WeakMap();
var KO = Z('<div class="statusbar-side svelte-1axc334"></div>'), qO = Z('<div class="statusbar svelte-1axc334"></div>');
const GO = {
  hash: "svelte-1axc334",
  code: ".statusbar.svelte-1axc334 {display:flex;flex-wrap:wrap;justify-content:space-between;}.statusbar-side.svelte-1axc334 {display:flex;flex-wrap:wrap;}.statusbar-item.svelte-1axc334 {display:inline-flex;align-items:center;margin:2px 0 3px;border:none;background:none;border-radius:4px;padding:1px 5px;}"
};
function eb(n, e) {
  ye(e, !0), Ht(n, GO);
  const t = Q(e, "editor", 7), i = Q(e, "statusbar", 7), r = Q(e, "options", 7), s = {}, o = i().map((u) => (u || []).map((d) => ({
    name: d,
    elementName: Jr("statusbar", d),
    options: r()[d] ?? {}
  })).filter((d) => d.elementName && d.options !== !1));
  function a() {
    for (const u in s)
      "onEditorUpdate" in s[u] && s[u].onEditorUpdate();
  }
  t().tiptap.on("selectionUpdate", a), t().tiptap.on("update", a), $e(() => {
    a();
  });
  function l(u, d) {
    return s[d] = u, "onEditorInit" in u && u.onEditorInit(t(), r()[d] ?? {}), {
      destroy() {
        delete s[d];
      }
    };
  }
  var c = qO();
  return ft(c, 21, () => o, kn, (u, d) => {
    var f = KO();
    ft(f, 21, () => E(d), kn, (h, p) => {
      var b = wi(), m = Re(b);
      Gr(m, () => E(p).elementName, !1, (g, v) => {
        St(g, (x, w) => l == null ? void 0 : l(x, w), () => E(p).name), pt(g, 0, "statusbar-item svelte-1axc334");
      }), F(h, b);
    }), O(f), F(u, f);
  }), O(c), F(n, c), xe({
    get editor() {
      return t();
    },
    set editor(u) {
      t(u), ee();
    },
    get statusbar() {
      return i();
    },
    set statusbar(u) {
      i(u), ee();
    },
    get options() {
      return r();
    },
    set options(u) {
      r(u), ee();
    }
  });
}
ve(eb, { editor: {}, statusbar: {}, options: {} }, [], [], !0);
var Tr;
class JO {
  constructor({ target: e, editor: t, statusbar: i, options: r, inline: s }) {
    Le(this, Tr);
    s || i.length === 0 || Oe(this, Tr, Nt(eb, {
      target: e,
      props: {
        editor: t,
        statusbar: i,
        inline: s,
        options: r
      }
    }));
  }
  destroy() {
    G(this, Tr) && at(G(this, Tr));
  }
}
Tr = new WeakMap();
const XO = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-clipboard">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" />
    <path d="M9 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v0a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z" />
</svg>
`;
var YO = (n, e) => q(e, !E(e)), ZO = Z("<div><!></div>"), QO = Z('<div class="paste-menu svelte-19f323f"><button type="button"><!></button> <div class="paste-menu-list svelte-19f323f"></div></div>');
const e3 = {
  hash: "svelte-19f323f",
  code: '.paste-menu.svelte-19f323f {position:absolute;z-index:1;}.paste-menu-icon.svelte-19f323f {background:none;border:1px solid #ccc;border-radius:4px;padding:2px;margin:0;cursor:pointer;display:flex;align-items:center;justify-content:center;background:#fff;}.paste-menu-icon.svelte-19f323f:after {content:"";display:block;margin:0 2px;width:6px;height:6px;border-right:1px solid #000;border-bottom:1px solid #000;transform:rotate(45deg);margin-top:-3px;}.paste-menu-icon.svelte-19f323f:hover {background:#f0f0f0;}.paste-menu-icon.is-active.svelte-19f323f {border-bottom:0;border-bottom-left-radius:0;border-bottom-right-radius:0;position:relative;z-index:1;background:#fff;}.paste-menu.svelte-19f323f {display:flex;flex-wrap:wrap;flex-direction:column;}.paste-menu-list.svelte-19f323f {display:flex;flex-wrap:wrap;border:1px solid #ccc;border-radius:4px;border-top-left-radius:0;margin-top:-1px;background:#fff;}.paste-menu-item-container.svelte-19f323f {position:relative;}.paste-menu-item-container.is-applied.svelte-19f323f::before {content:"";position:absolute;left:10px;top:50%;transform:translateY(-50%);}'
};
function tb(n, e) {
  ye(e, !0), Ht(n, e3);
  function t(_) {
    const T = _.getData("text/plain") || _.getData("Text");
    if (T)
      return T;
    const M = _.getData("text/uri-list");
    return M ? M.replace(/\r?\n/g, " ") : void 0;
  }
  const i = Q(e, "editor", 7), r = Q(e, "onPaste", 7), s = Q(e, "pasteMenu", 7), o = Q(e, "options", 7), a = Q(e, "setIsPasting", 7), l = {}, c = s().map((_) => ({
    name: _,
    elementName: Jr("paste-menu", _),
    options: o()[_] ?? {}
  })).filter((_) => _.elementName && _.options !== !1);
  let u = ce(!1), d = ce(!1), f = !1, h = ce(0), p = ce(0), b = null;
  const m = ce(Fe({}));
  $e(() => {
    a()(E(u));
  }), i().tiptap.on("update", () => {
    f || q(u, !1);
  });
  const g = (_, T = !1) => {
    const M = _.dom.getBoundingClientRect(), { selection: z } = _.state, P = z.$to.pos, V = _.nodeDOM(z.$from.pos - 2);
    if (!V) {
      const J = _.coordsAtPos(P), re = J.bottom - M.top;
      (E(h) < re || E(h) - re > 100) && q(h, re);
      const te = J.left - M.left;
      E(p) !== 0 && E(p) > te && q(p, te);
      return;
    }
    const U = (J = void 0) => {
      if (!V.parentElement) {
        J == null || J.disconnect();
        return;
      }
      const re = V.getBoundingClientRect(), te = re.bottom - M.top, ge = te > M.height - 20 ? M.height - 20 : te;
      (T || E(h) < ge || E(h) - ge > 100) && q(h, ge, !0);
      const se = re.left - M.left;
      (T || E(p) > se) && q(p, se);
    };
    if (U(), !T) {
      const J = new ResizeObserver(() => {
        U(J);
      });
      J.observe(V), setTimeout(
        () => {
          J.disconnect();
        },
        1e4
      );
    }
  }, v = (_, T = !1) => {
    try {
      g(_, T);
    } catch {
    }
  };
  i().tiptap.view.dom.addEventListener("scroll", () => {
    E(u) && v(i().tiptap.view, !0);
  });
  let x = ce("");
  r()((_, T) => {
    var J, re;
    i().tiptap.commands.undo(), i().tiptap.commands.redo();
    const M = (re = (J = _.domAtPos(i().tiptap.state.selection.from)) == null ? void 0 : J.node) == null ? void 0 : re.cloneNode(!0);
    if (M instanceof HTMLElement && M.querySelectorAll("br.ProseMirror-trailingBreak").forEach((te) => {
      te.remove();
    }), !T.clipboardData)
      return !1;
    const z = T.clipboardData, P = t(z), V = z.getData("text/html");
    let U = null;
    return V && (U = new DOMParser().parseFromString(V, "text/html")), (async () => {
      q(h, 0), q(p, P != null && P.includes(`
`) ? 0 : 9999, !0);
      const te = {};
      c.forEach(({ name: se }) => {
        var fe;
        const Be = l[se];
        "onEditorSetPasteContent" in Be && ((fe = Be.onEditorSetPasteContent) == null || fe.call(Be, {
          plainText: P ?? (U == null ? void 0 : U.body.innerText) ?? "",
          htmlDocument: U,
          targetDomNode: M,
          clipboardData: z,
          transaction: async (Je) => {
            f = !0;
            try {
              await Je();
            } finally {
              f = !1, v(_);
            }
          }
        })), "isEditorItemAvailable" in Be && (te[se] = Be.isEditorItemAvailable());
      }), await Promise.all(Object.values(te));
      let ge = 0;
      q(x, "");
      for (const { name: se } of c) {
        const Be = await te[se];
        E(m)[se] = Be === !0 ? 1 : Be === !1 ? 0 : Be, E(m)[se] > ge && (ge = E(m)[se], q(x, se, !0));
      }
      if (E(x)) {
        a()(!0);
        const se = l[E(x)];
        "onEditorPaste" in se && se.onEditorPaste();
      }
      setTimeout(() => {
        Object.values(E(m)).filter(Boolean).length <= 1 || (q(u, !0), v(_));
      });
    })(), !1;
  });
  const w = (_, T) => (l[T] = _, "onEditorInit" in _ && _.onEditorInit(i(), o()[T] ?? {}), {
    destroy() {
      delete l[T];
    }
  }), S = (_) => {
    document.body.classList.contains("modal-open") || b && _.composedPath().includes(b) || q(d, !1);
  };
  $e(() => (E(d) && document.addEventListener("click", S), () => {
    document.removeEventListener("click", S);
  }));
  var k = QO(), C = L(k);
  C.__click = [YO, d];
  var y = L(C);
  qt(y, () => XO), O(C);
  var A = H(C, 2);
  return ft(A, 21, () => c, (_) => _.name, (_, T) => {
    var M = ZO();
    let z;
    var P = L(M);
    Gr(P, () => E(T).elementName, !1, (V, U) => {
      St(V, (re, te) => w == null ? void 0 : w(re, te), () => E(T).name);
      let J;
      ne(() => J = o0(V, J, {
        class: "paste-menu-item",
        style: `display: ${E(m)[E(T).name] ? "block" : "none"};`
      }));
    }), O(M), ne((V) => z = pt(M, 1, "paste-menu-item-container svelte-19f323f", null, z, V), [
      () => ({
        "is-applied": E(x) === E(T).name
      })
    ]), dt("paste-menu-item-applied", M, () => {
      q(x, E(T).name, !0);
    }), F(_, M);
  }), O(A), O(k), et(k, (_) => b = _, () => b), ne(() => {
    qs(k, `
    display: ${E(u) ? "block" : "none"};
    z-index: 1000;
    top: ${E(h)}px;
    left: ${E(p)}px;
    width: max-content;
  `), pt(C, 1, `paste-menu-icon ${E(d) ? "is-active" : ""}`, "svelte-19f323f"), qs(A, `display: ${E(d) ? "block" : "none"};`);
  }), F(n, k), xe({
    get editor() {
      return i();
    },
    set editor(_) {
      i(_), ee();
    },
    get onPaste() {
      return r();
    },
    set onPaste(_) {
      r(_), ee();
    },
    get pasteMenu() {
      return s();
    },
    set pasteMenu(_) {
      s(_), ee();
    },
    get options() {
      return o();
    },
    set options(_) {
      o(_), ee();
    },
    get setIsPasting() {
      return a();
    },
    set setIsPasting(_) {
      a(_), ee();
    }
  });
}
Ot(["click"]);
ve(
  tb,
  {
    editor: {},
    onPaste: {},
    pasteMenu: {},
    options: {},
    setIsPasting: {}
  },
  [],
  [],
  !0
);
var Er, Gs;
class t3 {
  constructor({ target: e, editor: t, onPaste: i, pasteMenu: r, options: s }) {
    Le(this, Er);
    Le(this, Gs, !1);
    r.length !== 0 && Oe(this, Er, Nt(tb, {
      target: e,
      props: {
        editor: t,
        onPaste: i,
        pasteMenu: r,
        options: s,
        setIsPasting: (o) => {
          Oe(this, Gs, o);
        }
      }
    }));
  }
  isPasting() {
    return G(this, Gs);
  }
  destroy() {
    G(this, Er) && at(G(this, Er));
  }
}
Er = new WeakMap(), Gs = new WeakMap();
var n3 = Z("<div><!></div>"), i3 = Z('<div class="mt-rich-text-editor-quick-action svelte-182x144"></div>');
const r3 = {
  hash: "svelte-182x144",
  code: `.mt-rich-text-editor-quick-action.svelte-182x144 {position:absolute;z-index:1;border:1px solid #ccc;border-radius:4px;background:#fff;display:none;}.mt-rich-text-editor-quick-action-button.svelte-182x144 {padding:10px;display:block;&.selected,
    &:hover {background:#f0f0f0;}}`
};
function nb(n, e) {
  ye(e, !0), Ht(n, r3);
  const t = Q(e, "editor", 7), i = Q(e, "quickAction", 7), r = Q(e, "options", 7), s = {}, o = i().map((m) => {
    const [g, v] = m.split(":");
    return {
      name: m,
      variant: v,
      elementName: Jr("quick-action", g),
      aliases: [v],
      options: r()[m] ?? {}
    };
  }).filter((m) => m.elementName && m.options !== !1);
  let a = ce("");
  const l = ta(() => E(a) ? o.filter((m) => m.aliases.some((g) => g.startsWith(E(a)))) : o), c = ta(() => E(l).length);
  let u = ce(0);
  $e(() => {
    E(c) > 0 && q(u, 0);
  });
  let d = !1, f = null;
  const h = d0(
    () => {
      var x, w;
      if (!f)
        return;
      if (d = !1, t().tiptap.state.selection.empty) {
        const S = t().tiptap.state.selection.$head.parent;
        d = S.type.name === "paragraph" && ((x = S.textContent) == null ? void 0 : x.startsWith("/")), d && q(a, (w = S.textContent) == null ? void 0 : w.slice(1), !0);
      }
      if (!d) {
        f.style.display = "", f.style.transition = "";
        return;
      }
      f.style.display === "" && (f.style.display = "block", setTimeout(
        () => {
          f && (f.style.transition = "left 0.2s ease-in-out");
        },
        100
      ));
      const m = t().tiptap.view.dom.getBoundingClientRect(), { selection: g } = t().tiptap.view.state, v = t().tiptap.view.coordsAtPos(g.$to.pos);
      f.style.top = `${v.bottom - m.top + 10}px`, f.style.left = "0px";
    },
    50
  );
  $e(() => {
    t().tiptap.on("selectionUpdate", h), h(), t().tiptap.view.dom.addEventListener(
      "keydown",
      (m) => {
        d && (m.key === "Enter" ? (m.preventDefault(), m.stopPropagation(), m.stopImmediatePropagation(), s[E(l)[E(u)].name].click()) : m.key === "ArrowDown" ? (m.preventDefault(), m.stopPropagation(), m.stopImmediatePropagation(), q(u, (E(u) + 1) % E(l).length)) : m.key === "ArrowUp" && (m.preventDefault(), m.stopPropagation(), m.stopImmediatePropagation(), q(u, (E(u) - 1 + E(l).length) % E(l).length)));
      },
      { capture: !0 }
    );
  });
  function p(m, g) {
    if (s[g] = m, "onEditorInit" in m && m.onEditorInit(t(), r()[g] ?? {}), "aliases" in m) {
      const v = o.find((x) => x.name === g);
      v && (v.aliases = m.aliases);
    }
    return {
      destroy() {
        delete s[g];
      }
    };
  }
  var b = i3();
  return ft(b, 23, () => E(l), (m) => m.name, (m, g, v) => {
    var x = n3(), w = L(x);
    Gr(w, () => E(g).elementName, !1, (S, k) => {
      St(S, (y, A) => p == null ? void 0 : p(y, A), () => E(g).name);
      let C;
      ne(() => C = o0(S, C, {
        "data-mt-rich-text-editor-panel-item-variant": E(g).variant
      }));
    }), O(x), ne(() => pt(x, 1, `mt-rich-text-editor-quick-action-button ${(E(v) === E(u) ? "selected" : "") ?? ""}`, "svelte-182x144")), F(m, x);
  }), O(b), et(b, (m) => f = m, () => f), F(n, b), xe({
    get editor() {
      return t();
    },
    set editor(m) {
      t(m), ee();
    },
    get quickAction() {
      return i();
    },
    set quickAction(m) {
      i(m), ee();
    },
    get options() {
      return r();
    },
    set options(m) {
      r(m), ee();
    }
  });
}
ve(nb, { editor: {}, quickAction: {}, options: {} }, [], [], !0);
var Ar;
class s3 {
  constructor({ target: e, editor: t, quickAction: i, options: r }) {
    Le(this, Ar);
    i.length !== 0 && Oe(this, Ar, Nt(nb, {
      target: e,
      props: {
        editor: t,
        quickAction: i,
        options: r
      }
    }));
  }
  destroy() {
    G(this, Ar) && at(G(this, Ar));
  }
}
Ar = new WeakMap();
var o3 = Z('<div class="form-group mb-3"><label for="structure-id" class="form-label"> </label> <input type="text" id="structure-id" class="form-control"></div> <div class="form-group mb-3"><label for="structure-class-name" class="form-label"> </label> <input type="text" id="structure-class-name" class="form-control"></div> <div class="form-group mb-3"><label for="structure-style" class="form-label"> </label> <input type="text" id="structure-style" class="form-control"></div>', 1), a3 = Z('<button type="button" class="action primary button btn btn-primary"> </button> <button type="button" class="cancel action button mt-close-dialog btn btn-default"> </button>', 1);
function ib(n, e) {
  ye(e, !0);
  let t = Q(e, "structureData", 7), i = Q(e, "onSubmit", 7), r = Q(e, "onClose", 7), s = ce(Fe(t().id)), o = ce(Fe(t().className)), a = ce(Fe(t().style)), l;
  $e(() => {
    l == null || l.focus();
  });
  let c, u;
  return et(
    An(n, {
      $$events: {
        close(...d) {
          var f;
          (f = r()) == null || f.apply(this, d);
        }
      },
      children: (d, f) => {
        Mn(d, {
          get close() {
            return u;
          },
          set close(h) {
            u = h;
          },
          $$slots: {
            title: (h, p) => {
              var b = Cn();
              ne((m) => B(b, m), [() => I("Edit attributes")]), F(h, b);
            },
            body: (h, p) => {
              var b = o3(), m = Re(b), g = L(m), v = L(g, !0);
              O(g);
              var x = H(g, 2);
              ht(x), et(x, (M) => l = M, () => l), O(m);
              var w = H(m, 2), S = L(w), k = L(S, !0);
              O(S);
              var C = H(S, 2);
              ht(C), O(w);
              var y = H(w, 2), A = L(y), _ = L(A, !0);
              O(A);
              var T = H(A, 2);
              ht(T), O(y), ne(
                (M, z, P) => {
                  B(v, M), B(k, z), B(_, P);
                },
                [
                  () => I("ID"),
                  () => I("Class name"),
                  () => I("Style")
                ]
              ), kt(x, () => E(s), (M) => q(s, M)), kt(C, () => E(o), (M) => q(o, M)), kt(T, () => E(a), (M) => q(a, M)), F(h, b);
            },
            footer: (h, p) => {
              var b = a3(), m = Re(b);
              m.__click = () => {
                i()({
                  id: E(s),
                  className: E(o),
                  style: E(a)
                }), u();
              };
              var g = L(m, !0);
              O(m);
              var v = H(m, 2);
              v.__click = u;
              var x = L(v, !0);
              O(v), ne(
                (w, S, k, C) => {
                  Ae(m, "title", w), B(g, S), Ae(v, "title", k), B(x, C);
                },
                [
                  () => I("Insert (s)"),
                  () => I("Insert"),
                  () => I("Cancel (x)"),
                  () => I("Cancel")
                ]
              ), F(h, b);
            }
          }
        });
      },
      $$slots: { default: !0 }
    }),
    (d) => c = d,
    () => c
  ), xe({
    get structureData() {
      return t();
    },
    set structureData(d) {
      t(d), ee();
    },
    get onSubmit() {
      return i();
    },
    set onSubmit(d) {
      i(d), ee();
    },
    get onClose() {
      return r();
    },
    set onClose(d) {
      r(d), ee();
    }
  });
}
Ot(["click"]);
ve(ib, { structureData: {}, onSubmit: {}, onClose: {} }, [], [], !0);
var Gt, Mr, Pi, Di, Jt, Js;
class l3 {
  constructor(e) {
    Le(this, Gt);
    Le(this, Mr);
    Le(this, Pi);
    Le(this, Di);
    Le(this, Jt, null);
    Le(this, Js, "section, div, p, ul, ol, li, h1, h2, h3, h4, h5, h6");
    Oe(this, Gt, e), Oe(this, Mr, this.onUpdate.bind(this)), Oe(this, Di, (t) => {
      const i = t.currentTarget;
      if (t.target !== i)
        return;
      const r = i.getBoundingClientRect();
      t.clientY - r.top > 13 || Oe(this, Jt, Nt(ib, {
        target: document.body,
        props: {
          structureData: {
            id: i.id,
            className: i.className,
            style: i.style.cssText
          },
          onSubmit: (s) => {
            const o = G(this, Gt).tiptap.view.posAtDOM(i, 0), a = G(this, Gt).tiptap.state.doc.nodeAt(o - 1);
            if (!a)
              return;
            const l = { ...a.attrs.MTRichTextEditorHTMLAttributes }, c = {
              className: "class"
            };
            ["id", "className", "style"].forEach((d) => {
              l[c[d] ?? d] = s[d] || void 0;
            });
            const u = G(this, Gt).tiptap.state.tr.setNodeAttribute(
              o - 1,
              "MTRichTextEditorHTMLAttributes",
              l
            );
            G(this, Gt).tiptap.view.dispatch(u), G(this, Jt) && (at(G(this, Jt)), Oe(this, Jt, null));
          },
          onClose: () => {
            G(this, Jt) && (at(G(this, Jt)), Oe(this, Jt, null));
          }
        }
      }));
    }), Oe(this, Pi, document.createElement("style")), G(this, Gt).tiptap.view.dom.getRootNode().appendChild(G(this, Pi)), G(this, Gt).tiptap.on("update", G(this, Mr)), this.onUpdate();
  }
  onUpdate() {
    let e = "";
    const t = G(this, Gt).tiptap.view.dom.querySelectorAll(G(this, Js));
    for (const i of t) {
      i.removeEventListener("click", G(this, Di)), i.addEventListener("click", G(this, Di));
      const r = `${i.tagName.toLowerCase()}${i.getAttributeNames().map((s) => s === "data-mt-rich-text-editor-id" || !["id", "class", "style"].includes(s) ? "" : `[${s}="${i.getAttribute(s)}"]`).join("")}`;
      e += `${r} {
    outline: 1px solid rgba(0, 0, 0, 0.2);
    padding: 0.5rem;
    margin: 1rem 0;
    border-radius: 0.5rem;
    position: relative;
    &:before {
      content: "${r.replace(/"/g, '\\"')}";
      position: absolute;
      top: -0.8rem;
      left: 0.5rem;
      display: block;
      background-color: #fff;
      padding: 0 0.5rem;
      font-weight: normal;
      font-size: 1rem;
      cursor: pointer;
    }
  }
      `;
    }
    G(this, Pi).textContent = e;
  }
  destroy() {
    const e = G(this, Gt).tiptap.view.dom.querySelectorAll(G(this, Js));
    for (const t of e)
      t.removeEventListener("click", G(this, Di));
    G(this, Pi).remove(), G(this, Jt) && (at(G(this, Jt)), Oe(this, Jt, null)), G(this, Gt).tiptap.off("update", G(this, Mr));
  }
}
Gt = new WeakMap(), Mr = new WeakMap(), Pi = new WeakMap(), Di = new WeakMap(), Jt = new WeakMap(), Js = new WeakMap();
const Nc = async (n, e) => {
  for (let t of e)
    if (t) {
      if (/^blob:/.test(t))
        try {
          t = await (await fetch(t)).text();
        } catch (i) {
          console.error(i);
          continue;
        }
      else !/^https?:/.test(t) && /\.css$/i.test(t) && (t = new URL(t, window.location.href).href);
      if (/^https?:/.test(t)) {
        const i = document.createElement("link");
        i.rel = "stylesheet", i.href = t, n.appendChild(i);
      } else {
        const i = document.createElement("style");
        i.textContent = t, n.appendChild(i);
      }
    }
}, c3 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror pre {
  white-space: pre-wrap;
}

.ProseMirror li {
  position: relative;
}

.ProseMirror-hideselection *::selection { background: transparent; }
.ProseMirror-hideselection *::-moz-selection { background: transparent; }
.ProseMirror-hideselection { caret-color: transparent; }

/* See https://github.com/ProseMirror/prosemirror/issues/1421#issuecomment-1759320191 */
.ProseMirror [draggable][contenteditable=false] { user-select: text }

.ProseMirror-selectednode {
  outline: 2px solid #8cf;
}

/* Make sure li selections wrap around markers */

li.ProseMirror-selectednode {
  outline: none;
}

li.ProseMirror-selectednode:after {
  content: "";
  position: absolute;
  left: -32px;
  right: -2px; top: -2px; bottom: -2px;
  border: 2px solid #8cf;
  pointer-events: none;
}

/* Protect against generic img rules */

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
}
`, zp = `.tiptap{overflow:auto}.mt-rich-text-editor-editor{border:1px solid #ccc;border-radius:4px;display:flex;flex-direction:column;height:100%;position:relative;background:#fff}.mt-rich-text-editor-editor--fullscreen{position:fixed;top:-1px;left:0;width:100%;z-index:10000}.mt-rich-text-editor-content{position:relative}.mt-rich-text-editor-content-root,.mt-rich-text-editor-content-root>.tiptap{height:calc(100% - 10px)}.mt-rich-text-editor-content-root>.tiptap{padding:10px;outline:none}.mt-rich-text-editor-content-root>.tiptap:after{content:"";display:block;height:1px}.mt-rich-text-editor-editor:focus-within{outline:none}.mt-rich-text-editor-content{flex-grow:1;min-height:0}.mt-rich-text-editor-toolbar{border-bottom:1px solid #ccc}.mt-rich-text-editor-statusbar{border-top:1px solid #ccc}.mt-rich-text-editor-resize-handle{position:absolute;right:0;bottom:0;width:15px;height:15px;cursor:ns-resize;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='15' height='15' viewBox='0 0 15 15'%3E%3Cpath d='M11 15 L15 11 M7 15 L15 7' stroke='%23666666' stroke-width='1' fill='none'/%3E%3C/svg%3E")}.mt-rich-text-editor-editor--fullscreen .mt-rich-text-editor-resize-handle{display:none}.mt-rich-text-editor-editor--inline,.mt-rich-text-editor-editor--inline .mt-rich-text-editor-content,.mt-rich-text-editor-content-root{display:flex;flex-direction:column;flex-grow:1}.tiptap{flex-grow:1}.mt-rich-text-editor-toolbar--inline,.mt-rich-text-editor-statusbar--inline{border:none}.mt-rich-text-editor-editor--inline .mt-rich-text-editor-resize-handle{display:none}`, u3 = ':host{--table-border-color: #ccc;--table-header-background-color: #f0f0f0;--table-header-text-color: #333;--table-header-font-weight: bold;--table-header-text-align: left;--table-selected-cell-background-color: #f0f0f0;--table-resize-handle-background-color: #ccc}table{border-collapse:collapse;margin:0;overflow:hidden;table-layout:fixed;width:100%}table td,table th{border:1px solid var(--table-border-color);box-sizing:border-box;min-width:1em;padding:6px 8px;position:relative;vertical-align:top}:is(table td,table th)>*{margin-bottom:0}table th{background-color:var(--table-header-background-color);color:var(--table-header-text-color);font-weight:var(--table-header-font-weight);text-align:var(--table-header-text-align)}table .selectedCell:after{background:var(--table-selected-cell-background-color);content:"";left:0;right:0;top:0;bottom:0;pointer-events:none;position:absolute;z-index:2}table .column-resize-handle{background-color:var(--table-resize-handle-background-color);bottom:-2px;pointer-events:none;position:absolute;right:-2px;top:0;width:4px}.tableWrapper{margin:1.5rem 0;overflow-x:auto}.resize-cursor{cursor:col-resize}.mt-rich-text-editor-script:before{content:attr(data-mt-rich-text-editor-script-title);display:block;position:absolute;top:-13px;left:10px;background-color:#fff;padding:0 5px}.mt-rich-text-editor-script{position:relative;border:1px solid #ccc;border-radius:4px;margin-top:10px;padding:10px}.mt-rich-text-editor-script.mt-rich-text-editor-script--preview{padding:10px 0 0}', d3 = 350, f3 = 300, vn = Symbol("EditorEl");
var Fp, Or, Xt, Pn, $i, Xs, Ys, Nr, Zs, mi, Lr, Xa, rb;
Fp = vn;
class h3 {
  constructor(e, t) {
    Le(this, Xa);
    _n(this, "id");
    _n(this, "tiptap");
    _n(this, Fp);
    _n(this, "options");
    Le(this, Or);
    Le(this, Xt);
    Le(this, Pn);
    Le(this, $i);
    Le(this, Xs);
    Le(this, Ys);
    Le(this, Nr);
    Le(this, Zs);
    Le(this, mi);
    Le(this, Lr);
    var m, g, v, x, w, S;
    this.id = e.id, Oe(this, Pn, e), this.options = t, Oe(this, Lr, ((m = t.htmlOutputOptions) == null ? void 0 : m.format) === !1 ? void 0 : {
      indent_size: ((g = t.htmlOutputOptions) == null ? void 0 : g.indentSize) ?? 0,
      wrap_line_length: 0,
      content_unformatted: ((v = t.htmlOutputOptions) == null ? void 0 : v.contentUnformatted) ?? [
        "pre",
        "style",
        "script"
      ]
    });
    const i = t.inline ?? !1, r = typeof t.height == "number" ? `${t.height}px` : t.height ?? `${localStorage.getItem("mt-rich-text-editor-height") ?? d3}px`;
    Oe(this, Xt, document.createElement("div")), G(this, Xt).className = "mt-rich-text-editor", i ? G(this, Xt).style.minHeight = r : G(this, Xt).style.height = r, G(this, Xt).dataset.mtRichTextEditorId = e.id, (x = G(this, Pn).parentNode) == null || x.insertBefore(G(this, Xt), G(this, Pn)), G(this, Pn).style.display = "none";
    const s = G(this, Xt).attachShadow({ mode: "open" });
    Nc(s, [zp, ...t.editorStylesheets ?? []]), this[vn] = document.createElement("div"), this[vn].classList.add("mt-rich-text-editor-editor"), i && (this[vn].classList.add("mt-rich-text-editor-editor--inline"), this[vn].style.minHeight = r), s.appendChild(this[vn]);
    const o = (k, C) => {
      const A = (k ?? (() => {
        const T = document.createElement("div");
        return T.className = C, i && T.classList.add(`${C}--inline`), this[vn].appendChild(T), T;
      })()).attachShadow({ mode: "open" });
      Nc(A, t.editorStylesheets ?? []);
      const _ = document.createElement("div");
      return A.appendChild(_), _;
    }, a = o(
      t.toolbarContainer,
      (w = t.toolbar) != null && w.length ? "mt-rich-text-editor-toolbar" : "mt-rich-text-editor-toolbar--empty"
    );
    Oe(this, $i, document.createElement("div")), G(this, $i).className = "mt-rich-text-editor-content";
    const l = G(this, $i).attachShadow({ mode: "open" });
    Nc(l, [
      c3 + zp + u3,
      ...t.editorStylesheets ?? [],
      ...t.stylesheets ?? []
    ]);
    const c = document.createElement("div");
    c.className = "mt-rich-text-editor-content-root", l.appendChild(c), this[vn].appendChild(G(this, $i));
    const u = (k) => {
      Oe(this, Or, k);
    }, d = (...k) => {
      var C;
      return ((C = G(this, Or)) == null ? void 0 : C.call(this, ...k)) ?? !1;
    }, f = document.createElement("div");
    f.className = "mt-rich-text-editor-paste-menu", l.appendChild(f), this.tiptap = new u_({
      element: c,
      extensions: [xT.configure(t.extensionOptions), ...t.extensions ?? []],
      content: _r(G(this, Pn).value),
      editorProps: {
        handlePaste: d
      }
    }), (t.autoFocus ?? i) && this.focus(), Oe(this, Xs, new UO({
      target: a,
      editor: this,
      toolbar: t.toolbar,
      options: t.toolbarOptions ?? {},
      inline: i && !t.toolbarContainer
    }));
    const h = o(
      t.statusbarContainer,
      (S = t.statusbar) != null && S.length ? "mt-rich-text-editor-statusbar" : "mt-rich-text-editor-statusbar--empty"
    );
    Oe(this, Ys, new JO({
      target: h,
      editor: this,
      statusbar: t.statusbar ?? [],
      options: t.statusbarOptions ?? {},
      inline: i && !t.statusbarContainer
    }));
    const p = o(f, "mt-rich-text-editor-paste-menu");
    Oe(this, Nr, new t3({
      target: p,
      editor: this,
      onPaste: u,
      pasteMenu: t.pasteMenu ?? [],
      options: t.pasteMenuOptions ?? {},
      inline: i
    }));
    const b = document.createElement("div");
    l.appendChild(b), Oe(this, Zs, new s3({
      target: b,
      editor: this,
      quickAction: t.quickAction ?? [],
      options: t.quickActionOptions ?? {}
    })), bo(this, Xa, rb).call(this, this[vn]), t.structure && this.setStructureMode(!0);
  }
  save() {
    G(this, Pn).value = this.getContent();
  }
  getContent() {
    return G(this, Lr) === void 0 ? Ic(this.tiptap.getHTML()) : y_.html(Ic(this.tiptap.getHTML()), G(this, Lr));
  }
  setContent(e) {
    this.tiptap.commands.setContent(_r(e)), G(this, Pn).value = e;
  }
  getHeight() {
    return G(this, Xt).clientHeight;
  }
  setHeight(e) {
    e !== 0 && (G(this, Xt).style.height = `${e}px`, localStorage.setItem("mt-rich-text-editor-height", e.toString()));
  }
  getStructureMode() {
    return G(this, mi) !== void 0;
  }
  setStructureMode(e) {
    var t;
    e ? Oe(this, mi, new l3(this)) : ((t = G(this, mi)) == null || t.destroy(), Oe(this, mi, void 0));
  }
  focus() {
    this.tiptap.commands.focus();
  }
  destroy() {
    var e;
    Oe(this, Or, void 0), G(this, Xs).destroy(), G(this, Ys).destroy(), G(this, Nr).destroy(), (e = G(this, mi)) == null || e.destroy(), G(this, Zs).destroy(), this.tiptap.destroy(), G(this, Xt).remove();
  }
  insertContent(e) {
    const t = Rg(_r(e), this.tiptap.extensionManager.extensions);
    this.tiptap.commands.insertContent(t);
  }
  notify({ message: e }) {
    alert(e);
  }
  isPasting() {
    return G(this, Nr).isPasting();
  }
}
Or = new WeakMap(), Xt = new WeakMap(), Pn = new WeakMap(), $i = new WeakMap(), Xs = new WeakMap(), Ys = new WeakMap(), Nr = new WeakMap(), Zs = new WeakMap(), mi = new WeakMap(), Lr = new WeakMap(), Xa = new WeakSet(), rb = function(e) {
  const t = document.createElement("div");
  t.className = "mt-rich-text-editor-resize-handle", e.appendChild(t);
  let i = 0, r = 0;
  const s = (l) => {
    l.preventDefault(), i = l.clientY, r = this.getHeight(), document.addEventListener("mousemove", o), document.addEventListener("mouseup", a);
  }, o = (l) => {
    const c = l.clientY - i, u = Math.max(f3, r + c);
    this.setHeight(u);
  }, a = () => {
    document.removeEventListener("mousemove", o), document.removeEventListener("mouseup", a);
  };
  t.addEventListener("mousedown", s);
};
var Bi, Qs, ku;
const jt = class jt {
  static on(e, t) {
    G(this, Bi)[e] || (G(this, Bi)[e] = []), G(this, Bi)[e].push(t);
  }
  static async create(e) {
    const { id: t, language: i } = e;
    if (i && Qe.language !== i && Qe.changeLanguage(i), jt.Editors[t])
      throw new Error("Editor already exists");
    const r = document.querySelector(`#${t}`);
    if (!r)
      throw new Error("Textarea not found");
    const s = {
      toolbar: [],
      toolbarOptions: {},
      statusbar: [["path"]],
      statusbarOptions: {},
      pasteMenu: ["embedInline", "embed", "html", "link", "text", "markdown"],
      pasteMenuOptions: {},
      quickAction: ["heading:1", "heading:2", "heading:3", "heading:4", "heading:5", "heading:6"],
      quickActionOptions: {},
      extensions: [],
      inline: !1,
      ...e
    };
    bo(this, Qs, ku).call(this, "create", s);
    const { id: o, language: a, ...l } = s, c = new h3(r, l);
    return bo(this, Qs, ku).call(this, "init", c), jt.Editors[t] = c, c;
  }
  static unload({ id: e }) {
    jt.Editors[e] && (jt.Editors[e].destroy(), delete jt.Editors[e]);
  }
  static get({ id: e }) {
    return jt.Editors[e];
  }
  static async save() {
    await Promise.all(Object.values(jt.Editors).map((e) => e.save()));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static async import(e) {
    if (e === "@tiptap/core")
      return Y2;
    throw new Error(`Unknown module: ${e}`);
  }
  static setLanguage(e) {
    Qe.language !== e && Qe.changeLanguage(e);
  }
};
Bi = new WeakMap(), Qs = new WeakSet(), ku = function(e, ...t) {
  (G(this, Bi)[e] || []).forEach((r) => r(...t));
}, Le(jt, Qs), _n(jt, "version", n1), _n(jt, "Editors", {}), _n(jt, "Component", {
  ...t1,
  getPanelItem: Jr
}), Le(jt, Bi, {});
let Hp = jt;
export {
  h3 as Editor,
  Hp as default
};
//# sourceMappingURL=index.js.map
